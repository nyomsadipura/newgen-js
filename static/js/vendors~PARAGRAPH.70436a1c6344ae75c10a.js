(this["fb_mf"] = this["fb_mf"] || []).push([[79],{

/***/ 1009:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2017 JiHong Lee.
 * MIT license.
 */


(function (global, factory) {
  if ( true && typeof module.exports === 'object') {
    module.exports = global.document ? factory(global, true) : function (w) {
      if (!w.document) {
        throw new Error('SUNEDITOR_LANG a window with a document');
      }
      return factory(w);
    };
  } else {
    factory(global);
  }
})(typeof window !== 'undefined' ? window : this, function (window, noGlobal) {
  var lang = {
    code: 'ckb',
    toolbar: {
      default: 'بنه‌ڕه‌ت',
      save: 'پاشه‌كه‌وتكردن',
      font: 'فۆنت',
      formats: 'Formats',
      fontSize: 'قه‌باره‌',
      bold: 'تۆخكردن',
      underline: 'هێڵ به‌ژێردا بێنه‌',
      italic: 'لار',
      strike: 'هێڵ به‌ناودا بێنه‌',
      subscript: 'ژێرسکریپت',
      superscript: 'سەرنووس',
      removeFormat: 'لابردنی فۆرمات',
      fontColor: 'ره‌نگی فۆنت',
      hiliteColor: 'ره‌نگی دیاركراو',
      indent: 'بۆشایی بەجێهێشتن',
      outdent: 'لابردنی بۆشایی',
      align: 'ئاراسته‌',
      alignLeft: 'لای چه‌پ',
      alignRight: 'لای راست',
      alignCenter: 'ناوه‌ند',
      alignJustify: 'به‌رێكی دابه‌ش بكه‌',
      list: 'لیست',
      orderList: 'لیستی ریزكراو',
      unorderList: 'لیستی ریزنه‌كراو',
      horizontalRule: 'هێڵی ئاسۆیی',
      hr_solid: 'پته‌و',
      hr_dotted: 'نوكته‌ نوكته‌',
      hr_dashed: 'داش داش',
      table: 'خشته‌',
      link: 'به‌سته‌ر',
      math: 'بیركاری',
      image: 'وێنه‌',
      video: 'ڤیدیۆ',
      audio: 'ده‌نگ',
      fullScreen: 'پڕ به‌ شاشه‌',
      showBlocks: 'بڵۆك نیشانبده',
      codeView: 'بینینی كۆده‌كان',
      undo: 'وەک خۆی لێ بکەوە',
      redo: 'هەڵگەڕاندنەوە',
      preview: 'پێشبینین',
      print: 'پرینت',
      tag_p: 'په‌ره‌گراف',
      tag_div: 'ی ئاسایی (DIV)',
      tag_h: 'سەرپەڕە',
      tag_blockquote: 'ده‌ق',
      tag_pre: 'كۆد',
      template: 'قاڵب',
      lineHeight: 'بڵندی دێر',
      paragraphStyle: 'ستایلی په‌ره‌گراف',
      textStyle: 'ستایلی نوسین',
      imageGallery: 'گاله‌ری وێنه‌كان',
      dir_ltr: 'من اليسار إلى اليمين',
      dir_rtl: 'من اليمين الى اليسار',
      mention: 'تنويه ب'
    },
    dialogBox: {
      linkBox: {
        title: 'به‌سته‌ر دابنێ',
        url: 'به‌سته‌ر',
        text: 'تێكستی به‌سته‌ر',
        newWindowCheck: 'له‌ په‌نجه‌ره‌یه‌كی نوێ بكه‌ره‌وه‌',
        downloadLinkCheck: 'رابط التحميل',
        bookmark: 'المرجعية'
      },
      mathBox: {
        title: 'بیركاری',
        inputLabel: 'نیشانه‌كانی بیركاری',
        fontSizeLabel: 'قه‌باره‌ی فۆنت',
        previewLabel: 'پێشبینین'
      },
      imageBox: {
        title: 'وێنه‌یه‌ك دابنێ',
        file: 'فایلێك هه‌ڵبژێره‌',
        url: 'به‌سته‌ری وێنه‌',
        altText: 'نوسینی جێگره‌وه‌'
      },
      videoBox: {
        title: 'ڤیدیۆیه‌ك دابنێ',
        file: 'فایلێك هه‌ڵبژێره‌',
        url: 'YouTube/Vimeo به‌سته‌ری له‌ناودانان وه‌ك '
      },
      audioBox: {
        title: 'ده‌نگێك دابنێ',
        file: 'فایلێك هه‌ڵبژێره‌',
        url: 'به‌سته‌ری ده‌نگ'
      },
      browser: {
        tags: 'تاگه‌كان',
        search: 'گه‌ران'
      },
      caption: 'پێناسه‌یه‌ك دابنێ',
      close: 'داخستن',
      submitButton: 'ناردن',
      revertButton: 'بیگەڕێنەوە سەر باری سەرەتایی',
      proportion: 'رێژه‌كان وه‌ك خۆی بهێڵه‌وه‌',
      basic: 'سه‌ره‌تایی',
      left: 'چه‌پ',
      right: 'راست',
      center: 'ناوەڕاست',
      width: 'پانی',
      height: 'به‌رزی',
      size: 'قه‌باره‌',
      ratio: 'رێژه‌'
    },
    controller: {
      edit: 'دەسکاریکردن',
      unlink: 'سڕینەوەی بەستەر',
      remove: 'سڕینه‌وه‌',
      insertRowAbove: 'ریزك له‌ سه‌ره‌وه‌ زیادبكه‌',
      insertRowBelow: 'ریزێك له‌ خواره‌وه‌ زیادبكه‌',
      deleteRow: 'ریز بسره‌وه‌',
      insertColumnBefore: 'ستونێك له‌ پێشه‌وه‌ زیادبكه‌',
      insertColumnAfter: 'ستونێك له‌ دواوه‌ زیادبكه‌',
      deleteColumn: 'ستونێك بسره‌وه‌',
      fixedColumnWidth: 'پانی ستون نه‌گۆربكه‌',
      resize100: 'قه‌باره‌ بگۆره‌ بۆ ١٠٠%',
      resize75: 'قه‌باره‌ بگۆره‌ بۆ ٧٥%',
      resize50: 'قه‌باره‌ بگۆره‌ بۆ ٥٠%',
      resize25: 'قه‌باره‌ بگۆره‌ بۆ ٢٥%',
      autoSize: 'قه‌باره‌ی خۆكارانه‌',
      mirrorHorizontal: 'هه‌ڵگه‌رێنه‌وه‌ به‌ده‌وری ته‌وه‌ره‌ی ئاسۆیی',
      mirrorVertical: 'هه‌ڵگه‌رێنه‌وه‌ به‌ده‌وری ته‌وه‌ره‌ی ستونی',
      rotateLeft: 'بسوڕێنه‌ به‌لای چه‌پدا',
      rotateRight: 'بسورێنه‌ به‌لای راستدا',
      maxSize: 'گه‌وره‌ترین قه‌باره‌',
      minSize: 'بچوكترین قه‌باره‌',
      tableHeader: 'سه‌ردێری خشته‌ك',
      mergeCells: 'خانه‌كان تێكه‌ڵبكه‌',
      splitCells: 'خانه‌كان لێك جیابكه‌وه‌',
      HorizontalSplit: 'جیاكردنه‌وه‌ی ئاسۆیی',
      VerticalSplit: 'جیاكردنه‌وه‌ی ستونی'
    },
    menu: {
      spaced: 'بۆشای هه‌بێت',
      bordered: 'لێواری هه‌بێت',
      neon: 'نیۆن',
      translucent: 'كه‌مێك وه‌ك شووشه‌',
      shadow: 'سێبه‌ر',
      code: 'كۆد'
    }
  };
  if (typeof noGlobal === typeof undefined) {
    if (!window.SUNEDITOR_LANG) {
      Object.defineProperty(window, 'SUNEDITOR_LANG', {
        enumerable: true,
        writable: false,
        configurable: false,
        value: {}
      });
    }
    Object.defineProperty(window.SUNEDITOR_LANG, 'ckb', {
      enumerable: true,
      writable: true,
      configurable: true,
      value: lang
    });
  }
  return lang;
});

/***/ }),

/***/ 1010:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2017 JiHong Lee.
 * 
 * Danish translation by davidkonrad at github or gmail
 *
 * MIT license.
 */


(function (global, factory) {
  if ( true && typeof module.exports === 'object') {
    module.exports = global.document ? factory(global, true) : function (w) {
      if (!w.document) {
        throw new Error('SUNEDITOR_LANG a window with a document');
      }
      return factory(w);
    };
  } else {
    factory(global);
  }
})(typeof window !== 'undefined' ? window : this, function (window, noGlobal) {
  var lang = {
    code: 'da',
    toolbar: {
      default: 'Default',
      save: 'Gem',
      font: 'Skrifttype',
      formats: 'Format',
      fontSize: 'Skriftstørrelse',
      bold: 'Fed',
      underline: 'Understreget',
      italic: 'Skråskrift',
      strike: 'Overstreget',
      subscript: 'Sænket skrift',
      superscript: 'Hævet skrift',
      removeFormat: 'Fjern formatering',
      fontColor: 'Skriftfarve',
      hiliteColor: 'Baggrundsfarve',
      indent: 'Ryk ind',
      outdent: 'Ryk ud',
      align: 'Justering',
      alignLeft: 'Venstrejustering',
      alignRight: 'Højrejustering',
      alignCenter: 'Midterjustering',
      alignJustify: 'Tilpas margin',
      list: 'Lister',
      orderList: 'Nummereret liste',
      unorderList: 'Uordnet liste',
      horizontalRule: 'Horisontal linie',
      hr_solid: 'Almindelig',
      hr_dotted: 'Punkteret',
      hr_dashed: 'Streget',
      table: 'Tabel',
      link: 'Link',
      math: 'Math',
      image: 'Billede',
      video: 'Video',
      audio: 'Audio',
      fullScreen: 'Fuld skærm',
      showBlocks: 'Vis blokke',
      codeView: 'Vis koder',
      undo: 'Undo',
      redo: 'Redo',
      preview: 'Preview',
      print: 'Print',
      tag_p: 'Paragraph',
      tag_div: 'Normal (DIV)',
      tag_h: 'Overskrift',
      tag_blockquote: 'Citer',
      tag_pre: 'Code',
      template: 'Schablone',
      lineHeight: 'Linjehøjde',
      paragraphStyle: 'Afsnitstil',
      textStyle: 'Tekststil',
      imageGallery: 'Billedgalleri',
      dir_ltr: 'Venstre til højre',
      dir_rtl: 'Højre til venstre',
      mention: 'Nævne'
    },
    dialogBox: {
      linkBox: {
        title: 'Indsæt link',
        url: 'URL til link',
        text: 'Tekst for link',
        newWindowCheck: 'Åben i nyt faneblad',
        downloadLinkCheck: 'Download link',
        bookmark: 'Bogmærke'
      },
      mathBox: {
        title: 'Math',
        inputLabel: 'Matematisk notation',
        fontSizeLabel: 'Skriftstørrelse',
        previewLabel: 'Preview'
      },
      imageBox: {
        title: 'Indsæt billede',
        file: 'Indsæt fra fil',
        url: 'Indsæt fra URL',
        altText: 'Alternativ tekst'
      },
      videoBox: {
        title: 'Indsæt Video',
        file: 'Indsæt fra fil',
        url: 'Indlejr video / YouTube,Vimeo'
      },
      audioBox: {
        title: 'Indsæt Audio',
        file: 'Indsæt fra fil',
        url: 'Indsæt fra URL'
      },
      browser: {
        tags: 'Tags',
        search: 'Søg'
      },
      caption: 'Indsæt beskrivelse',
      close: 'Luk',
      submitButton: 'Gennemfør',
      revertButton: 'Gendan',
      proportion: 'Bevar proportioner',
      basic: 'Basis',
      left: 'Venstre',
      right: 'Højre',
      center: 'Center',
      width: 'Bredde',
      height: 'Højde',
      size: 'Størrelse',
      ratio: 'Forhold'
    },
    controller: {
      edit: 'Rediger',
      unlink: 'Fjern link',
      remove: 'Fjern',
      insertRowAbove: 'Indsæt række foroven',
      insertRowBelow: 'Indsæt række nedenfor',
      deleteRow: 'Slet række',
      insertColumnBefore: 'Indsæt kolonne før',
      insertColumnAfter: 'Indsæt kolonne efter',
      deleteColumn: 'Slet kolonne',
      fixedColumnWidth: 'Fast søjlebredde',
      resize100: 'Forstør 100%',
      resize75: 'Forstør 75%',
      resize50: 'Forstør 50%',
      resize25: 'Forstør 25%',
      autoSize: 'Auto størrelse',
      mirrorHorizontal: 'Spejling, horisontal',
      mirrorVertical: 'Spejling, vertikal',
      rotateLeft: 'Roter til venstre',
      rotateRight: 'Toter til højre',
      maxSize: 'Max størrelse',
      minSize: 'Min størrelse',
      tableHeader: 'Tabel overskrift',
      mergeCells: 'Sammenlæg celler (merge)',
      splitCells: 'Opdel celler',
      HorizontalSplit: 'Opdel horisontalt',
      VerticalSplit: 'Opdel vertikalt'
    },
    menu: {
      spaced: 'Brev Afstand',
      bordered: 'Afgrænsningslinje',
      neon: 'Neon',
      translucent: 'Gennemsigtig',
      shadow: 'Skygge',
      code: 'Code'
    }
  };
  if (typeof noGlobal === typeof undefined) {
    if (!window.SUNEDITOR_LANG) {
      Object.defineProperty(window, 'SUNEDITOR_LANG', {
        enumerable: true,
        writable: false,
        configurable: false,
        value: {}
      });
    }
    Object.defineProperty(window.SUNEDITOR_LANG, 'da', {
      enumerable: true,
      writable: true,
      configurable: true,
      value: lang
    });
  }
  return lang;
});

/***/ }),

/***/ 1011:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2019 @Gundolf68
 * MIT license.
 */


(function (global, factory) {
  if ( true && typeof module.exports === 'object') {
    module.exports = global.document ? factory(global, true) : function (w) {
      if (!w.document) {
        throw new Error('SUNEDITOR_LANG a window with a document');
      }
      return factory(w);
    };
  } else {
    factory(global);
  }
})(typeof window !== 'undefined' ? window : this, function (window, noGlobal) {
  var lang = {
    code: 'de',
    toolbar: {
      default: 'Standard',
      save: 'Speichern',
      font: 'Schriftart',
      formats: 'Format',
      fontSize: 'Schriftgröße',
      bold: 'Fett',
      underline: 'Unterstrichen',
      italic: 'Kursiv',
      strike: 'Durchgestrichen',
      subscript: 'Tiefgestellt',
      superscript: 'Hochgestellt',
      removeFormat: 'Format entfernen',
      fontColor: 'Schriftfarbe',
      hiliteColor: 'Farbe für Hervorhebungen',
      indent: 'Einzug vergrößern',
      outdent: 'Einzug verkleinern',
      align: 'Ausrichtung',
      alignLeft: 'Links ausrichten',
      alignRight: 'Rechts ausrichten',
      alignCenter: 'Zentriert ausrichten',
      alignJustify: 'Blocksatz',
      list: 'Liste',
      orderList: 'Nummerierte Liste',
      unorderList: 'Aufzählung',
      horizontalRule: 'Horizontale Linie',
      hr_solid: 'Strich',
      hr_dotted: 'Gepunktet',
      hr_dashed: 'Gestrichelt',
      table: 'Tabelle',
      link: 'Link',
      math: 'Mathematik',
      image: 'Bild',
      video: 'Video',
      audio: 'Audio',
      fullScreen: 'Vollbild',
      showBlocks: 'Blockformatierungen anzeigen',
      codeView: 'Quelltext anzeigen',
      undo: 'Rückgängig',
      redo: 'Wiederholen',
      preview: 'Vorschau',
      print: 'Drucken',
      tag_p: 'Absatz',
      tag_div: 'Normal (DIV)',
      tag_h: 'Header',
      tag_blockquote: 'Zitat',
      tag_pre: 'Quellcode',
      template: 'Vorlage',
      lineHeight: 'Zeilenhöhe',
      paragraphStyle: 'Absatzstil',
      textStyle: 'Textstil',
      imageGallery: 'Bildergalerie',
      dir_ltr: 'Links nach rechts',
      dir_rtl: 'Rechts nach links',
      mention: 'Erwähnen'
    },
    dialogBox: {
      linkBox: {
        title: 'Link einfügen',
        url: 'Link-URL',
        text: 'Link-Text',
        newWindowCheck: 'In neuem Fenster anzeigen',
        downloadLinkCheck: 'Download-Link',
        bookmark: 'Lesezeichen'
      },
      mathBox: {
        title: 'Mathematik',
        inputLabel: 'Mathematische Notation',
        fontSizeLabel: 'Schriftgröße',
        previewLabel: 'Vorschau'
      },
      imageBox: {
        title: 'Bild einfügen',
        file: 'Datei auswählen',
        url: 'Bild-URL',
        altText: 'Alternativer Text'
      },
      videoBox: {
        title: 'Video enfügen',
        file: 'Datei auswählen',
        url: 'Video-URL, YouTube/Vimeo'
      },
      audioBox: {
        title: 'Audio enfügen',
        file: 'Datei auswählen',
        url: 'Audio-URL'
      },
      browser: {
        tags: 'Stichworte',
        search: 'Suche'
      },
      caption: 'Beschreibung eingeben',
      close: 'Schließen',
      submitButton: 'Übernehmen',
      revertButton: 'Rückgängig',
      proportion: 'Seitenverhältnis beibehalten',
      basic: 'Standard',
      left: 'Links',
      right: 'Rechts',
      center: 'Zentriert',
      width: 'Breite',
      height: 'Höhe',
      size: 'Größe',
      ratio: 'Verhältnis'
    },
    controller: {
      edit: 'Bearbeiten',
      unlink: 'Link entfernen',
      remove: 'Löschen',
      insertRowAbove: 'Zeile oberhalb einfügen',
      insertRowBelow: 'Zeile unterhalb einfügen',
      deleteRow: 'Zeile löschen',
      insertColumnBefore: 'Spalte links einfügen',
      insertColumnAfter: 'Spalte rechts einfügen',
      deleteColumn: 'Spalte löschen',
      fixedColumnWidth: 'Feste Spaltenbreite',
      resize100: 'Zoom 100%',
      resize75: 'Zoom 75%',
      resize50: 'Zoom 50%',
      resize25: 'Zoom 25%',
      autoSize: 'Automatische Größenanpassung',
      mirrorHorizontal: 'Horizontal spiegeln',
      mirrorVertical: 'Vertikal spiegeln',
      rotateLeft: 'Nach links drehen',
      rotateRight: 'Nach rechts drehen',
      maxSize: 'Maximale Größe',
      minSize: 'Mindestgröße',
      tableHeader: 'Tabellenüberschrift',
      mergeCells: 'Zellen verbinden',
      splitCells: 'Zellen teilen',
      HorizontalSplit: 'Horizontal teilen',
      VerticalSplit: 'Vertikal teilen'
    },
    menu: {
      spaced: 'Buchstabenabstand',
      bordered: 'Umrandet',
      neon: 'Neon',
      translucent: 'Durchscheinend',
      shadow: 'Schatten',
      code: 'Quellcode'
    }
  };
  if (typeof noGlobal === typeof undefined) {
    if (!window.SUNEDITOR_LANG) {
      Object.defineProperty(window, 'SUNEDITOR_LANG', {
        enumerable: true,
        writable: false,
        configurable: false,
        value: {}
      });
    }
    Object.defineProperty(window.SUNEDITOR_LANG, 'de', {
      enumerable: true,
      writable: true,
      configurable: true,
      value: lang
    });
  }
  return lang;
});

/***/ }),

/***/ 1012:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2017 JiHong Lee.
 * MIT license.
 */


(function (global, factory) {
  if ( true && typeof module.exports === 'object') {
    module.exports = global.document ? factory(global, true) : function (w) {
      if (!w.document) {
        throw new Error('SUNEDITOR_LANG a window with a document');
      }
      return factory(w);
    };
  } else {
    factory(global);
  }
})(typeof window !== 'undefined' ? window : this, function (window, noGlobal) {
  var lang = {
    code: 'es',
    toolbar: {
      default: 'Valor por defecto',
      save: 'Guardar',
      font: 'Fuente',
      formats: 'Formato',
      fontSize: 'Tamaño de fuente',
      bold: 'Negrita',
      underline: 'Subrayado',
      italic: 'Cursiva',
      strike: 'Tachado',
      subscript: 'Subíndice',
      superscript: 'Superíndice',
      removeFormat: 'Eliminar formato',
      fontColor: 'Color de fuente',
      hiliteColor: 'Color de resaltado',
      indent: 'Más tabulación',
      outdent: 'Menos tabulación',
      align: 'Alinear',
      alignLeft: 'Alinear a la izquierda',
      alignRight: 'Alinear a la derecha',
      alignCenter: 'Alinear al centro',
      alignJustify: 'Justificar',
      list: 'Lista',
      orderList: 'Lista ordenada',
      unorderList: 'Lista desordenada',
      horizontalRule: 'Horizontal line',
      hr_solid: 'Línea horizontal solida',
      hr_dotted: 'Línea horizontal punteada',
      hr_dashed: 'Línea horizontal discontinua',
      table: 'Tabla',
      link: 'Link',
      math: 'Matemáticas',
      image: 'Imagen',
      video: 'Video',
      audio: 'Audio',
      fullScreen: 'Pantalla completa',
      showBlocks: 'Ver bloques',
      codeView: 'Ver código fuente',
      undo: 'UndoDeshacer última acción',
      redo: 'Rehacer última acción',
      preview: 'Vista previa',
      print: 'Imprimir',
      tag_p: 'Párrafo',
      tag_div: 'Normal (DIV)',
      tag_h: 'Header',
      tag_blockquote: 'Cita',
      tag_pre: 'Código',
      template: 'Plantilla',
      lineHeight: 'Altura de la línea',
      paragraphStyle: 'Estilo del parrafo',
      textStyle: 'Estilo del texto',
      imageGallery: 'Galería de imágenes',
      dir_ltr: 'De izquierda a derecha',
      dir_rtl: 'De derecha a izquierda',
      mention: 'Mencionar'
    },
    dialogBox: {
      linkBox: {
        title: 'Insertar Link',
        url: '¿Hacia que URL lleva el link?',
        text: 'Texto para mostrar',
        newWindowCheck: 'Abrir en una nueva ventana',
        downloadLinkCheck: 'Enlace de descarga',
        bookmark: 'Marcador'
      },
      mathBox: {
        title: 'Matemáticas',
        inputLabel: 'Notación Matemática',
        fontSizeLabel: 'Tamaño de fuente',
        previewLabel: 'Vista previa'
      },
      imageBox: {
        title: 'Insertar imagen',
        file: 'Seleccionar desde los archivos',
        url: 'URL de la imagen',
        altText: 'Texto alternativo'
      },
      videoBox: {
        title: 'Insertar Video',
        file: 'Seleccionar desde los archivos',
        url: '¿URL del vídeo? Youtube/Vimeo'
      },
      audioBox: {
        title: 'Insertar Audio',
        file: 'Seleccionar desde los archivos',
        url: 'URL de la audio'
      },
      browser: {
        tags: 'Etiquetas',
        search: 'Buscar'
      },
      caption: 'Insertar descripción',
      close: 'Cerrar',
      submitButton: 'Enviar',
      revertButton: 'revertir',
      proportion: 'Restringir las proporciones',
      basic: 'Basico',
      left: 'Izquierda',
      right: 'derecha',
      center: 'Centro',
      width: 'Ancho',
      height: 'Alto',
      size: 'Tamaño',
      ratio: 'Proporción'
    },
    controller: {
      edit: 'Editar',
      unlink: 'Desvincular',
      remove: 'RemoveQuitar',
      insertRowAbove: 'Insertar fila arriba',
      insertRowBelow: 'Insertar fila debajo',
      deleteRow: 'Eliminar fila',
      insertColumnBefore: 'Insertar columna antes',
      insertColumnAfter: 'Insertar columna después',
      deleteColumn: 'Eliminar columna',
      fixedColumnWidth: 'Ancho de columna fijo',
      resize100: 'Redimensionar 100%',
      resize75: 'Redimensionar 75%',
      resize50: 'Redimensionar 50%',
      resize25: 'Redimensionar 25%',
      autoSize: 'Tamaño automático',
      mirrorHorizontal: 'Espejo, Horizontal',
      mirrorVertical: 'Espejo, Vertical',
      rotateLeft: 'Girar a la izquierda',
      rotateRight: 'Girar a la derecha',
      maxSize: 'Tamaño máximo',
      minSize: 'Tamaño minímo',
      tableHeader: 'Encabezado de tabla',
      mergeCells: 'Combinar celdas',
      splitCells: 'Dividir celdas',
      HorizontalSplit: 'División horizontal',
      VerticalSplit: 'División vertical'
    },
    menu: {
      spaced: 'Espaciado',
      bordered: 'Bordeado',
      neon: 'Neón',
      translucent: 'Translúcido',
      shadow: 'Sombreado',
      code: 'Código'
    }
  };
  if (typeof noGlobal === typeof undefined) {
    if (!window.SUNEDITOR_LANG) {
      Object.defineProperty(window, 'SUNEDITOR_LANG', {
        enumerable: true,
        writable: false,
        configurable: false,
        value: {}
      });
    }
    Object.defineProperty(window.SUNEDITOR_LANG, 'es', {
      enumerable: true,
      writable: true,
      configurable: true,
      value: lang
    });
  }
  return lang;
});

/***/ }),

/***/ 1013:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2019 JiHong Lee.
 * MIT license.
 */


(function (global, factory) {
  if ( true && typeof module.exports === 'object') {
    module.exports = global.document ? factory(global, true) : function (w) {
      if (!w.document) {
        throw new Error('SUNEDITOR_LANG a window with a document');
      }
      return factory(w);
    };
  } else {
    factory(global);
  }
})(typeof window !== 'undefined' ? window : this, function (window, noGlobal) {
  var lang = {
    code: 'fr',
    toolbar: {
      default: 'Défaut',
      save: 'Sauvegarder',
      font: 'Police',
      formats: 'Formats',
      fontSize: 'Taille',
      bold: 'Gras',
      underline: 'Souligné',
      italic: 'Italique',
      strike: 'Barré',
      subscript: 'Indice',
      superscript: 'Exposant',
      removeFormat: 'Effacer le formatage',
      fontColor: 'Couleur du texte',
      hiliteColor: 'Couleur en arrière plan',
      indent: 'Indenter',
      outdent: 'Désindenter',
      align: 'Alignement',
      alignLeft: 'À gauche',
      alignRight: 'À droite',
      alignCenter: 'Centré',
      alignJustify: 'Justifié',
      list: 'Liste',
      orderList: 'Ordonnée',
      unorderList: 'Non-ordonnée',
      horizontalRule: 'Ligne horizontale',
      hr_solid: 'Solide',
      hr_dotted: 'Points',
      hr_dashed: 'Tirets',
      table: 'Table',
      link: 'Lien',
      math: 'Math',
      image: 'Image',
      video: 'Video',
      audio: 'Audio',
      fullScreen: 'Plein écran',
      showBlocks: 'Voir les blocs',
      codeView: 'Voir le code',
      undo: 'Annuler',
      redo: 'Rétablir',
      preview: 'Prévisualiser',
      print: 'Imprimer',
      tag_p: 'Paragraphe',
      tag_div: 'Normal (DIV)',
      tag_h: 'Titre',
      tag_blockquote: 'Citation',
      tag_pre: 'Code',
      template: 'Template',
      lineHeight: 'Hauteur de la ligne',
      paragraphStyle: 'Style de paragraphe',
      textStyle: 'Style de texte',
      imageGallery: 'Galerie d\'images',
      dir_ltr: 'De gauche à droite',
      dir_rtl: 'De droite à gauche',
      mention: 'Mention'
    },
    dialogBox: {
      linkBox: {
        title: 'Insérer un lien',
        url: 'Adresse URL du lien',
        text: 'Texte à afficher',
        newWindowCheck: 'Ouvrir dans une nouvelle fenêtre',
        downloadLinkCheck: 'Lien de téléchargement',
        bookmark: 'Signet'
      },
      mathBox: {
        title: 'Math',
        inputLabel: 'Notation mathématique',
        fontSizeLabel: 'Taille',
        previewLabel: 'Prévisualiser'
      },
      imageBox: {
        title: 'Insérer une image',
        file: 'Sélectionner le fichier',
        url: 'Adresse URL du fichier',
        altText: 'Texte Alternatif'
      },
      videoBox: {
        title: 'Insérer une vidéo',
        file: 'Sélectionner le fichier',
        url: 'URL d’intégration du média, YouTube/Vimeo'
      },
      audioBox: {
        title: 'Insérer un fichier audio',
        file: 'Sélectionner le fichier',
        url: 'Adresse URL du fichier'
      },
      browser: {
        tags: 'Mots clés',
        search: 'Chercher'
      },
      caption: 'Insérer une description',
      close: 'Fermer',
      submitButton: 'Appliquer',
      revertButton: 'Revenir en arrière',
      proportion: 'Maintenir le rapport hauteur/largeur',
      basic: 'Basique',
      left: 'Gauche',
      right: 'Droite',
      center: 'Centré',
      width: 'Largeur',
      height: 'Hauteur',
      size: 'Taille',
      ratio: 'Rapport'
    },
    controller: {
      edit: 'Modifier',
      unlink: 'Supprimer un lien',
      remove: 'Effacer',
      insertRowAbove: 'Insérer une ligne en dessous',
      insertRowBelow: 'Insérer une ligne au dessus',
      deleteRow: 'Effacer la ligne',
      insertColumnBefore: 'Insérer une colonne avant',
      insertColumnAfter: 'Insérer une colonne après',
      deleteColumn: 'Effacer la colonne',
      fixedColumnWidth: 'Largeur de colonne fixe',
      resize100: 'Redimensionner à 100%',
      resize75: 'Redimensionner à 75%',
      resize50: 'Redimensionner à 50%',
      resize25: 'Redimensionner à 25%',
      autoSize: 'Taille automatique',
      mirrorHorizontal: 'Mirroir, Horizontal',
      mirrorVertical: 'Mirroir, Vertical',
      rotateLeft: 'Rotation à gauche',
      rotateRight: 'Rotation à droite',
      maxSize: 'Taille max',
      minSize: 'Taille min',
      tableHeader: 'En-tête de table',
      mergeCells: 'Fusionner les cellules',
      splitCells: 'Diviser les Cellules',
      HorizontalSplit: 'Scission horizontale',
      VerticalSplit: 'Scission verticale'
    },
    menu: {
      spaced: 'Espacement',
      bordered: 'Ligne de démarcation',
      neon: 'Néon',
      translucent: 'Translucide',
      shadow: 'Ombre',
      code: 'Code'
    }
  };
  if (typeof noGlobal === typeof undefined) {
    if (!window.SUNEDITOR_LANG) {
      Object.defineProperty(window, 'SUNEDITOR_LANG', {
        enumerable: true,
        writable: false,
        configurable: false,
        value: {}
      });
    }
    Object.defineProperty(window.SUNEDITOR_LANG, 'fr', {
      enumerable: true,
      writable: true,
      configurable: true,
      value: lang
    });
  }
  return lang;
});

/***/ }),

/***/ 1014:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2017 JiHong Lee.
 * MIT license.
 */


(function (global, factory) {
  if ( true && typeof module.exports === 'object') {
    module.exports = global.document ? factory(global, true) : function (w) {
      if (!w.document) {
        throw new Error('SUNEDITOR_LANG a window with a document');
      }
      return factory(w);
    };
  } else {
    factory(global);
  }
})(typeof window !== 'undefined' ? window : this, function (window, noGlobal) {
  var lang = {
    code: 'he',
    toolbar: {
      default: 'ברירת מחדל',
      save: 'שמור',
      font: 'גופן',
      formats: 'עיצוב',
      fontSize: 'גודל',
      bold: 'מודגש',
      underline: 'קו תחתון',
      italic: 'נטוי',
      strike: 'קו חוצה',
      subscript: 'עילי',
      superscript: 'תחתי',
      removeFormat: 'הסר עיצוב',
      fontColor: 'צבע גופן',
      hiliteColor: 'צבע קו תחתון',
      indent: 'הגדל כניסה',
      outdent: 'הקטן כניסה',
      align: 'יישור',
      alignLeft: 'יישר לשמאל',
      alignRight: 'יישר לימין',
      alignCenter: 'מרכז',
      alignJustify: 'יישר לשני הצדדים',
      list: 'רשימה',
      orderList: 'מספור',
      unorderList: 'תבליטים',
      horizontalRule: 'קו אופקי',
      hr_solid: 'קו',
      hr_dotted: 'נקודות',
      hr_dashed: 'מקפים',
      table: 'טבלה',
      link: 'קישור',
      math: 'מתמטיקה',
      image: 'תמונה',
      video: 'חוזי',
      audio: 'שמע',
      fullScreen: 'מסך מלא',
      showBlocks: 'הצג גושים',
      codeView: 'הצג קוד',
      undo: 'בטל',
      redo: 'חזור',
      preview: 'תצוגה מקדימה',
      print: 'הדפס',
      tag_p: 'פסקה',
      tag_div: 'רגילה (DIV)',
      tag_h: 'כותרת',
      tag_blockquote: 'ציטוט',
      tag_pre: 'קוד',
      template: 'תבנית',
      lineHeight: 'גובה השורה',
      paragraphStyle: 'סגנון פסקה',
      textStyle: 'סגנון גופן',
      imageGallery: 'גלרית תמונות',
      dir_ltr: 'משמאל לימין',
      dir_rtl: 'מימין לשמאל',
      mention: 'הזכר'
    },
    dialogBox: {
      linkBox: {
        title: 'הכנס קשור',
        url: 'כתובת קשור',
        text: 'תיאור',
        newWindowCheck: 'פתח בחלון חדש',
        downloadLinkCheck: 'קישור להורדה',
        bookmark: 'סמניה'
      },
      mathBox: {
        title: 'נוסחה',
        inputLabel: 'סימנים מתמטים',
        fontSizeLabel: 'גודל גופן',
        previewLabel: 'תצוגה מקדימה'
      },
      imageBox: {
        title: 'הכנס תמונה',
        file: 'בחר מקובץ',
        url: 'כתובת URL תמונה',
        altText: 'תיאור (תגית alt)'
      },
      videoBox: {
        title: 'הכנס סרטון',
        file: 'בחר מקובץ',
        url: 'כתובת הטמעה YouTube/Vimeo'
      },
      audioBox: {
        title: 'הכנס שמע',
        file: 'בחר מקובץ',
        url: 'כתובת URL שמע'
      },
      browser: {
        tags: 'תג',
        search: 'חפש'
      },
      caption: 'הכנס תיאור',
      close: 'סגור',
      submitButton: 'שלח',
      revertButton: 'בטל',
      proportion: 'שמר יחס',
      basic: 'בסיסי',
      left: 'שמאל',
      right: 'ימין',
      center: 'מרכז',
      width: 'רוחב',
      height: 'גובה',
      size: 'גודל',
      ratio: 'יחס'
    },
    controller: {
      edit: 'ערוך',
      unlink: 'הסר קישורים',
      remove: 'הסר',
      insertRowAbove: 'הכנס שורה מעל',
      insertRowBelow: 'הכנס שורה מתחת',
      deleteRow: 'מחק שורה',
      insertColumnBefore: 'הכנס עמודה לפני',
      insertColumnAfter: 'הכנס עמודה אחרי',
      deleteColumn: 'מחק עמודה',
      fixedColumnWidth: 'קבע רוחב עמודות',
      resize100: 'ללא הקטנה',
      resize75: 'הקטן 75%',
      resize50: 'הקטן 50%',
      resize25: 'הקטן 25%',
      autoSize: 'הקטן אוטומטית',
      mirrorHorizontal: 'הפוך לרוחב',
      mirrorVertical: 'הפוך לגובה',
      rotateLeft: 'סובב שמאלה',
      rotateRight: 'סובב ימינה',
      maxSize: 'גודל מרבי',
      minSize: 'גודל מזערי',
      tableHeader: 'כותרת טבלה',
      mergeCells: 'מזג תאים',
      splitCells: 'פצל תא',
      HorizontalSplit: 'פצל לגובה',
      VerticalSplit: 'פצל לרוחב'
    },
    menu: {
      spaced: 'מרווח',
      bordered: 'בעל מיתאר',
      neon: 'זוהר',
      translucent: 'שקוף למחצה',
      shadow: 'צל',
      code: 'קוד'
    }
  };
  if (typeof noGlobal === typeof undefined) {
    if (!window.SUNEDITOR_LANG) {
      Object.defineProperty(window, 'SUNEDITOR_LANG', {
        enumerable: true,
        writable: false,
        configurable: false,
        value: {}
      });
    }
    Object.defineProperty(window.SUNEDITOR_LANG, 'he', {
      enumerable: true,
      writable: true,
      configurable: true,
      value: lang
    });
  }
  return lang;
});

/***/ }),

/***/ 1015:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2017 JiHong Lee.
 * MIT license.
 */


(function (global, factory) {
  if ( true && typeof module.exports === 'object') {
    module.exports = global.document ? factory(global, true) : function (w) {
      if (!w.document) {
        throw new Error('SUNEDITOR_LANG una finestra con un documento');
      }
      return factory(w);
    };
  } else {
    factory(global);
  }
})(typeof window !== 'undefined' ? window : this, function (window, noGlobal) {
  var lang = {
    code: 'it',
    toolbar: {
      default: 'Predefinita',
      save: 'Salva',
      font: 'Font',
      formats: 'Formato',
      fontSize: 'Grandezza',
      bold: 'Grassetto',
      underline: 'Sottolineato',
      italic: 'Corsivo',
      strike: 'Barrato',
      subscript: 'Apice',
      superscript: 'Pedice',
      removeFormat: 'Rimuovi formattazione',
      fontColor: 'Colore testo',
      hiliteColor: 'Colore sottolineatura',
      indent: 'Aumenta rientro',
      outdent: 'Riduci rientro',
      align: 'Allinea',
      alignLeft: 'Allinea a sinistra',
      alignRight: 'Allinea a destra',
      alignCenter: 'Allinea al centro',
      alignJustify: 'Giustifica testo',
      list: 'Elenco',
      orderList: 'Elenco numerato',
      unorderList: 'Elenco puntato',
      horizontalRule: 'Linea orizzontale',
      hr_solid: 'Linea continua',
      hr_dotted: 'Puntini',
      hr_dashed: 'Trattini',
      table: 'Tabella',
      link: 'Collegamento ipertestuale',
      math: 'Formula matematica',
      image: 'Immagine',
      video: 'Video',
      audio: 'Audio',
      fullScreen: 'A tutto schermo',
      showBlocks: 'Visualizza blocchi',
      codeView: 'Visualizza codice',
      undo: 'Annulla',
      redo: 'Ripristina',
      preview: 'Anteprima',
      print: 'Stampa',
      tag_p: 'Paragrafo',
      tag_div: 'Normale (DIV)',
      tag_h: 'Titolo',
      tag_blockquote: 'Citazione',
      tag_pre: 'Codice',
      template: 'Modello',
      lineHeight: 'Interlinea',
      paragraphStyle: 'Stile paragrafo',
      textStyle: 'Stile testo',
      imageGallery: 'Galleria di immagini',
      dir_ltr: 'Da sinistra a destra',
      dir_rtl: 'Da destra a sinistra',
      mention: 'Menzione'
    },
    dialogBox: {
      linkBox: {
        title: 'Inserisci un link',
        url: 'Indirizzo',
        text: 'Testo da visualizzare',
        newWindowCheck: 'Apri in una nuova finestra',
        downloadLinkCheck: 'Link per scaricare',
        bookmark: 'Segnalibro'
      },
      mathBox: {
        title: 'Matematica',
        inputLabel: 'Notazione matematica',
        fontSizeLabel: 'Grandezza testo',
        previewLabel: 'Anteprima'
      },
      imageBox: {
        title: 'Inserisci immagine',
        file: 'Seleziona da file',
        url: 'Indirizzo immagine',
        altText: 'Testo alternativo (ALT)'
      },
      videoBox: {
        title: 'Inserisci video',
        file: 'Seleziona da file',
        url: 'Indirizzo video di embed, YouTube/Vimeo'
      },
      audioBox: {
        title: 'Inserisci audio',
        file: 'Seleziona da file',
        url: 'Indirizzo audio'
      },
      browser: {
        tags: 'tag',
        search: 'Ricerca'
      },
      caption: 'Inserisci didascalia',
      close: 'Chiudi',
      submitButton: 'Invia',
      revertButton: 'Annulla',
      proportion: 'Proporzionale',
      basic: 'Da impostazione',
      left: 'Sinistra',
      right: 'Destra',
      center: 'Centrato',
      width: 'Larghezza',
      height: 'Altezza',
      size: 'Dimensioni',
      ratio: 'Rapporto'
    },
    controller: {
      edit: 'Modifica',
      unlink: 'Elimina link',
      remove: 'Rimuovi',
      insertRowAbove: 'Inserisci riga sopra',
      insertRowBelow: 'Inserisci riga sotto',
      deleteRow: 'Cancella riga',
      insertColumnBefore: 'Inserisci colonna prima',
      insertColumnAfter: 'Inserisci colonna dopo',
      deleteColumn: 'Cancella colonna',
      fixedColumnWidth: 'Larghezza delle colonne fissa',
      resize100: 'Ridimensiona 100%',
      resize75: 'Ridimensiona 75%',
      resize50: 'Ridimensiona 50%',
      resize25: 'Ridimensiona 25%',
      autoSize: 'Ridimensione automatica',
      mirrorHorizontal: 'Capovolgi orizzontalmente',
      mirrorVertical: 'Capovolgi verticalmente',
      rotateLeft: 'Ruota a sinistra',
      rotateRight: 'Ruota a destra',
      maxSize: 'Dimensione massima',
      minSize: 'Dimensione minima',
      tableHeader: 'Intestazione tabella',
      mergeCells: 'Unisci celle',
      splitCells: 'Dividi celle',
      HorizontalSplit: 'Separa orizontalmente',
      VerticalSplit: 'Separa verticalmente'
    },
    menu: {
      spaced: 'Spaziato',
      bordered: 'Bordato',
      neon: 'Luminoso',
      translucent: 'Traslucido',
      shadow: 'Ombra',
      code: 'Codice'
    }
  };
  if (typeof noGlobal === typeof undefined) {
    if (!window.SUNEDITOR_LANG) {
      Object.defineProperty(window, 'SUNEDITOR_LANG', {
        enumerable: true,
        writable: false,
        configurable: false,
        value: {}
      });
    }
    Object.defineProperty(window.SUNEDITOR_LANG, 'it', {
      enumerable: true,
      writable: true,
      configurable: true,
      value: lang
    });
  }
  return lang;
});

/***/ }),

/***/ 1016:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2019 JiHong Lee.
 * MIT license.
 */


(function (global, factory) {
  if ( true && typeof module.exports === 'object') {
    module.exports = global.document ? factory(global, true) : function (w) {
      if (!w.document) {
        throw new Error('SUNEDITOR_LANG a window with a document');
      }
      return factory(w);
    };
  } else {
    factory(global);
  }
})(typeof window !== 'undefined' ? window : this, function (window, noGlobal) {
  var lang = {
    code: 'ja',
    toolbar: {
      default: 'デフォルト',
      save: '保存',
      font: 'フォント',
      formats: '段落形式',
      fontSize: 'サイズ',
      bold: '太字',
      underline: '下線',
      italic: 'イタリック',
      strike: '取り消し線',
      subscript: '下付き',
      superscript: '上付き',
      removeFormat: '形式を削除',
      fontColor: '文字色',
      hiliteColor: '文字の背景色',
      indent: 'インデント',
      outdent: 'インデント',
      align: 'ソート',
      alignLeft: '左揃え',
      alignRight: '右揃え',
      alignCenter: '中央揃え',
      alignJustify: '両端揃え',
      list: 'リスト',
      orderList: '数値ブリット',
      unorderList: '円形ブリット',
      horizontalRule: '水平線を挿入',
      hr_solid: '実線',
      hr_dotted: '点線',
      hr_dashed: 'ダッシュ',
      table: 'テーブル',
      link: 'リンク',
      math: '数学',
      image: '画像',
      video: '動画',
      audio: 'オーディオ',
      fullScreen: 'フルスクリーン',
      showBlocks: 'ブロック表示',
      codeView: 'HTMLの編集',
      undo: '元に戻す',
      redo: '再実行',
      preview: 'プレビュー',
      print: '印刷',
      tag_p: '本文',
      tag_div: '基本（DIV）',
      tag_h: 'タイトル',
      tag_blockquote: '引用',
      tag_pre: 'コード',
      template: 'テンプレート',
      lineHeight: '行の高さ',
      paragraphStyle: '段落スタイル',
      textStyle: 'テキストスタイル',
      imageGallery: 'イメージギャラリー',
      dir_ltr: '左から右へ',
      dir_rtl: '右から左に',
      mention: '言及する'
    },
    dialogBox: {
      linkBox: {
        title: 'リンクの挿入',
        url: 'インターネットアドレス',
        text: '画面のテキスト',
        newWindowCheck: '別ウィンドウで開く',
        downloadLinkCheck: 'ダウンロードリンク',
        bookmark: 'ブックマーク'
      },
      mathBox: {
        title: '数学',
        inputLabel: '数学表記',
        fontSizeLabel: 'サイズ',
        previewLabel: 'プレビュー'
      },
      imageBox: {
        title: '画像の挿入',
        file: 'ファイルの選択',
        url: 'イメージアドレス',
        altText: '置換文字列'
      },
      videoBox: {
        title: '動画を挿入',
        file: 'ファイルの選択',
        url: 'メディア埋め込みアドレス, YouTube/Vimeo'
      },
      audioBox: {
        title: 'オーディオを挿入',
        file: 'ファイルの選択',
        url: 'オーディオアドレス'
      },
      browser: {
        tags: 'タグ',
        search: '探す'
      },
      caption: '説明付け',
      close: '閉じる',
      submitButton: '確認',
      revertButton: '元に戻す',
      proportion: 'の割合カスタマイズ',
      basic: '基本',
      left: '左',
      right: '右',
      center: '中央',
      width: '横',
      height: '縦',
      size: 'サイズ',
      ratio: '比率'
    },
    controller: {
      edit: '編集',
      unlink: 'リンク解除',
      remove: '削除',
      insertRowAbove: '上に行を挿入',
      insertRowBelow: '下に行を挿入',
      deleteRow: '行の削除',
      insertColumnBefore: '左に列を挿入',
      insertColumnAfter: '右に列を挿入',
      deleteColumn: '列を削除する',
      fixedColumnWidth: '固定列幅',
      resize100: '100％ サイズ',
      resize75: '75％ サイズ',
      resize50: '50％ サイズ',
      resize25: '25％ サイズ',
      autoSize: '自動サイズ',
      mirrorHorizontal: '左右反転',
      mirrorVertical: '上下反転',
      rotateLeft: '左に回転',
      rotateRight: '右に回転',
      maxSize: '最大サイズ',
      minSize: '最小サイズ',
      tableHeader: '表のヘッダー',
      mergeCells: 'セルの結合',
      splitCells: 'セルを分割',
      HorizontalSplit: '横分割',
      VerticalSplit: '垂直分割'
    },
    menu: {
      spaced: '文字間隔',
      bordered: '境界線',
      neon: 'ネオン',
      translucent: '半透明',
      shadow: '影',
      code: 'コード'
    }
  };
  if (typeof noGlobal === typeof undefined) {
    if (!window.SUNEDITOR_LANG) {
      Object.defineProperty(window, 'SUNEDITOR_LANG', {
        enumerable: true,
        writable: false,
        configurable: false,
        value: {}
      });
    }
    Object.defineProperty(window.SUNEDITOR_LANG, 'ja', {
      enumerable: true,
      writable: true,
      configurable: true,
      value: lang
    });
  }
  return lang;
});

/***/ }),

/***/ 1017:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2017 JiHong Lee.
 * MIT license.
 */


(function (global, factory) {
  if ( true && typeof module.exports === 'object') {
    module.exports = global.document ? factory(global, true) : function (w) {
      if (!w.document) {
        throw new Error('SUNEDITOR_LANG a window with a document');
      }
      return factory(w);
    };
  } else {
    factory(global);
  }
})(typeof window !== 'undefined' ? window : this, function (window, noGlobal) {
  var lang = {
    code: 'ko',
    toolbar: {
      default: '기본값',
      save: '저장',
      font: '글꼴',
      formats: '문단 형식',
      fontSize: '크기',
      bold: '굵게',
      underline: '밑줄',
      italic: '기울임',
      strike: '취소선',
      subscript: '아래 첨자',
      superscript: '위 첨자',
      removeFormat: '형식 제거',
      fontColor: '글자색',
      hiliteColor: '배경색',
      indent: '들여쓰기',
      outdent: '내어쓰기',
      align: '정렬',
      alignLeft: '왼쪽 정렬',
      alignRight: '오른쪽 정렬',
      alignCenter: '가운데 정렬',
      alignJustify: '양쪽 정렬',
      list: '리스트',
      orderList: '숫자형 리스트',
      unorderList: '원형 리스트',
      horizontalRule: '가로 줄 삽입',
      hr_solid: '실선',
      hr_dotted: '점선',
      hr_dashed: '대시',
      table: '테이블',
      link: '링크',
      math: '수식',
      image: '이미지',
      video: '동영상',
      audio: '오디오',
      fullScreen: '전체 화면',
      showBlocks: '블록 보기',
      codeView: 'HTML 편집',
      undo: '실행 취소',
      redo: '다시 실행',
      preview: '미리보기',
      print: '인쇄',
      tag_p: '본문',
      tag_div: '기본 (DIV)',
      tag_h: '제목',
      tag_blockquote: '인용문',
      tag_pre: '코드',
      template: '템플릿',
      lineHeight: '줄 높이',
      paragraphStyle: '문단 스타일',
      textStyle: '글자 스타일',
      imageGallery: '이미지 갤러리',
      dir_ltr: '왼쪽에서 오른쪽',
      dir_rtl: '오른쪽에서 왼쪽',
      mention: '멘션'
    },
    dialogBox: {
      linkBox: {
        title: '링크 삽입',
        url: '인터넷 주소',
        text: '화면 텍스트',
        newWindowCheck: '새창으로 열기',
        downloadLinkCheck: '다운로드 링크',
        bookmark: '북마크'
      },
      mathBox: {
        title: '수식',
        inputLabel: '수학적 표기법',
        fontSizeLabel: '글자 크기',
        previewLabel: '미리보기'
      },
      imageBox: {
        title: '이미지 삽입',
        file: '파일 선택',
        url: '이미지 주소',
        altText: '대체 문자열'
      },
      videoBox: {
        title: '동영상 삽입',
        file: '파일 선택',
        url: '미디어 임베드 주소, 유튜브/비메오'
      },
      audioBox: {
        title: '오디오 삽입',
        file: '파일 선택',
        url: '오디오 파일 주소'
      },
      browser: {
        tags: '태그',
        search: '검색'
      },
      caption: '설명 넣기',
      close: '닫기',
      submitButton: '확인',
      revertButton: '되돌리기',
      proportion: '비율 맞춤',
      basic: '기본',
      left: '왼쪽',
      right: '오른쪽',
      center: '가운데',
      width: '가로',
      height: '세로',
      size: '크기',
      ratio: '비율'
    },
    controller: {
      edit: '편집',
      unlink: '링크 해제',
      remove: '삭제',
      insertRowAbove: '위에 행 삽입',
      insertRowBelow: '아래에 행 삽입',
      deleteRow: '행 삭제',
      insertColumnBefore: '왼쪽에 열 삽입',
      insertColumnAfter: '오른쪽에 열 삽입',
      deleteColumn: '열 삭제',
      fixedColumnWidth: '고정 된 열 너비',
      resize100: '100% 크기',
      resize75: '75% 크기',
      resize50: '50% 크기',
      resize25: '25% 크기',
      autoSize: '자동 크기',
      mirrorHorizontal: '좌우 반전',
      mirrorVertical: '상하 반전',
      rotateLeft: '왼쪽으로 회전',
      rotateRight: '오른쪽으로 회전',
      maxSize: '최대화',
      minSize: '최소화',
      tableHeader: '테이블 제목',
      mergeCells: '셀 병합',
      splitCells: '셀 분할',
      HorizontalSplit: '가로 분할',
      VerticalSplit: '세로 분할'
    },
    menu: {
      spaced: '글자 간격',
      bordered: '경계선',
      neon: '네온',
      translucent: '반투명',
      shadow: '그림자',
      code: '코드'
    }
  };
  if (typeof noGlobal === typeof undefined) {
    if (!window.SUNEDITOR_LANG) {
      Object.defineProperty(window, 'SUNEDITOR_LANG', {
        enumerable: true,
        writable: false,
        configurable: false,
        value: {}
      });
    }
    Object.defineProperty(window.SUNEDITOR_LANG, 'ko', {
      enumerable: true,
      writable: true,
      configurable: true,
      value: lang
    });
  }
  return lang;
});

/***/ }),

/***/ 1018:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2017 JiHong Lee.
 * MIT license.
 */


(function (global, factory) {
  if ( true && typeof module.exports === 'object') {
    module.exports = global.document ? factory(global, true) : function (w) {
      if (!w.document) {
        throw new Error('SUNEDITOR_LANG a window with a document');
      }
      return factory(w);
    };
  } else {
    factory(global);
  }
})(typeof window !== 'undefined' ? window : this, function (window, noGlobal) {
  var lang = {
    code: 'lv',
    toolbar: {
      default: 'Noklusējuma',
      save: 'Saglabāt',
      font: 'Fonts',
      formats: 'Formāti',
      fontSize: 'Fonta lielums',
      bold: 'Treknraksts',
      underline: 'Pasvītrot',
      italic: 'Slīpraksts',
      strike: 'Pārsvītrojums',
      subscript: 'Apakšraksts',
      superscript: 'Augšraksts',
      removeFormat: 'Noņemt formātu',
      fontColor: 'Fonta krāsa',
      hiliteColor: 'Teksta iezīmēšanas krāsa',
      indent: 'Palielināt atkāpi',
      outdent: 'Samazināt atkāpi',
      align: 'Izlīdzināt',
      alignLeft: 'Līdzināt pa kreisi',
      alignRight: 'Līdzināt pa labi',
      alignCenter: 'Centrēt',
      alignJustify: 'Taisnot',
      list: 'Saraksts',
      orderList: 'Numerācija',
      unorderList: 'Aizzimes',
      horizontalRule: 'Horizontāla līnija',
      hr_solid: 'Ciets',
      hr_dotted: 'Punktiņš',
      hr_dashed: 'Braša',
      table: 'Tabula',
      link: 'Saite',
      math: 'Matemātika',
      image: 'Attēls',
      video: 'Video',
      audio: 'Audio',
      fullScreen: 'Pilnekrāna režīms',
      showBlocks: 'Parādit blokus',
      codeView: 'Koda skats',
      undo: 'Atsaukt',
      redo: 'Atkārtot',
      preview: 'Priekšskatījums',
      print: 'Drukāt',
      tag_p: 'Paragrāfs',
      tag_div: 'Normāli (DIV)',
      tag_h: 'Galvene',
      tag_blockquote: 'Citāts',
      tag_pre: 'Kods',
      template: 'Veidne',
      lineHeight: 'Līnijas augstums',
      paragraphStyle: 'Paragrāfa stils',
      textStyle: 'Teksta stils',
      imageGallery: 'Attēlu galerija',
      dir_ltr: 'No kreisās uz labo',
      dir_rtl: 'No labās uz kreiso',
      mention: 'Pieminēt'
    },
    dialogBox: {
      linkBox: {
        title: 'Ievietot saiti',
        url: 'Saites URL',
        text: 'Parādāmais teksts',
        newWindowCheck: 'Atvērt jaunā logā',
        downloadLinkCheck: 'Lejupielādes saite',
        bookmark: 'Grāmatzīme'
      },
      mathBox: {
        title: 'Matemātika',
        inputLabel: 'Matemātiskā notācija',
        fontSizeLabel: 'Fonta lielums',
        previewLabel: 'Priekšskatījums'
      },
      imageBox: {
        title: 'Ievietot attēlu',
        file: 'Izvēlieties no failiem',
        url: 'Attēla URL',
        altText: 'Alternatīvs teksts'
      },
      videoBox: {
        title: 'Ievietot video',
        file: 'Izvēlieties no failiem',
        url: 'Multivides iegulšanas URL, YouTube/Vimeo'
      },
      audioBox: {
        title: 'Ievietot audio',
        file: 'Izvēlieties no failiem',
        url: 'Audio URL'
      },
      browser: {
        tags: 'Tagi',
        search: 'Meklēt'
      },
      caption: 'Ievietot aprakstu',
      close: 'Aizvērt',
      submitButton: 'Iesniegt',
      revertButton: 'Atjaunot',
      proportion: 'Ierobežo proporcijas',
      basic: 'Nav iesaiņojuma',
      left: 'Pa kreisi',
      right: 'Labajā pusē',
      center: 'Centrs',
      width: 'Platums',
      height: 'Augstums',
      size: 'Izmērs',
      ratio: 'Attiecība'
    },
    controller: {
      edit: 'Rediģēt',
      unlink: 'Atsaistīt',
      remove: 'Noņemt',
      insertRowAbove: 'Ievietot rindu virs',
      insertRowBelow: 'Ievietot rindu zemāk',
      deleteRow: 'Dzēst rindu',
      insertColumnBefore: 'Ievietot kolonnu pirms',
      insertColumnAfter: 'Ievietot kolonnu aiz',
      deleteColumn: 'Dzēst kolonnu',
      fixColumnWidth: 'Fiksēts kolonnas platums',
      resize100: 'Mainīt izmēru 100%',
      resize75: 'Mainīt izmēru 75%',
      resize50: 'Mainīt izmēru 50%',
      resize25: 'Mainīt izmēru 25%',
      autoSize: 'Automātiskais izmērs',
      mirrorHorizontal: 'Spogulis, horizontāls',
      mirrorVertical: 'Spogulis, vertikāls',
      rotateLeft: 'Pagriezt pa kreisi',
      rotateRight: 'Pagriezt pa labi',
      maxSize: 'Maksimālais izmērs',
      minSize: 'Minimālais izmērs',
      tableHeader: 'Tabulas galvene',
      mergeCells: 'Apvienot šūnas',
      splitCells: 'Sadalīt šūnas',
      HorizontalSplit: 'Horizontāls sadalījums',
      VerticalSplit: 'Vertikāls sadalījums'
    },
    menu: {
      spaced: 'Ar atstarpi',
      bordered: 'Robežojās',
      neon: 'Neona',
      translucent: 'Caurspīdīgs',
      shadow: 'Ēna',
      code: 'Kods'
    }
  };
  if (typeof noGlobal === typeof undefined) {
    if (!window.SUNEDITOR_LANG) {
      Object.defineProperty(window, 'SUNEDITOR_LANG', {
        enumerable: true,
        writable: false,
        configurable: false,
        value: {}
      });
    }
    Object.defineProperty(window.SUNEDITOR_LANG, 'lv', {
      enumerable: true,
      writable: true,
      configurable: true,
      value: lang
    });
  }
  return lang;
});

/***/ }),

/***/ 1019:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2017 JiHong Lee.
 * MIT license.
 */


(function (global, factory) {
  if ( true && typeof module.exports === 'object') {
    module.exports = global.document ? factory(global, true) : function (w) {
      if (!w.document) {
        throw new Error('SUNEDITOR_LANG a window with a document');
      }
      return factory(w);
    };
  } else {
    factory(global);
  }
})(typeof window !== 'undefined' ? window : this, function (window, noGlobal) {
  var lang = {
    code: 'nl',
    toolbar: {
      default: 'Standaard',
      save: 'Opslaan',
      font: 'Lettertype',
      formats: 'Formaten',
      fontSize: 'Lettergrootte',
      bold: 'Vetgedrukt',
      underline: 'Onderstrepen',
      italic: 'Cursief',
      strike: 'Doorstrepen',
      subscript: 'Subscript',
      superscript: 'Superscript',
      removeFormat: 'Opmaak verwijderen',
      fontColor: 'Tekstkleur',
      hiliteColor: 'Tekst markeren',
      indent: 'Inspringen',
      outdent: 'Inspringen ongedaan maken',
      align: 'Uitlijnen',
      alignLeft: 'Links uitlijnen',
      alignRight: 'Rechts uitlijnen',
      alignCenter: 'In het midden uitlijnen',
      alignJustify: 'Uitvullen',
      list: 'Lijst',
      orderList: 'Geordende lijst',
      unorderList: 'Ongeordende lijst',
      horizontalRule: 'Horizontale regel',
      hr_solid: 'Standaard',
      hr_dotted: 'Gestippeld',
      hr_dashed: 'Gestreept',
      table: 'Tabel',
      link: 'Link',
      math: 'Wiskunde',
      image: 'Afbeelding',
      video: 'Video',
      audio: 'Audio',
      fullScreen: 'Volledig scherm',
      showBlocks: 'Blokken tonen',
      codeView: 'Broncode weergeven',
      undo: 'Ongedaan maken',
      redo: 'Ongedaan maken herstellen',
      preview: 'Voorbeeldweergave',
      print: 'Printen',
      tag_p: 'Alinea',
      tag_div: 'Normaal (div)',
      tag_h: 'Kop',
      tag_blockquote: 'Citaat',
      tag_pre: 'Code',
      template: 'Sjabloon',
      lineHeight: 'Lijnhoogte',
      paragraphStyle: 'Alineastijl',
      textStyle: 'Tekststijl',
      imageGallery: 'Galerij',
      dir_ltr: 'Van links naar rechts',
      dir_rtl: 'Rechts naar links',
      mention: 'Vermelding'
    },
    dialogBox: {
      linkBox: {
        title: 'Link invoegen',
        url: 'URL',
        text: 'Tekst van de link',
        newWindowCheck: 'In een nieuw tabblad openen',
        downloadLinkCheck: 'Downloadlink',
        bookmark: 'Bladwijzer'
      },
      mathBox: {
        title: 'Wiskunde',
        inputLabel: 'Wiskundige notatie',
        fontSizeLabel: 'Lettergrootte',
        previewLabel: 'Voorbeeld'
      },
      imageBox: {
        title: 'Afbeelding invoegen',
        file: 'Selecteer een bestand van uw apparaat',
        url: 'URL',
        altText: 'Alt-tekst'
      },
      videoBox: {
        title: 'Video invoegen',
        file: 'Selecteer een bestand van uw apparaat',
        url: 'Embedded URL (YouTube/Vimeo)'
      },
      audioBox: {
        title: 'Audio invoegen',
        file: 'Selecteer een bestand van uw apparaat',
        url: 'URL'
      },
      browser: {
        tags: 'Tags',
        search: 'Zoeken'
      },
      caption: 'Omschrijving toevoegen',
      close: 'Sluiten',
      submitButton: 'Toepassen',
      revertButton: 'Standaardwaarden herstellen',
      proportion: 'Verhouding behouden',
      basic: 'Standaard',
      left: 'Links',
      right: 'Rechts',
      center: 'Midden',
      width: 'Breedte',
      height: 'Hoogte',
      size: 'Grootte',
      ratio: 'Verhouding'
    },
    controller: {
      edit: 'Bewerken',
      unlink: 'Ontkoppelen',
      remove: 'Verwijderen',
      insertRowAbove: 'Rij hierboven invoegen',
      insertRowBelow: 'Rij hieronder invoegen',
      deleteRow: 'Rij verwijderen',
      insertColumnBefore: 'Kolom links invoegen',
      insertColumnAfter: 'Kolom rechts invoegen',
      deleteColumn: 'Kolom verwijderen',
      fixedColumnWidth: 'Vaste kolombreedte',
      resize100: 'Formaat wijzigen: 100%',
      resize75: 'Formaat wijzigen: 75%',
      resize50: 'Formaat wijzigen: 50%',
      resize25: 'Formaat wijzigen: 25%',
      autoSize: 'Automatische grootte',
      mirrorHorizontal: 'Horizontaal spiegelen',
      mirrorVertical: 'Verticaal spiegelen',
      rotateLeft: 'Naar links draaien',
      rotateRight: 'Naar rechts draaien',
      maxSize: 'Maximale grootte',
      minSize: 'Minimale grootte',
      tableHeader: 'Tabelkoppen',
      mergeCells: 'Cellen samenvoegen',
      splitCells: 'Cellen splitsen',
      HorizontalSplit: 'Horizontaal splitsen',
      VerticalSplit: 'Verticaal splitsen'
    },
    menu: {
      spaced: 'Uit elkaar',
      bordered: 'Omlijnd',
      neon: 'Neon',
      translucent: 'Doorschijnend',
      shadow: 'Schaduw',
      code: 'Code'
    }
  };
  if (typeof noGlobal === typeof undefined) {
    if (!window.SUNEDITOR_LANG) {
      Object.defineProperty(window, 'SUNEDITOR_LANG', {
        enumerable: true,
        writable: false,
        configurable: false,
        value: {}
      });
    }
    Object.defineProperty(window.SUNEDITOR_LANG, 'nl', {
      enumerable: true,
      writable: true,
      configurable: true,
      value: lang
    });
  }
  return lang;
});

/***/ }),

/***/ 1020:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2017 JiHong Lee.
 * MIT license.
 */


(function (global, factory) {
  if ( true && typeof module.exports === 'object') {
    module.exports = global.document ? factory(global, true) : function (w) {
      if (!w.document) {
        throw new Error('SUNEDITOR_LANG a window with a document');
      }
      return factory(w);
    };
  } else {
    factory(global);
  }
})(typeof window !== 'undefined' ? window : this, function (window, noGlobal) {
  var lang = {
    code: 'pl',
    toolbar: {
      default: 'Domyślne',
      save: 'Zapisz',
      font: 'Czcionka',
      formats: 'Formaty',
      fontSize: 'Rozmiar',
      bold: 'Pogrubienie',
      underline: 'Podkreślenie',
      italic: 'Kursywa',
      strike: 'Przekreślenie',
      subscript: 'Indeks dolny',
      superscript: 'Indeks górny',
      removeFormat: 'Wyczyść formatowanie',
      fontColor: 'Kolor tekstu',
      hiliteColor: 'Kolor tła tekstu',
      indent: 'Zwiększ wcięcie',
      outdent: 'Zmniejsz wcięcie',
      align: 'Wyrównaj',
      alignLeft: 'Do lewej',
      alignRight: 'Do prawej',
      alignCenter: 'Do środka',
      alignJustify: 'Wyjustuj',
      list: 'Lista',
      orderList: 'Lista numerowana',
      unorderList: 'Lista wypunktowana',
      horizontalRule: 'Pozioma linia',
      hr_solid: 'Ciągła',
      hr_dotted: 'Kropkowana',
      hr_dashed: 'Przerywana',
      table: 'Tabela',
      link: 'Odnośnik',
      math: 'Matematyczne',
      image: 'Obraz',
      video: 'Wideo',
      audio: 'Audio',
      fullScreen: 'Pełny ekran',
      showBlocks: 'Pokaż bloki',
      codeView: 'Widok kodu',
      undo: 'Cofnij',
      redo: 'Ponów',
      preview: 'Podgląd',
      print: 'Drukuj',
      tag_p: 'Akapit',
      tag_div: 'Blok (DIV)',
      tag_h: 'Nagłówek H',
      tag_blockquote: 'Cytat',
      tag_pre: 'Kod',
      template: 'Szablon',
      lineHeight: 'Odstęp między wierszami',
      paragraphStyle: 'Styl akapitu',
      textStyle: 'Styl tekstu',
      imageGallery: 'Galeria obrazów',
      dir_ltr: 'Od lewej do prawej',
      dir_rtl: 'Od prawej do lewej',
      mention: 'Wzmianka'
    },
    dialogBox: {
      linkBox: {
        title: 'Wstaw odnośnik',
        url: 'Adres URL',
        text: 'Tekst do wyświetlenia',
        newWindowCheck: 'Otwórz w nowym oknie',
        downloadLinkCheck: 'Link do pobrania',
        bookmark: 'Zakładka'
      },
      mathBox: {
        title: 'Matematyczne',
        inputLabel: 'Zapis matematyczny',
        fontSizeLabel: 'Rozmiar czcionki',
        previewLabel: 'Podgląd'
      },
      imageBox: {
        title: 'Wstaw obraz',
        file: 'Wybierz plik',
        url: 'Adres URL obrazka',
        altText: 'Tekst alternatywny'
      },
      videoBox: {
        title: 'Wstaw wideo',
        file: 'Wybierz plik',
        url: 'Adres URL video, np. YouTube/Vimeo'
      },
      audioBox: {
        title: 'Wstaw audio',
        file: 'Wybierz plik',
        url: 'Adres URL audio'
      },
      browser: {
        tags: 'Tagi',
        search: 'Szukaj'
      },
      caption: 'Wstaw opis',
      close: 'Zamknij',
      submitButton: 'Zatwierdź',
      revertButton: 'Cofnij zmiany',
      proportion: 'Ogranicz proporcje',
      basic: 'Bez wyrównania',
      left: 'Do lewej',
      right: 'Do prawej',
      center: 'Do środka',
      width: 'Szerokość',
      height: 'Wysokość',
      size: 'Rozmiar',
      ratio: 'Proporcje'
    },
    controller: {
      edit: 'Edycja',
      unlink: 'Usuń odnośnik',
      remove: 'Usuń',
      insertRowAbove: 'Wstaw wiersz powyżej',
      insertRowBelow: 'Wstaw wiersz poniżej',
      deleteRow: 'Usuń wiersz',
      insertColumnBefore: 'Wstaw kolumnę z lewej',
      insertColumnAfter: 'Wstaw kolumnę z prawej',
      deleteColumn: 'Usuń kolumnę',
      fixedColumnWidth: 'Stała szerokość kolumny',
      resize100: 'Zmień rozmiar - 100%',
      resize75: 'Zmień rozmiar - 75%',
      resize50: 'Zmień rozmiar - 50%',
      resize25: 'Zmień rozmiar - 25%',
      autoSize: 'Rozmiar automatyczny',
      mirrorHorizontal: 'Odbicie lustrzane w poziomie',
      mirrorVertical: 'Odbicie lustrzane w pionie',
      rotateLeft: 'Obróć w lewo',
      rotateRight: 'Obróć w prawo',
      maxSize: 'Maksymalny rozmiar',
      minSize: 'Minimalny rozmiar',
      tableHeader: 'Nagłówek tabeli',
      mergeCells: 'Scal komórki',
      splitCells: 'Podziel komórki',
      HorizontalSplit: 'Podział poziomy',
      VerticalSplit: 'Podział pionowy'
    },
    menu: {
      spaced: 'Rozstawiony',
      bordered: 'Z obwódką',
      neon: 'Neon',
      translucent: 'Półprzezroczysty',
      shadow: 'Cień',
      code: 'Kod'
    }
  };
  if (typeof noGlobal === typeof undefined) {
    if (!window.SUNEDITOR_LANG) {
      Object.defineProperty(window, 'SUNEDITOR_LANG', {
        enumerable: true,
        writable: false,
        configurable: false,
        value: {}
      });
    }
    Object.defineProperty(window.SUNEDITOR_LANG, 'pl', {
      enumerable: true,
      writable: true,
      configurable: true,
      value: lang
    });
  }
  return lang;
});

/***/ }),

/***/ 1021:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2017 JiHong Lee.
 * Brazilian Portuguese translation by lpeil github
 * MIT license.
 */


(function (global, factory) {
  if ( true && typeof module.exports === 'object') {
    module.exports = global.document ? factory(global, true) : function (w) {
      if (!w.document) {
        throw new Error('SUNEDITOR_LANG a window with a document');
      }
      return factory(w);
    };
  } else {
    factory(global);
  }
})(typeof window !== 'undefined' ? window : this, function (window, noGlobal) {
  var lang = {
    code: 'pt_br',
    toolbar: {
      default: 'Padrão',
      save: 'Salvar',
      font: 'Fonte',
      formats: 'Formatos',
      fontSize: 'Tamanho',
      bold: 'Negrito',
      underline: 'Sublinhado',
      italic: 'Itálico',
      strike: 'Riscado',
      subscript: 'Subescrito',
      superscript: 'Sobrescrito',
      removeFormat: 'Remover Formatação',
      fontColor: 'Cor da Fonte',
      hiliteColor: 'Cor de destaque',
      indent: 'Recuo',
      outdent: 'Avançar',
      align: 'Alinhar',
      alignLeft: 'Alinhar à esquerda',
      alignRight: 'Alinhar à direita',
      alignCenter: 'Alinhar ao centro',
      alignJustify: 'Alinhat justificado',
      list: 'Lista',
      orderList: 'Lista ordenada',
      unorderList: 'Lista desordenada',
      horizontalRule: 'Linha horizontal',
      hr_solid: 'solida',
      hr_dotted: 'pontilhada',
      hr_dashed: 'tracejada',
      table: 'Tabela',
      link: 'Link',
      math: 'Matemática',
      image: 'Imagem',
      video: 'Vídeo',
      audio: 'Áudio',
      fullScreen: 'Tela cheia',
      showBlocks: 'Mostrar blocos',
      codeView: 'Mostrar códigos',
      undo: 'Voltar',
      redo: 'Refazer',
      preview: 'Prever',
      print: 'imprimir',
      tag_p: 'Paragráfo',
      tag_div: '(DIV) Normal',
      tag_h: 'Cabeçalho',
      tag_blockquote: 'Citar',
      tag_pre: 'Código',
      template: 'Modelo',
      lineHeight: 'Altura da linha',
      paragraphStyle: 'Estilo do parágrafo',
      textStyle: 'Estilo do texto',
      imageGallery: 'Galeria de imagens',
      dir_ltr: 'Da esquerda para direita',
      dir_rtl: 'Direita para esquerda',
      mention: 'Menção'
    },
    dialogBox: {
      linkBox: {
        title: 'Inserir link',
        url: 'URL para link',
        text: 'Texto à mostrar',
        newWindowCheck: 'Abrir em nova guia',
        downloadLinkCheck: 'Link para Download',
        bookmark: 'marca páginas'
      },
      mathBox: {
        title: 'Matemática',
        inputLabel: 'Notação matemática',
        fontSizeLabel: 'Tamanho',
        previewLabel: 'Prever'
      },
      imageBox: {
        title: 'Inserir imagens',
        file: 'Selecionar arquivos',
        url: 'URL da imagem',
        altText: 'Texto alternativo'
      },
      videoBox: {
        title: 'Inserir vídeo',
        file: 'Selecionar arquivos',
        url: 'URL do YouTube/Vimeo'
      },
      audioBox: {
        title: 'Inserir audio',
        file: 'Selecionar arquivos',
        url: 'URL da audio'
      },
      browser: {
        tags: 'Tag',
        search: 'Procurar'
      },
      caption: 'Inserir descrição',
      close: 'Fechar',
      submitButton: 'Enviar',
      revertButton: 'Reverter',
      proportion: 'restringir proporções',
      basic: 'Básico',
      left: 'Esquerda',
      right: 'Direita',
      center: 'Centro',
      width: 'Largura',
      height: 'Altura',
      size: 'Tamanho',
      ratio: 'Proporções'
    },
    controller: {
      edit: 'Editar',
      unlink: 'Retirar link',
      remove: 'Remover',
      insertRowAbove: 'Inserir linha acima',
      insertRowBelow: 'Inserir linha abaixo',
      deleteRow: 'Deletar linha',
      insertColumnBefore: 'Inserir coluna antes',
      insertColumnAfter: 'Inserir coluna depois',
      deleteColumn: 'Deletar coluna',
      fixedColumnWidth: 'Largura fixa da coluna',
      resize100: 'Redimensionar para 100%',
      resize75: 'Redimensionar para 75%',
      resize50: 'Redimensionar para 50%',
      resize25: 'Redimensionar para 25%',
      autoSize: 'Tamanho automático',
      mirrorHorizontal: 'Espelho, Horizontal',
      mirrorVertical: 'Espelho, Vertical',
      rotateLeft: 'Girar para esquerda',
      rotateRight: 'Girar para direita',
      maxSize: 'Tam max',
      minSize: 'Tam min',
      tableHeader: 'Cabeçalho da tabela',
      mergeCells: 'Mesclar células',
      splitCells: 'Dividir células',
      HorizontalSplit: 'Divisão horizontal',
      VerticalSplit: 'Divisão vertical'
    },
    menu: {
      spaced: 'Espaçado',
      bordered: 'Com borda',
      neon: 'Néon',
      translucent: 'Translúcido',
      shadow: 'Sombreado',
      code: 'Código'
    }
  };
  if (typeof noGlobal === typeof undefined) {
    if (!window.SUNEDITOR_LANG) {
      Object.defineProperty(window, 'SUNEDITOR_LANG', {
        enumerable: true,
        writable: false,
        configurable: false,
        value: {}
      });
    }
    Object.defineProperty(window.SUNEDITOR_LANG, 'pt_br', {
      enumerable: true,
      writable: true,
      configurable: true,
      value: lang
    });
  }
  return lang;
});

/***/ }),

/***/ 1022:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2017 JiHong Lee.
 * MIT license.
 */


(function (global, factory) {
  if ( true && typeof module.exports === 'object') {
    module.exports = global.document ? factory(global, true) : function (w) {
      if (!w.document) {
        throw new Error('SUNEDITOR_LANG a window with a document');
      }
      return factory(w);
    };
  } else {
    factory(global);
  }
})(typeof window !== 'undefined' ? window : this, function (window, noGlobal) {
  var lang = {
    code: 'ro',
    toolbar: {
      default: 'Default',
      save: 'Salvează',
      font: 'Font',
      formats: 'Format',
      fontSize: 'Dimensiune',
      bold: 'Îngroșat',
      underline: 'Subliniat',
      italic: 'Înclinat',
      strike: 'Tăiat',
      subscript: 'Subscript',
      superscript: 'Superscript',
      removeFormat: 'Șterge formatare',
      fontColor: 'Culoare font',
      hiliteColor: 'Culoare de evidențiere',
      indent: 'Indentează',
      outdent: 'Fără indentare',
      align: 'Aliniere',
      alignLeft: 'Aliniere la stânga',
      alignRight: 'Aliniere la dreapta',
      alignCenter: 'Aliniere la centru',
      alignJustify: 'Aliniere stânga - dreapta',
      list: 'Listă',
      orderList: 'Listă ordonată',
      unorderList: 'Listă neordonată',
      horizontalRule: 'Linie orizontală',
      hr_solid: 'Solid',
      hr_dotted: 'Punctat',
      hr_dashed: 'Punctate',
      table: 'Tabel',
      link: 'Link',
      math: 'Matematică',
      image: 'Imagine',
      video: 'Video',
      audio: 'Audio',
      fullScreen: 'Tot ecranul',
      showBlocks: 'Arată blocuri',
      codeView: 'Vizualizare cod',
      undo: 'Anulează',
      redo: 'Refă',
      preview: 'Previzualizare',
      print: 'printează',
      tag_p: 'Paragraf',
      tag_div: 'Normal (DIV)',
      tag_h: 'Antet',
      tag_blockquote: 'Quote',
      tag_pre: 'Citat',
      template: 'Template',
      lineHeight: 'Înălțime linie',
      paragraphStyle: 'Stil paragraf',
      textStyle: 'Stil text',
      imageGallery: 'Galerie de imagini',
      dir_ltr: 'De la stânga la dreapta',
      dir_rtl: 'De la dreapta la stanga',
      mention: 'Mentiune'
    },
    dialogBox: {
      linkBox: {
        title: 'Inserează Link',
        url: 'Adresă link',
        text: 'Text de afișat',
        newWindowCheck: 'Deschide în fereastră nouă',
        downloadLinkCheck: 'Link de descărcare',
        bookmark: 'Marcaj'
      },
      mathBox: {
        title: 'Matematică',
        inputLabel: 'Notație matematică',
        fontSizeLabel: 'Dimensiune font',
        previewLabel: 'Previzualizare'
      },
      imageBox: {
        title: 'Inserează imagine',
        file: 'Selectează',
        url: 'URL imagine',
        altText: 'text alternativ'
      },
      videoBox: {
        title: 'Inserează video',
        file: 'Selectează',
        url: 'Include URL, youtube/vimeo'
      },
      audioBox: {
        title: 'Inserează Audio',
        file: 'Selectează',
        url: 'URL Audio'
      },
      browser: {
        tags: 'Etichete',
        search: 'Căutareim'
      },
      caption: 'Inserează descriere',
      close: 'Închide',
      submitButton: 'Salvează',
      revertButton: 'Revenire',
      proportion: 'Constrânge proporțiile',
      basic: 'De bază',
      left: 'Stânga',
      right: 'Dreapta',
      center: 'Centru',
      width: 'Lățime',
      height: 'Înălțime',
      size: 'Dimensiune',
      ratio: 'Ratie'
    },
    controller: {
      edit: 'Editează',
      unlink: 'Scoate link',
      remove: 'Elimină',
      insertRowAbove: 'Inserează rând deasupra',
      insertRowBelow: 'Inserează rând dedesupt',
      deleteRow: 'Șterge linie',
      insertColumnBefore: 'Inserează coloană înainte',
      insertColumnAfter: 'Inserează coloană după',
      deleteColumn: 'Șterge coloană',
      fixedColumnWidth: 'Lățime fixă coloană',
      resize100: 'Redimensionare 100%',
      resize75: 'Redimensionare 75%',
      resize50: 'Redimensionare 50%',
      resize25: 'Redimensionare 25%',
      autoSize: 'Dimensiune automată',
      mirrorHorizontal: 'Oglindă, orizontal',
      mirrorVertical: 'Oglindă, vertical',
      rotateLeft: 'Rotește la stânga',
      rotateRight: 'Rotește la dreapta',
      maxSize: 'Dimensiune maximă',
      minSize: 'Dimensiune minimă',
      tableHeader: 'Antet tabel',
      mergeCells: 'Îmbină celule',
      splitCells: 'Divizează celule',
      HorizontalSplit: 'Despicare orizontală',
      VerticalSplit: 'Despicare verticală'
    },
    menu: {
      spaced: 'Spațiat',
      bordered: 'Mărginit',
      neon: 'Neon',
      translucent: 'Translucent',
      shadow: 'Umbră',
      code: 'Citat'
    }
  };
  if (typeof noGlobal === typeof undefined) {
    if (!window.SUNEDITOR_LANG) {
      Object.defineProperty(window, 'SUNEDITOR_LANG', {
        enumerable: true,
        writable: false,
        configurable: false,
        value: {}
      });
    }
    Object.defineProperty(window.SUNEDITOR_LANG, 'ro', {
      enumerable: true,
      writable: true,
      configurable: true,
      value: lang
    });
  }
  return lang;
});

/***/ }),

/***/ 1023:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2017 JiHong Lee.
 * MIT license.
 */


(function (global, factory) {
  if ( true && typeof module.exports === 'object') {
    module.exports = global.document ? factory(global, true) : function (w) {
      if (!w.document) {
        throw new Error('SUNEDITOR_LANG a window with a document');
      }
      return factory(w);
    };
  } else {
    factory(global);
  }
})(typeof window !== 'undefined' ? window : this, function (window, noGlobal) {
  var lang = {
    code: 'ru',
    toolbar: {
      default: 'По умолчанию',
      save: 'Сохранить',
      font: 'Шрифт',
      formats: 'Стиль абзаца',
      fontSize: 'Размер шрифта',
      bold: 'Полужирный',
      underline: 'Подчёркнутый',
      italic: 'Курсив',
      strike: 'Зачеркнутый',
      subscript: 'Нижний индекс',
      superscript: 'Верхний индекс',
      removeFormat: 'Очистить форматирование',
      fontColor: 'Цвет текста',
      hiliteColor: 'Цвет фона',
      indent: 'Увеличить отступ',
      outdent: 'Уменьшить отступ',
      align: 'Выравнивание',
      alignLeft: 'Слева',
      alignRight: 'Справа',
      alignCenter: 'По центру',
      alignJustify: 'По ширине',
      list: 'Списки',
      orderList: 'Нумерованный',
      unorderList: 'Маркированный',
      horizontalRule: 'Горизонтальная линия',
      hr_solid: 'Сплошная',
      hr_dotted: 'Пунктир',
      hr_dashed: 'Штриховая',
      table: 'Таблица',
      link: 'Ссылка',
      math: 'математический',
      image: 'Изображение',
      video: 'Видео',
      audio: 'Аудио',
      fullScreen: 'Полный экран',
      showBlocks: 'Блочный вид',
      codeView: 'Редактировать HTML',
      undo: 'Отменить',
      redo: 'Вернуть',
      preview: 'Предварительный просмотр',
      print: 'Печать',
      tag_p: 'Текст',
      tag_div: 'Базовый',
      tag_h: 'Заголовок',
      tag_blockquote: 'Цитата',
      tag_pre: 'Код',
      template: 'Шаблон',
      lineHeight: 'Высота линии',
      paragraphStyle: 'Стиль абзаца',
      textStyle: 'Стиль текста',
      imageGallery: 'Галерея',
      dir_ltr: 'Слева направо',
      dir_rtl: 'Справа налево',
      mention: 'Упоминание'
    },
    dialogBox: {
      linkBox: {
        title: 'Вставить ссылку',
        url: 'Ссылка',
        text: 'Текст',
        newWindowCheck: 'Открывать в новом окне',
        downloadLinkCheck: 'Ссылка для скачивания',
        bookmark: 'Закладка'
      },
      mathBox: {
        title: 'математический',
        inputLabel: 'Математическая запись',
        fontSizeLabel: 'Кегль',
        previewLabel: 'Предварительный просмотр'
      },
      imageBox: {
        title: 'Вставить изображение',
        file: 'Выберите файл',
        url: 'Адрес изображения',
        altText: 'Текстовое описание изображения'
      },
      videoBox: {
        title: 'Вставить видео',
        file: 'Выберите файл',
        url: 'Ссылка на видео, Youtube,Vimeo'
      },
      audioBox: {
        title: 'Вставить аудио',
        file: 'Выберите файл',
        url: 'Адрес аудио'
      },
      browser: {
        tags: 'Теги',
        search: 'Поиск'
      },
      caption: 'Добавить подпись',
      close: 'Закрыть',
      submitButton: 'Подтвердить',
      revertButton: 'Сбросить',
      proportion: 'Сохранить пропорции',
      basic: 'Без обтекания',
      left: 'Слева',
      right: 'Справа',
      center: 'По центру',
      width: 'Ширина',
      height: 'Высота',
      size: 'Размер',
      ratio: 'Соотношение'
    },
    controller: {
      edit: 'Изменить',
      unlink: 'Убрать ссылку',
      remove: 'Удалить',
      insertRowAbove: 'Вставить строку выше',
      insertRowBelow: 'Вставить строку ниже',
      deleteRow: 'Удалить строку',
      insertColumnBefore: 'Вставить столбец слева',
      insertColumnAfter: 'Вставить столбец справа',
      deleteColumn: 'Удалить столбец',
      fixedColumnWidth: 'Фиксированная ширина столбца',
      resize100: 'Размер 100%',
      resize75: 'Размер 75%',
      resize50: 'Размер 50%',
      resize25: 'Размер 25%',
      autoSize: 'Авто размер',
      mirrorHorizontal: 'Отразить по горизонтали',
      mirrorVertical: 'Отразить по вертикали',
      rotateLeft: 'Повернуть против часовой стрелки',
      rotateRight: 'Повернуть по часовой стрелке',
      maxSize: 'Ширина по размеру страницы',
      minSize: 'Ширина по содержимому',
      tableHeader: 'Строка заголовков',
      mergeCells: 'Объединить ячейки',
      splitCells: 'Разделить ячейку',
      HorizontalSplit: 'Разделить горизонтально',
      VerticalSplit: 'Разделить вертикально'
    },
    menu: {
      spaced: 'интервал',
      bordered: 'Граничная Линия',
      neon: 'неон',
      translucent: 'полупрозрачный',
      shadow: 'Тень',
      code: 'Код'
    }
  };
  if (typeof noGlobal === typeof undefined) {
    if (!window.SUNEDITOR_LANG) {
      Object.defineProperty(window, 'SUNEDITOR_LANG', {
        enumerable: true,
        writable: false,
        configurable: false,
        value: {}
      });
    }
    Object.defineProperty(window.SUNEDITOR_LANG, 'ru', {
      enumerable: true,
      writable: true,
      configurable: true,
      value: lang
    });
  }
  return lang;
});

/***/ }),

/***/ 1024:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2017 JiHong Lee.
 * 
 * Swedish translation by olehrb at github or gmail
 *
 * MIT license.
 */


(function (global, factory) {
  if ( true && typeof module.exports === 'object') {
    module.exports = global.document ? factory(global, true) : function (w) {
      if (!w.document) {
        throw new Error('SUNEDITOR_LANG a window with a document');
      }
      return factory(w);
    };
  } else {
    factory(global);
  }
})(typeof window !== 'undefined' ? window : this, function (window, noGlobal) {
  var lang = {
    code: 'se',
    toolbar: {
      default: 'Default',
      save: 'Spara',
      font: 'Typsnitt',
      formats: 'Format',
      fontSize: 'Textstorlek',
      bold: 'Fet',
      underline: 'Understruket',
      italic: 'Kursiv',
      strike: 'Överstruket',
      subscript: 'Sänkt skrift',
      superscript: 'Höjd skrift',
      removeFormat: 'Ta bort formattering',
      fontColor: 'Textfärg',
      hiliteColor: 'Bakgrundsfärg',
      indent: 'Minska indrag',
      outdent: 'Öka indrag',
      align: 'Justering',
      alignLeft: 'Vänsterjustering',
      alignRight: 'Högerjustering',
      alignCenter: 'Mittenjusteirng',
      alignJustify: 'Justera indrag',
      list: 'Listor',
      orderList: 'Numrerad lista',
      unorderList: 'Oordnad lista',
      horizontalRule: 'Horisontell linje',
      hr_solid: 'Solid',
      hr_dotted: 'Punkter',
      hr_dashed: 'Prickad',
      table: 'Tabell',
      link: 'Länk',
      math: 'Math',
      image: 'Bild',
      video: 'Video',
      audio: 'Ljud',
      fullScreen: 'Helskärm',
      showBlocks: 'Visa block',
      codeView: 'Visa koder',
      undo: 'Ångra',
      redo: 'Gör om',
      preview: 'Preview',
      print: 'Print',
      tag_p: 'Paragraf',
      tag_div: 'Normal (DIV)',
      tag_h: 'Rubrik',
      tag_blockquote: 'Citer',
      tag_pre: 'Kod',
      template: 'Mall',
      lineHeight: 'Linjehöjd',
      paragraphStyle: 'Stil på stycke',
      textStyle: 'Textstil',
      imageGallery: 'Bildgalleri',
      dir_ltr: 'Vänster till höger',
      dir_rtl: 'Höger till vänster',
      mention: 'Namn'
    },
    dialogBox: {
      linkBox: {
        title: 'Lägg till länk',
        url: 'URL till länk',
        text: 'Länktext',
        newWindowCheck: 'Öppna i nytt fönster',
        downloadLinkCheck: 'Nedladdningslänk',
        bookmark: 'Bokmärke'
      },
      mathBox: {
        title: 'Math',
        inputLabel: 'Matematisk notation',
        fontSizeLabel: 'Textstorlek',
        previewLabel: 'Preview'
      },
      imageBox: {
        title: 'Lägg till bild',
        file: 'Lägg till från fil',
        url: 'Lägg till från URL',
        altText: 'Alternativ text'
      },
      videoBox: {
        title: 'Lägg till video',
        file: 'Lägg till från fil',
        url: 'Bädda in video / YouTube,Vimeo'
      },
      audioBox: {
        title: 'Lägg till ljud',
        file: 'Lägg till från fil',
        url: 'Lägg till från URL'
      },
      browser: {
        tags: 'Tags',
        search: 'Sök'
      },
      caption: 'Lägg till beskrivning',
      close: 'Stäng',
      submitButton: 'Skicka',
      revertButton: 'Återgå',
      proportion: 'Spara proportioner',
      basic: 'Basic',
      left: 'Vänster',
      right: 'Höger',
      center: 'Center',
      width: 'Bredd',
      height: 'Höjd',
      size: 'Storlek',
      ratio: 'Förhållande'
    },
    controller: {
      edit: 'Redigera',
      unlink: 'Ta bort länk',
      remove: 'Ta bort',
      insertRowAbove: 'Lägg till rad över',
      insertRowBelow: 'Lägg till rad under',
      deleteRow: 'Ta bort rad',
      insertColumnBefore: 'Lägg till kolumn före',
      insertColumnAfter: 'Lägg till kolumn efter',
      deleteColumn: 'Ta bort kolumner',
      fixedColumnWidth: 'Fast kolumnbredd',
      resize100: 'Förstora 100%',
      resize75: 'Förstora 75%',
      resize50: 'Förstora 50%',
      resize25: 'Förstora 25%',
      autoSize: 'Autostorlek',
      mirrorHorizontal: 'Spegling, horisontell',
      mirrorVertical: 'Spegling, vertikal',
      rotateLeft: 'Rotera till vänster',
      rotateRight: 'Rotera till höger',
      maxSize: 'Maxstorlek',
      minSize: 'Minsta storlek',
      tableHeader: 'Rubrik tabell',
      mergeCells: 'Sammanfoga celler (merge)',
      splitCells: 'Separera celler',
      HorizontalSplit: 'Separera horisontalt',
      VerticalSplit: 'Separera vertikalt'
    },
    menu: {
      spaced: 'Avstånd',
      bordered: 'Avgränsningslinje',
      neon: 'Neon',
      translucent: 'Genomskinlig',
      shadow: 'Skugga',
      code: 'Kod'
    }
  };
  if (typeof noGlobal === typeof undefined) {
    if (!window.SUNEDITOR_LANG) {
      Object.defineProperty(window, 'SUNEDITOR_LANG', {
        enumerable: true,
        writable: false,
        configurable: false,
        value: {}
      });
    }
    Object.defineProperty(window.SUNEDITOR_LANG, 'se', {
      enumerable: true,
      writable: true,
      configurable: true,
      value: lang
    });
  }
  return lang;
});

/***/ }),

/***/ 1025:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2017 JiHong Lee.
 * MIT license.
 */


(function (global, factory) {
  if ( true && typeof module.exports === 'object') {
    module.exports = global.document ? factory(global, true) : function (w) {
      if (!w.document) {
        throw new Error('SUNEDITOR_LANG a window with a document');
      }
      return factory(w);
    };
  } else {
    factory(global);
  }
})(typeof window !== "undefined" ? window : this, function (window, noGlobal) {
  var lang = {
    code: "ua",
    toolbar: {
      default: "По замовчуванням",
      save: "Зберегти",
      font: "Шрифт",
      formats: "Стиль абзацу",
      fontSize: "Розмір шрифту",
      bold: "Жирний",
      underline: "Підкреслений",
      italic: "Курсив",
      strike: "Перекреслити",
      subscript: "Нижній індекс",
      superscript: "Верхній індекс",
      removeFormat: "Очистити форматування",
      fontColor: "Колір тексту",
      hiliteColor: "Колір виділення",
      indent: "Збільшити відступ",
      outdent: "Зменшити відступ",
      align: "Вирівнювання",
      alignLeft: "За лівим краєм",
      alignRight: "За правим краєм",
      alignCenter: "По центру",
      alignJustify: "За шириною",
      list: "Список",
      orderList: "Нумерований",
      unorderList: "Маркований",
      horizontalRule: "Горизонтальна лінія",
      hr_solid: "Суцільна",
      hr_dotted: "Пунктирна",
      hr_dashed: "Штрихова",
      table: "Таблиця",
      link: "Посилання",
      math: "Формула",
      image: "Зображення",
      video: "Відео",
      audio: "Аудіо",
      fullScreen: "Повний екран",
      showBlocks: "Показати блоки",
      codeView: "Редагувати як HTML",
      undo: "Скасувати",
      redo: "Виконати знову",
      preview: "Попередній перегляд",
      print: "Друк",
      tag_p: "Абзац",
      tag_div: "Базовий",
      tag_h: "Заголовок",
      tag_blockquote: "Цитата",
      tag_pre: "Код",
      template: "Шаблон",
      lineHeight: "Висота лінії",
      paragraphStyle: "Стиль абзацу",
      textStyle: "Стиль тексту",
      imageGallery: "Галерея",
      dir_ltr: 'Зліва направо',
      dir_rtl: 'Справа наліво',
      mention: "Згадати"
    },
    dialogBox: {
      linkBox: {
        title: "Вставити посилання",
        url: "Посилання",
        text: "Текст",
        newWindowCheck: "Відкривати в новому вікні",
        downloadLinkCheck: 'Посилання для завантаження',
        bookmark: 'Закладка'
      },
      mathBox: {
        title: "Формула",
        inputLabel: "Математична запис",
        fontSizeLabel: "Розмір шрифту",
        previewLabel: "Попередній перегляд"
      },
      imageBox: {
        title: "Вставити зображення",
        file: "Виберіть файл",
        url: "Посилання на зображення",
        altText: "Текстовий опис зображення"
      },
      videoBox: {
        title: "Вставити відео",
        file: "Виберіть файл",
        url: "Посилання на відео, Youtube, Vimeo"
      },
      audioBox: {
        title: "Вставити аудіо",
        file: "Виберіть файл",
        url: "Посилання на аудіо"
      },
      browser: {
        tags: "Теги",
        search: "Пошук"
      },
      caption: "Додати підпис",
      close: "Закрити",
      submitButton: "Підтвердити",
      revertButton: "Скинути",
      proportion: "Зберегти пропорції",
      basic: "Без обтікання",
      left: "Зліва",
      right: "Справа",
      center: "По центру",
      width: "Ширина",
      height: "Висота",
      size: "Розмір",
      ratio: "Співвідношення"
    },
    controller: {
      edit: "Змінити",
      unlink: "Прибрати посилання",
      remove: "Видалити",
      insertRowAbove: "Вставити рядок вище",
      insertRowBelow: "Вставити рядок нижче",
      deleteRow: "Видалити рядок",
      insertColumnBefore: "Вставити стовпець зліва",
      insertColumnAfter: "Вставити стовпець справа",
      deleteColumn: "Видалити стовпець",
      fixedColumnWidth: "Фіксована ширина стовпця",
      resize100: "Розмір 100%",
      resize75: "Розмір 75%",
      resize50: "Розмір 50%",
      resize25: "Розмір 25%",
      autoSize: "Авто розмір",
      mirrorHorizontal: "Відобразити по горизонталі",
      mirrorVertical: "Відобразити по вертикалі",
      rotateLeft: "Повернути проти годинникової стрілки",
      rotateRight: "Повернути за годинниковою стрілкою",
      maxSize: "Ширина за розміром сторінки",
      minSize: "Ширина за вмістом",
      tableHeader: "Заголовок таблиці",
      mergeCells: "Об'єднати клітинки",
      splitCells: "Розділити клітинку",
      HorizontalSplit: "Розділити горизонтально",
      VerticalSplit: "Розділити вертикально"
    },
    menu: {
      spaced: "Інтервал",
      bordered: "З лініями",
      neon: "Неон",
      translucent: "Напівпрозорий",
      shadow: "Тінь",
      code: "Код"
    }
  };
  if (typeof noGlobal === typeof undefined) {
    if (!window.SUNEDITOR_LANG) {
      Object.defineProperty(window, "SUNEDITOR_LANG", {
        enumerable: true,
        writable: false,
        configurable: false,
        value: {}
      });
    }
    Object.defineProperty(window.SUNEDITOR_LANG, "ua", {
      enumerable: true,
      writable: true,
      configurable: true,
      value: lang
    });
  }
  return lang;
});

/***/ }),

/***/ 1026:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2019 JiHong Lee.
 * MIT license.
 */


(function (global, factory) {
  if ( true && typeof module.exports === 'object') {
    module.exports = global.document ? factory(global, true) : function (w) {
      if (!w.document) {
        throw new Error('SUNEDITOR_LANG a window with a document');
      }
      return factory(w);
    };
  } else {
    factory(global);
  }
})(typeof window !== 'undefined' ? window : this, function (window, noGlobal) {
  var lang = {
    code: 'zh_cn',
    toolbar: {
      default: '默认',
      save: '保存',
      font: '字体',
      formats: '格式',
      fontSize: '字号',
      bold: '粗体',
      underline: '下划线',
      italic: '斜体',
      strike: '删除线',
      subscript: '下标',
      superscript: '上标',
      removeFormat: '清除格式',
      fontColor: '字体颜色',
      hiliteColor: '背景颜色',
      indent: '增加缩进',
      outdent: '减少缩进',
      align: '对齐方式',
      alignLeft: '左对齐',
      alignRight: '右对齐',
      alignCenter: '居中',
      alignJustify: '两端对齐',
      list: '列表',
      orderList: '有序列表',
      unorderList: '无序列表',
      horizontalRule: '水平线',
      hr_solid: '实线',
      hr_dotted: '点线',
      hr_dashed: '虚线',
      table: '表格',
      link: '超链接',
      math: '数学',
      image: '图片',
      video: '视频',
      audio: '音讯',
      fullScreen: '全屏',
      showBlocks: '显示块区域',
      codeView: '代码视图',
      undo: '撤消',
      redo: '恢复',
      preview: '预览',
      print: '打印',
      tag_p: '段落',
      tag_div: '正文 (DIV)',
      tag_h: '标题',
      tag_blockquote: '引用',
      tag_pre: '代码',
      template: '模板',
      lineHeight: '行高',
      paragraphStyle: '段落样式',
      textStyle: '文字样式',
      imageGallery: '图片库',
      dir_ltr: '左到右',
      dir_rtl: '右到左',
      mention: '提到'
    },
    dialogBox: {
      linkBox: {
        title: '插入超链接',
        url: '网址',
        text: '要显示的文字',
        newWindowCheck: '在新标签页中打开',
        downloadLinkCheck: '下载链接',
        bookmark: '书签'
      },
      mathBox: {
        title: '数学',
        inputLabel: '数学符号',
        fontSizeLabel: '字号',
        previewLabel: '预览'
      },
      imageBox: {
        title: '插入图片',
        file: '上传图片',
        url: '图片网址',
        altText: '替换文字'
      },
      videoBox: {
        title: '插入视频',
        file: '上传图片',
        url: '嵌入网址, Youtube,Vimeo'
      },
      audioBox: {
        title: '插入音频',
        file: '上传图片',
        url: '音频网址'
      },
      browser: {
        tags: '标签',
        search: '搜索'
      },
      caption: '标题',
      close: '取消',
      submitButton: '确定',
      revertButton: '恢复',
      proportion: '比例',
      basic: '基本',
      left: '左',
      right: '右',
      center: '居中',
      width: '宽度',
      height: '高度',
      size: '尺寸',
      ratio: '比'
    },
    controller: {
      edit: '编辑',
      unlink: '去除链接',
      remove: '删除',
      insertRowAbove: '在上方插入',
      insertRowBelow: '在下方插入',
      deleteRow: '删除行',
      insertColumnBefore: '在左侧插入',
      insertColumnAfter: '在右侧插入',
      deleteColumn: '删除列',
      fixedColumnWidth: '固定列宽',
      resize100: '放大 100%',
      resize75: '放大 75%',
      resize50: '放大 50%',
      resize25: '放大 25%',
      mirrorHorizontal: '翻转左右',
      mirrorVertical: '翻转上下',
      rotateLeft: '向左旋转',
      rotateRight: '向右旋转',
      maxSize: '最大尺寸',
      minSize: '最小尺寸',
      tableHeader: '表格标题',
      mergeCells: '合并单元格',
      splitCells: '分割单元格',
      HorizontalSplit: '水平分割',
      VerticalSplit: '垂直分割'
    },
    menu: {
      spaced: '间隔开',
      bordered: '边界线',
      neon: '霓虹灯',
      translucent: '半透明',
      shadow: '阴影',
      code: '代码'
    }
  };
  if (typeof noGlobal === typeof undefined) {
    if (!window.SUNEDITOR_LANG) {
      Object.defineProperty(window, 'SUNEDITOR_LANG', {
        enumerable: true,
        writable: false,
        configurable: false,
        value: {}
      });
    }
    Object.defineProperty(window.SUNEDITOR_LANG, 'zh_cn', {
      enumerable: true,
      writable: true,
      configurable: true,
      value: lang
    });
  }
  return lang;
});

/***/ }),

/***/ 1027:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2017 JiHong Lee.
 * MIT license.
 */


(function (global, factory) {
  if ( true && typeof module.exports === 'object') {
    module.exports = global.document ? factory(global, true) : function (w) {
      if (!w.document) {
        throw new Error('SUNEDITOR_MODULES a window with a document');
      }
      return factory(w);
    };
  } else {
    factory(global);
  }
})(typeof window !== 'undefined' ? window : this, function (window, noGlobal) {
  var component = {
    name: 'component',
    /**
     * @description Create a container for the resizing component and insert the element.
     * @param {Element} cover Cover element (FIGURE)
     * @param {String} className Class name of container (fixed: se-component)
     * @returns {Element} Created container element
     */
    set_container: function set_container(cover, className) {
      var container = this.util.createElement('DIV');
      container.className = 'se-component ' + className;
      container.setAttribute('contenteditable', false);
      container.appendChild(cover);
      return container;
    },
    /**
     * @description Cover the target element with a FIGURE element.
     * @param {Element} element Target element
     */
    set_cover: function set_cover(element) {
      var cover = this.util.createElement('FIGURE');
      cover.appendChild(element);
      return cover;
    },
    /**
     * @description Return HTML string of caption(FIGCAPTION) element
     * @returns {String}
     */
    create_caption: function create_caption() {
      var caption = this.util.createElement('FIGCAPTION');
      caption.setAttribute('contenteditable', true);
      caption.innerHTML = '<div>' + this.lang.dialogBox.caption + '</div>';
      return caption;
    }
  };
  if (typeof noGlobal === typeof undefined) {
    if (!window.SUNEDITOR_MODULES) {
      Object.defineProperty(window, 'SUNEDITOR_MODULES', {
        enumerable: true,
        writable: false,
        configurable: false,
        value: {}
      });
    }
    Object.defineProperty(window.SUNEDITOR_MODULES, 'component', {
      enumerable: true,
      writable: false,
      configurable: false,
      value: component
    });
  }
  return component;
});

/***/ }),

/***/ 1028:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2017 JiHong Lee.
 * MIT license.
 */


(function (global, factory) {
  if ( true && typeof module.exports === 'object') {
    module.exports = global.document ? factory(global, true) : function (w) {
      if (!w.document) {
        throw new Error('SUNEDITOR_MODULES a window with a document');
      }
      return factory(w);
    };
  } else {
    factory(global);
  }
})(typeof window !== 'undefined' ? window : this, function (window, noGlobal) {
  var fileManager = {
    name: 'fileManager',
    _xmlHttp: null,
    _checkMediaComponent: function _checkMediaComponent(tag) {
      if (/IMG/i.test(tag)) {
        return !/FIGURE/i.test(tag.parentElement.nodeName) || !/FIGURE/i.test(tag.parentElement.parentElement.nodeName);
      }
      return true;
    },
    /**
     * @description Upload the file to the server.
     * @param {String} uploadUrl Upload server url
     * @param {Object|null} uploadHeader Request header
     * @param {FormData} formData FormData in body
     * @param {Function|null} callBack Success call back function
     * @param {Function|null} errorCallBack Error call back function
     * @example this.plugins.fileManager.upload.call(this, imageUploadUrl, this.options.imageUploadHeader, formData, this.plugins.image.callBack_imgUpload.bind(this, info), this.functions.onImageUploadError);
     */
    upload: function upload(uploadUrl, uploadHeader, formData, callBack, errorCallBack) {
      this.showLoading();
      var filePlugin = this.plugins.fileManager;
      var xmlHttp = filePlugin._xmlHttp = this.util.getXMLHttpRequest();
      xmlHttp.onreadystatechange = filePlugin._callBackUpload.bind(this, xmlHttp, callBack, errorCallBack);
      xmlHttp.open('post', uploadUrl, true);
      if (uploadHeader !== null && typeof uploadHeader === 'object' && this._w.Object.keys(uploadHeader).length > 0) {
        for (var key in uploadHeader) {
          xmlHttp.setRequestHeader(key, uploadHeader[key]);
        }
      }
      xmlHttp.send(formData);
    },
    _callBackUpload: function _callBackUpload(xmlHttp, callBack, errorCallBack) {
      if (xmlHttp.readyState === 4) {
        if (xmlHttp.status === 200) {
          try {
            callBack(xmlHttp);
          } catch (e) {
            throw Error('[SUNEDITOR.fileManager.upload.callBack.fail] cause : "' + e.message + '"');
          } finally {
            this.closeLoading();
          }
        } else {
          // exception
          this.closeLoading();
          var res = !xmlHttp.responseText ? xmlHttp : JSON.parse(xmlHttp.responseText);
          if (typeof errorCallBack !== 'function' || errorCallBack('', res, this)) {
            var err = '[SUNEDITOR.fileManager.upload.serverException] status: ' + xmlHttp.status + ', response: ' + (res.errorMessage || xmlHttp.responseText);
            this.functions.noticeOpen(err);
            throw Error(err);
          }
        }
      }
    },
    /**
     * @description Checke the file's information and modify the tag that does not fit the format.
     * @param {String} pluginName Plugin name
     * @param {Array} tagNames Tag array to check
     * @param {Function|null} uploadEventHandler Event handler to process updated file info after checking (used in "setInfo")
     * @param {Function} modifyHandler A function to modify a tag that does not fit the format (Argument value: Tag element)
     * @param {Boolean} resizing True if the plugin is using a resizing module
     * @example 
     * const modifyHandler = function (tag) {
     *      imagePlugin.onModifyMode.call(this, tag, null);
     *      imagePlugin.openModify.call(this, true);
     *      imagePlugin.update_image.call(this, true, false, true);
     *  }.bind(this);
     *  this.plugins.fileManager.checkInfo.call(this, 'image', ['img'], this.functions.onImageUpload, modifyHandler, true);
     */
    checkInfo: function checkInfo(pluginName, tagNames, uploadEventHandler, modifyHandler, resizing) {
      var tags = [];
      for (var i = 0, len = tagNames.length; i < len; i++) {
        tags = tags.concat([].slice.call(this.context.element.wysiwyg.querySelectorAll(tagNames[i] + ':not([data-se-embed="true"])')));
      }
      var fileManagerPlugin = this.plugins.fileManager;
      var context = this.context[pluginName];
      var infoList = context._infoList;
      var setFileInfo = fileManagerPlugin.setInfo.bind(this);
      if (tags.length === infoList.length) {
        // reset
        if (this._componentsInfoReset) {
          for (var _i = 0, _len = tags.length; _i < _len; _i++) {
            setFileInfo(pluginName, tags[_i], uploadEventHandler, null, resizing);
          }
          return;
        } else {
          var infoUpdate = false;
          var _loop = function _loop(_info) {
            _info = infoList[_i2];
            if (tags.filter(function (t) {
              return _info.src === t.src && _info.index.toString() === t.getAttribute('data-index');
            }).length === 0) {
              infoUpdate = true;
              info = _info;
              return "break";
            }
            info = _info;
          };
          for (var _i2 = 0, _len2 = infoList.length, info; _i2 < _len2; _i2++) {
            var _ret = _loop(info);
            if (_ret === "break") break;
          }
          // pass
          if (!infoUpdate) return;
        }
      }

      // check
      var _resize_plugin = resizing ? this.context.resizing._resize_plugin : '';
      if (resizing) this.context.resizing._resize_plugin = pluginName;
      var currentTags = [];
      var infoIndex = [];
      for (var _i3 = 0, _len3 = infoList.length; _i3 < _len3; _i3++) {
        infoIndex[_i3] = infoList[_i3].index;
      }
      for (var _i4 = 0, _len4 = tags.length, tag; _i4 < _len4; _i4++) {
        tag = tags[_i4];
        if (!this.util.getParentElement(tag, this.util.isMediaComponent) || !fileManagerPlugin._checkMediaComponent(tag)) {
          currentTags.push(context._infoIndex);
          modifyHandler(tag);
        } else if (!tag.getAttribute('data-index') || infoIndex.indexOf(tag.getAttribute('data-index') * 1) < 0) {
          currentTags.push(context._infoIndex);
          tag.removeAttribute('data-index');
          setFileInfo(pluginName, tag, uploadEventHandler, null, resizing);
        } else {
          currentTags.push(tag.getAttribute('data-index') * 1);
        }
      }
      for (var _i5 = 0, dataIndex; _i5 < infoList.length; _i5++) {
        dataIndex = infoList[_i5].index;
        if (currentTags.indexOf(dataIndex) > -1) continue;
        infoList.splice(_i5, 1);
        if (typeof uploadEventHandler === 'function') uploadEventHandler(null, dataIndex, 'delete', null, 0, this);
        _i5--;
      }
      if (resizing) this.context.resizing._resize_plugin = _resize_plugin;
    },
    /**
     * @description Create info object of file and add it to "_infoList" (this.context[pluginName]._infoList[])
     * @param {String} pluginName Plugin name 
     * @param {Element} element 
     * @param {Function|null} uploadEventHandler Event handler to process updated file info (created in setInfo)
     * @param {Object|null} file 
     * @param {Boolean} resizing True if the plugin is using a resizing module
     * @example 
     * uploadCallBack {.. file = { name: fileList[i].name, size: fileList[i].size };
     * this.plugins.fileManager.setInfo.call(this, 'image', oImg, this.functions.onImageUpload, file, true);
     */
    setInfo: function setInfo(pluginName, element, uploadEventHandler, file, resizing) {
      var _resize_plugin = resizing ? this.context.resizing._resize_plugin : '';
      if (resizing) this.context.resizing._resize_plugin = pluginName;
      var plguin = this.plugins[pluginName];
      var context = this.context[pluginName];
      var infoList = context._infoList;
      var dataIndex = element.getAttribute('data-index');
      var info = null;
      var state = '';
      if (!file) {
        file = {
          'name': element.getAttribute('data-file-name') || (typeof element.src === 'string' ? element.src.split('/').pop() : ''),
          'size': element.getAttribute('data-file-size') || 0
        };
      }

      // create
      if (!dataIndex || this._componentsInfoInit) {
        state = 'create';
        dataIndex = context._infoIndex++;
        element.setAttribute('data-index', dataIndex);
        element.setAttribute('data-file-name', file.name);
        element.setAttribute('data-file-size', file.size);
        info = {
          src: element.src,
          index: dataIndex * 1,
          name: file.name,
          size: file.size
        };
        infoList.push(info);
      } else {
        // update
        state = 'update';
        dataIndex *= 1;
        for (var i = 0, len = infoList.length; i < len; i++) {
          if (dataIndex === infoList[i].index) {
            info = infoList[i];
            break;
          }
        }
        if (!info) {
          dataIndex = context._infoIndex++;
          info = {
            index: dataIndex
          };
          infoList.push(info);
        }
        info.src = element.src;
        info.name = element.getAttribute("data-file-name");
        info.size = element.getAttribute("data-file-size") * 1;
      }

      // method bind
      info.element = element;
      info.delete = plguin.destroy.bind(this, element);
      info.select = function (element) {
        element.scrollIntoView(true);
        this._w.setTimeout(plguin.select.bind(this, element));
      }.bind(this, element);
      if (resizing) {
        if (!element.getAttribute('origin-size') && element.naturalWidth) {
          element.setAttribute('origin-size', element.naturalWidth + ',' + element.naturalHeight);
        }
        if (!element.getAttribute('data-origin')) {
          var container = this.util.getParentElement(element, this.util.isMediaComponent);
          var cover = this.util.getParentElement(element, 'FIGURE');
          var w = this.plugins.resizing._module_getSizeX.call(this, context, element, cover, container);
          var h = this.plugins.resizing._module_getSizeY.call(this, context, element, cover, container);
          element.setAttribute('data-origin', w + ',' + h);
          element.setAttribute('data-size', w + ',' + h);
        }
        if (!element.style.width) {
          var size = (element.getAttribute('data-size') || element.getAttribute('data-origin') || '').split(',');
          plguin.onModifyMode.call(this, element, null);
          plguin.applySize.call(this, size[0], size[1]);
        }
        this.context.resizing._resize_plugin = _resize_plugin;
      }
      if (typeof uploadEventHandler === 'function') uploadEventHandler(element, dataIndex, state, info, --context._uploadFileLength < 0 ? 0 : context._uploadFileLength, this);
    },
    /**
     * @description Delete info object at "_infoList"
     * @param {String} pluginName Plugin name 
     * @param {Number} index index of info object (this.context[pluginName]._infoList[].index)
     * @param {Function|null} uploadEventHandler Event handler to process updated file info (created in setInfo)
     */
    deleteInfo: function deleteInfo(pluginName, index, uploadEventHandler) {
      if (index >= 0) {
        var infoList = this.context[pluginName]._infoList;
        for (var i = 0, len = infoList.length; i < len; i++) {
          if (index === infoList[i].index) {
            infoList.splice(i, 1);
            if (typeof uploadEventHandler === 'function') uploadEventHandler(null, index, 'delete', null, 0, this);
            return;
          }
        }
      }
    },
    /**
     * @description Reset info object and "_infoList = []", "_infoIndex = 0"
     * @param {String} pluginName Plugin name 
     * @param {Function|null} uploadEventHandler Event handler to process updated file info (created in setInfo)
     */
    resetInfo: function resetInfo(pluginName, uploadEventHandler) {
      var context = this.context[pluginName];
      if (typeof uploadEventHandler === 'function') {
        var infoList = context._infoList;
        for (var i = 0, len = infoList.length; i < len; i++) {
          uploadEventHandler(null, infoList[i].index, 'delete', null, 0, this);
        }
      }
      context._infoList = [];
      context._infoIndex = 0;
    }
  };
  if (typeof noGlobal === typeof undefined) {
    if (!window.SUNEDITOR_MODULES) {
      Object.defineProperty(window, 'SUNEDITOR_MODULES', {
        enumerable: true,
        writable: false,
        configurable: false,
        value: {}
      });
    }
    Object.defineProperty(window.SUNEDITOR_MODULES, 'fileManager', {
      enumerable: true,
      writable: false,
      configurable: false,
      value: fileManager
    });
  }
  return fileManager;
});

/***/ }),

/***/ 1443:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2017 JiHong Lee.
 * MIT license.
 */


(function (global, factory) {
  if ( true && typeof module.exports === 'object') {
    module.exports = global.document ? factory(global, true) : function (w) {
      if (!w.document) {
        throw new Error('SUNEDITOR_MODULES a window with a document');
      }
      return factory(w);
    };
  } else {
    factory(global);
  }
})(typeof window !== 'undefined' ? window : this, function (window, noGlobal) {
  var resizing = {
    name: 'resizing',
    /**
     * @description Constructor
     * Require context properties when resizing module
        inputX: Element,
        inputY: Element,
        _container: null,
        _cover: null,
        _element: null,
        _element_w: 1,
        _element_h: 1,
        _element_l: 0,
        _element_t: 0,
        _defaultSizeX: 'auto',
        _defaultSizeY: 'auto',
        _origin_w: core.options.imageWidth === 'auto' ? '' : core.options.imageWidth,
        _origin_h: core.options.imageHeight === 'auto' ? '' : core.options.imageHeight,
        _proportionChecked: true,
        // -- select function --
        _resizing: core.options.imageResizing,
        _resizeDotHide: !core.options.imageHeightShow,
        _rotation: core.options.imageRotation,
        _onlyPercentage: core.options.imageSizeOnlyPercentage,
        _ratio: false,
        _ratioX: 1,
        _ratioY: 1
        _captionShow: true,
        // -- when used caption (_captionShow: true) --
        _caption: null,
        _captionChecked: false,
        captionCheckEl: null,
     * @param {Object} core Core object 
     */
    add: function add(core) {
      var icons = core.icons;
      var context = core.context;
      context.resizing = {
        _resizeClientX: 0,
        _resizeClientY: 0,
        _resize_plugin: '',
        _resize_w: 0,
        _resize_h: 0,
        _origin_w: 0,
        _origin_h: 0,
        _rotateVertical: false,
        _resize_direction: '',
        _move_path: null,
        _isChange: false,
        alignIcons: {
          basic: icons.align_justify,
          left: icons.align_left,
          right: icons.align_right,
          center: icons.align_center
        }
      };

      /** resize controller, button */
      var resize_div_container = this.setController_resize(core);
      context.resizing.resizeContainer = resize_div_container;
      context.resizing.resizeDiv = resize_div_container.querySelector('.se-modal-resize');
      context.resizing.resizeDot = resize_div_container.querySelector('.se-resize-dot');
      context.resizing.resizeDisplay = resize_div_container.querySelector('.se-resize-display');
      var resize_button = this.setController_button(core);
      context.resizing.resizeButton = resize_button;
      var resize_handles = context.resizing.resizeHandles = context.resizing.resizeDot.querySelectorAll('span');
      context.resizing.resizeButtonGroup = resize_button.querySelector('._se_resizing_btn_group');
      context.resizing.rotationButtons = resize_button.querySelectorAll('._se_resizing_btn_group ._se_rotation');
      context.resizing.percentageButtons = resize_button.querySelectorAll('._se_resizing_btn_group ._se_percentage');
      context.resizing.alignMenu = resize_button.querySelector('.se-resizing-align-list');
      context.resizing.alignMenuList = context.resizing.alignMenu.querySelectorAll('button');
      context.resizing.alignButton = resize_button.querySelector('._se_resizing_align_button');
      context.resizing.autoSizeButton = resize_button.querySelector('._se_resizing_btn_group ._se_auto_size');
      context.resizing.captionButton = resize_button.querySelector('._se_resizing_caption_button');

      /** add event listeners */
      resize_div_container.addEventListener('mousedown', function (e) {
        e.preventDefault();
      });
      resize_handles[0].addEventListener('mousedown', this.onMouseDown_resize_handle.bind(core));
      resize_handles[1].addEventListener('mousedown', this.onMouseDown_resize_handle.bind(core));
      resize_handles[2].addEventListener('mousedown', this.onMouseDown_resize_handle.bind(core));
      resize_handles[3].addEventListener('mousedown', this.onMouseDown_resize_handle.bind(core));
      resize_handles[4].addEventListener('mousedown', this.onMouseDown_resize_handle.bind(core));
      resize_handles[5].addEventListener('mousedown', this.onMouseDown_resize_handle.bind(core));
      resize_handles[6].addEventListener('mousedown', this.onMouseDown_resize_handle.bind(core));
      resize_handles[7].addEventListener('mousedown', this.onMouseDown_resize_handle.bind(core));
      resize_button.addEventListener('click', this.onClick_resizeButton.bind(core));

      /** append html */
      context.element.relative.appendChild(resize_div_container);
      context.element.relative.appendChild(resize_button);

      /** empty memory */
      resize_div_container = null, resize_button = null, resize_handles = null;
    },
    /** resize controller, button (image, iframe, video) */
    setController_resize: function setController_resize(core) {
      var resize_container = core.util.createElement('DIV');
      resize_container.className = 'se-controller se-resizing-container';
      resize_container.style.display = 'none';
      resize_container.innerHTML = '' + '<div class="se-modal-resize"></div>' + '<div class="se-resize-dot">' + '<span class="tl"></span>' + '<span class="tr"></span>' + '<span class="bl"></span>' + '<span class="br"></span>' + '<span class="lw"></span>' + '<span class="th"></span>' + '<span class="rw"></span>' + '<span class="bh"></span>' + '<div class="se-resize-display"></div>' + '</div>';
      return resize_container;
    },
    setController_button: function setController_button(core) {
      var lang = core.lang;
      var icons = core.icons;
      var resize_button = core.util.createElement("DIV");
      resize_button.className = "se-controller se-controller-resizing";
      resize_button.innerHTML = '' + '<div class="se-arrow se-arrow-up"></div>' + '<div class="se-btn-group _se_resizing_btn_group">' + '<button type="button" data-command="percent" data-value="1" class="se-tooltip _se_percentage">' + '<span>100%</span>' + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.resize100 + '</span></span>' + '</button>' + '<button type="button" data-command="percent" data-value="0.75" class="se-tooltip _se_percentage">' + '<span>75%</span>' + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.resize75 + '</span></span>' + '</button>' + '<button type="button" data-command="percent" data-value="0.5" class="se-tooltip _se_percentage">' + '<span>50%</span>' + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.resize50 + '</span></span>' + '</button>' + '<button type="button" data-command="auto" class="se-btn se-tooltip _se_auto_size">' + icons.auto_size + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.autoSize + '</span></span>' + '</button>' + '<button type="button" data-command="rotate" data-value="-90" class="se-btn se-tooltip _se_rotation">' + icons.rotate_left + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.rotateLeft + '</span></span>' + '</button>' + '<button type="button" data-command="rotate" data-value="90" class="se-btn se-tooltip _se_rotation">' + icons.rotate_right + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.rotateRight + '</span></span>' + '</button>' + '</div>' + '<div class="se-btn-group" style="padding-top: 0;">' + '<button type="button" data-command="mirror" data-value="h" class="se-btn se-tooltip">' + icons.mirror_horizontal + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.mirrorHorizontal + '</span></span>' + '</button>' + '<button type="button" data-command="mirror" data-value="v" class="se-btn se-tooltip">' + icons.mirror_vertical + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.mirrorVertical + '</span></span>' + '</button>' + '<button type="button" data-command="onalign" class="se-btn se-tooltip _se_resizing_align_button">' + icons.align_justify + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.toolbar.align + '</span></span>' + '</button>' + '<div class="se-btn-group-sub sun-editor-common se-list-layer se-resizing-align-list">' + '<div class="se-list-inner">' + '<ul class="se-list-basic">' + '<li><button type="button" class="se-btn-list se-tooltip" data-command="align" data-value="basic">' + icons.align_justify + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.dialogBox.basic + '</span></span>' + '</button></li>' + '<li><button type="button" class="se-btn-list se-tooltip" data-command="align" data-value="left">' + icons.align_left + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.dialogBox.left + '</span></span>' + '</button></li>' + '<li><button type="button" class="se-btn-list se-tooltip" data-command="align" data-value="center">' + icons.align_center + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.dialogBox.center + '</span></span>' + '</button></li>' + '<li><button type="button" class="se-btn-list se-tooltip" data-command="align" data-value="right">' + icons.align_right + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.dialogBox.right + '</span></span>' + '</button></li>' + '</ul>' + '</div>' + '</div>' + '<button type="button" data-command="caption" class="se-btn se-tooltip _se_resizing_caption_button">' + icons.caption + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.dialogBox.caption + '</span></span>' + '</button>' + '<button type="button" data-command="revert" class="se-btn se-tooltip">' + icons.revert + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.dialogBox.revertButton + '</span></span>' + '</button>' + '<button type="button" data-command="update" class="se-btn se-tooltip">' + icons.modify + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.edit + '</span></span>' + '</button>' + '<button type="button" data-command="delete" class="se-btn se-tooltip">' + icons.delete + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.remove + '</span></span>' + '</button>' + '</div>';
      return resize_button;
    },
    /**
     * @description Gets the width size
     * @param {Object} contextPlugin context object of plugin (core.context[plugin])
     * @param {Element} element Target element
     * @param {Element} cover Cover element (FIGURE)
     * @param {Element} container Container element (DIV.se-component)
     * @returns {String}
     */
    _module_getSizeX: function _module_getSizeX(contextPlugin, element, cover, container) {
      if (!element) element = contextPlugin._element;
      if (!cover) cover = contextPlugin._cover;
      if (!container) container = contextPlugin._container;
      if (!element) return '';
      return !/%$/.test(element.style.width) ? element.style.width : (container && this.util.getNumber(container.style.width, 2) || 100) + '%';
    },
    /**
     * @description Gets the height size
     * @param {Object} contextPlugin context object of plugin (core.context[plugin])
     * @param {Element} element Target element
     * @param {Element} cover Cover element (FIGURE)
     * @param {Element} container Container element (DIV.se-component)
     * @returns {String}
     */
    _module_getSizeY: function _module_getSizeY(contextPlugin, element, cover, container) {
      if (!element) element = contextPlugin._element;
      if (!cover) cover = contextPlugin._cover;
      if (!container) container = contextPlugin._container;
      if (!container || !cover) return element && element.style.height || '';
      return this.util.getNumber(cover.style.paddingBottom, 0) > 0 && !this.context.resizing._rotateVertical ? cover.style.height : !/%$/.test(element.style.height) || !/%$/.test(element.style.width) ? element.style.height : (container && this.util.getNumber(container.style.height, 2) || 100) + '%';
    },
    /**
     * @description Called at the "openModify" to put the size of the current target into the size input element.
     * @param {Object} contextPlugin context object of plugin (core.context[plugin])
     * @param {Object} pluginObj Plugin object
     */
    _module_setModifyInputSize: function _module_setModifyInputSize(contextPlugin, pluginObj) {
      var percentageRotation = contextPlugin._onlyPercentage && this.context.resizing._rotateVertical;
      contextPlugin.proportion.checked = contextPlugin._proportionChecked = contextPlugin._element.getAttribute('data-proportion') !== 'false';
      var x = percentageRotation ? '' : this.plugins.resizing._module_getSizeX.call(this, contextPlugin);
      if (x === contextPlugin._defaultSizeX) x = '';
      if (contextPlugin._onlyPercentage) x = this.util.getNumber(x, 2);
      contextPlugin.inputX.value = x;
      pluginObj.setInputSize.call(this, 'x');
      if (!contextPlugin._onlyPercentage) {
        var y = percentageRotation ? '' : this.plugins.resizing._module_getSizeY.call(this, contextPlugin);
        if (y === contextPlugin._defaultSizeY) y = '';
        if (contextPlugin._onlyPercentage) y = this.util.getNumber(y, 2);
        contextPlugin.inputY.value = y;
      }
      contextPlugin.inputX.disabled = percentageRotation ? true : false;
      contextPlugin.inputY.disabled = percentageRotation ? true : false;
      contextPlugin.proportion.disabled = percentageRotation ? true : false;
      pluginObj.setRatio.call(this);
    },
    /**
     * @description It is called in "setInputSize" (input tag keyupEvent), 
     * checks the value entered in the input tag, 
     * calculates the ratio, and sets the calculated value in the input tag of the opposite size.
     * @param {Object} contextPlugin context object of plugin (core.context[plugin])
     * @param {String} xy 'x': width, 'y': height
     */
    _module_setInputSize: function _module_setInputSize(contextPlugin, xy) {
      if (contextPlugin._onlyPercentage) {
        if (xy === 'x' && contextPlugin.inputX.value > 100) contextPlugin.inputX.value = 100;
        return;
      }
      if (contextPlugin.proportion.checked && contextPlugin._ratio && /\d/.test(contextPlugin.inputX.value) && /\d/.test(contextPlugin.inputY.value)) {
        var xUnit = contextPlugin.inputX.value.replace(/\d+|\./g, '') || contextPlugin.sizeUnit;
        var yUnit = contextPlugin.inputY.value.replace(/\d+|\./g, '') || contextPlugin.sizeUnit;
        if (xUnit !== yUnit) return;
        var dec = xUnit === '%' ? 2 : 0;
        if (xy === 'x') {
          contextPlugin.inputY.value = this.util.getNumber(contextPlugin._ratioY * this.util.getNumber(contextPlugin.inputX.value, dec), dec) + yUnit;
        } else {
          contextPlugin.inputX.value = this.util.getNumber(contextPlugin._ratioX * this.util.getNumber(contextPlugin.inputY.value, dec), dec) + xUnit;
        }
      }
    },
    /**
     * @description It is called in "setRatio" (input and proportionCheck tags changeEvent), 
     * checks the value of the input tag, calculates the ratio, and resets it in the input tag.
     * @param {Object} contextPlugin context object of plugin (core.context[plugin])
     */
    _module_setRatio: function _module_setRatio(contextPlugin) {
      var xValue = contextPlugin.inputX.value;
      var yValue = contextPlugin.inputY.value;
      if (contextPlugin.proportion.checked && /\d+/.test(xValue) && /\d+/.test(yValue)) {
        var xUnit = xValue.replace(/\d+|\./g, '') || contextPlugin.sizeUnit;
        var yUnit = yValue.replace(/\d+|\./g, '') || contextPlugin.sizeUnit;
        if (xUnit !== yUnit) {
          contextPlugin._ratio = false;
        } else if (!contextPlugin._ratio) {
          var x = this.util.getNumber(xValue, 0);
          var y = this.util.getNumber(yValue, 0);
          contextPlugin._ratio = true;
          contextPlugin._ratioX = x / y;
          contextPlugin._ratioY = y / x;
        }
      } else {
        contextPlugin._ratio = false;
      }
    },
    /**
     * @description Revert size of element to origin size (plugin._origin_w, plugin._origin_h)
     * @param {Object} contextPlugin context object of plugin (core.context[plugin])
     */
    _module_sizeRevert: function _module_sizeRevert(contextPlugin) {
      if (contextPlugin._onlyPercentage) {
        contextPlugin.inputX.value = contextPlugin._origin_w > 100 ? 100 : contextPlugin._origin_w;
      } else {
        contextPlugin.inputX.value = contextPlugin._origin_w;
        contextPlugin.inputY.value = contextPlugin._origin_h;
      }
    },
    /**
     * @description Save the size data (element.setAttribute("data-size"))
     * Used at the "setSize" method
     * @param {Object} contextPlugin context object of plugin (core.context[plugin])
     */
    _module_saveCurrentSize: function _module_saveCurrentSize(contextPlugin) {
      var x = this.plugins.resizing._module_getSizeX.call(this, contextPlugin);
      var y = this.plugins.resizing._module_getSizeY.call(this, contextPlugin);
      contextPlugin._element.setAttribute('data-size', x + ',' + y);
      if (!!contextPlugin._videoRatio) contextPlugin._videoRatio = y;
    },
    /**
     * @description Call the resizing module
     * @param {Element} targetElement Resizing target element
     * @param {string} plugin Plugin name
     * @returns {Object} Size of resizing div {w, h, t, l}
     */
    call_controller_resize: function call_controller_resize(targetElement, plugin) {
      var contextResizing = this.context.resizing;
      var contextPlugin = this.context[plugin];
      contextResizing._resize_plugin = plugin;
      var resizeContainer = contextResizing.resizeContainer;
      var resizeDiv = contextResizing.resizeDiv;
      var offset = this.util.getOffset(targetElement, this.context.element.wysiwygFrame);
      var isVertical = contextResizing._rotateVertical = /^(90|270)$/.test(Math.abs(targetElement.getAttribute('data-rotate')).toString());
      var w = isVertical ? targetElement.offsetHeight : targetElement.offsetWidth;
      var h = isVertical ? targetElement.offsetWidth : targetElement.offsetHeight;
      var t = offset.top;
      var l = offset.left - this.context.element.wysiwygFrame.scrollLeft;
      resizeContainer.style.top = t + 'px';
      resizeContainer.style.left = l + 'px';
      resizeContainer.style.width = w + 'px';
      resizeContainer.style.height = h + 'px';
      resizeDiv.style.top = '0px';
      resizeDiv.style.left = '0px';
      resizeDiv.style.width = w + 'px';
      resizeDiv.style.height = h + 'px';
      var align = targetElement.getAttribute('data-align') || 'basic';
      align = align === 'none' ? 'basic' : align;

      // text
      var container = this.util.getParentElement(targetElement, this.util.isComponent);
      var cover = this.util.getParentElement(targetElement, 'FIGURE');
      var displayX = this.plugins.resizing._module_getSizeX.call(this, contextPlugin, targetElement, cover, container) || 'auto';
      var displayY = contextPlugin._onlyPercentage && plugin === 'image' ? '' : ', ' + (this.plugins.resizing._module_getSizeY.call(this, contextPlugin, targetElement, cover, container) || 'auto');
      this.util.changeTxt(contextResizing.resizeDisplay, this.lang.dialogBox[align] + ' (' + displayX + displayY + ')');

      // resizing display
      contextResizing.resizeButtonGroup.style.display = contextPlugin._resizing ? '' : 'none';
      var resizeDotShow = contextPlugin._resizing && !contextPlugin._resizeDotHide && !contextPlugin._onlyPercentage ? 'flex' : 'none';
      var resizeHandles = contextResizing.resizeHandles;
      for (var i = 0, len = resizeHandles.length; i < len; i++) {
        resizeHandles[i].style.display = resizeDotShow;
      }
      if (contextPlugin._resizing) {
        var rotations = contextResizing.rotationButtons;
        rotations[0].style.display = rotations[1].style.display = contextPlugin._rotation ? '' : 'none';
      }

      // align icon
      if (contextPlugin._alignHide) {
        contextResizing.alignButton.style.display = 'none';
      } else {
        contextResizing.alignButton.style.display = '';
        var alignList = contextResizing.alignMenuList;
        this.util.changeElement(contextResizing.alignButton.firstElementChild, contextResizing.alignIcons[align]);
        for (var _i = 0, _len = alignList.length; _i < _len; _i++) {
          if (alignList[_i].getAttribute('data-value') === align) this.util.addClass(alignList[_i], 'on');else this.util.removeClass(alignList[_i], 'on');
        }
      }

      // percentage active
      var pButtons = contextResizing.percentageButtons;
      var value = /%$/.test(targetElement.style.width) && /%$/.test(container.style.width) ? this.util.getNumber(container.style.width, 0) / 100 + '' : '';
      for (var _i2 = 0, _len2 = pButtons.length; _i2 < _len2; _i2++) {
        if (pButtons[_i2].getAttribute('data-value') === value) {
          this.util.addClass(pButtons[_i2], 'active');
        } else {
          this.util.removeClass(pButtons[_i2], 'active');
        }
      }

      // caption display, active
      if (!contextPlugin._captionShow) {
        contextResizing.captionButton.style.display = 'none';
      } else {
        contextResizing.captionButton.style.display = '';
        if (this.util.getChildElement(targetElement.parentNode, 'figcaption')) {
          this.util.addClass(contextResizing.captionButton, 'active');
          contextPlugin._captionChecked = true;
        } else {
          this.util.removeClass(contextResizing.captionButton, 'active');
          contextPlugin._captionChecked = false;
        }
      }
      resizeContainer.style.display = 'block';
      var addOffset = {
        left: 0,
        top: 50
      };
      if (this.options.iframe) {
        addOffset.left -= this.context.element.wysiwygFrame.parentElement.offsetLeft;
        addOffset.top -= this.context.element.wysiwygFrame.parentElement.offsetTop;
      }
      this.setControllerPosition(contextResizing.resizeButton, resizeContainer, 'bottom', addOffset);
      this.controllersOn(resizeContainer, contextResizing.resizeButton, this.util.setDisabledButtons.bind(this.util, false, this.resizingDisabledButtons), targetElement, plugin);
      this.util.setDisabledButtons(true, this.resizingDisabledButtons);
      contextResizing._resize_w = w;
      contextResizing._resize_h = h;
      var originSize = (targetElement.getAttribute('origin-size') || '').split(',');
      contextResizing._origin_w = originSize[0] || targetElement.naturalWidth;
      contextResizing._origin_h = originSize[1] || targetElement.naturalHeight;
      return {
        w: w,
        h: h,
        t: t,
        l: l
      };
    },
    _closeAlignMenu: null,
    /**
     * @description Open align submenu of module
     */
    openAlignMenu: function openAlignMenu() {
      var alignButton = this.context.resizing.alignButton;
      this.util.addClass(alignButton, 'on');
      this.context.resizing.alignMenu.style.top = alignButton.offsetTop + alignButton.offsetHeight + 'px';
      this.context.resizing.alignMenu.style.left = alignButton.offsetLeft - alignButton.offsetWidth / 2 + 'px';
      this.context.resizing.alignMenu.style.display = 'block';
      this.plugins.resizing._closeAlignMenu = function () {
        this.util.removeClass(this.context.resizing.alignButton, 'on');
        this.context.resizing.alignMenu.style.display = 'none';
        this.removeDocEvent('click', this.plugins.resizing._closeAlignMenu);
        this.plugins.resizing._closeAlignMenu = null;
      }.bind(this);
      this.addDocEvent('click', this.plugins.resizing._closeAlignMenu);
    },
    /**
     * @description Click event of resizing toolbar
     * Performs the action of the clicked toolbar button.
     * @param {MouseEvent} e Event object
     */
    onClick_resizeButton: function onClick_resizeButton(e) {
      e.stopPropagation();
      var target = e.target;
      var command = target.getAttribute('data-command') || target.parentNode.getAttribute('data-command');
      if (!command) return;
      var value = target.getAttribute('data-value') || target.parentNode.getAttribute('data-value');
      var pluginName = this.context.resizing._resize_plugin;
      var currentContext = this.context[pluginName];
      var contextEl = currentContext._element;
      var currentModule = this.plugins[pluginName];
      e.preventDefault();
      if (typeof this.plugins.resizing._closeAlignMenu === 'function') {
        this.plugins.resizing._closeAlignMenu();
        if (command === 'onalign') return;
      }
      switch (command) {
        case 'auto':
          this.plugins.resizing.resetTransform.call(this, contextEl);
          currentModule.setAutoSize.call(this);
          this.selectComponent(contextEl, pluginName);
          break;
        case 'percent':
          var percentY = this.plugins.resizing._module_getSizeY.call(this, currentContext);
          if (this.context.resizing._rotateVertical) {
            var percentage = contextEl.getAttribute('data-percentage');
            if (percentage) percentY = percentage.split(',')[1];
          }
          this.plugins.resizing.resetTransform.call(this, contextEl);
          currentModule.setPercentSize.call(this, value * 100, this.util.getNumber(percentY, 0) === null || !/%$/.test(percentY) ? '' : percentY);
          this.selectComponent(contextEl, pluginName);
          break;
        case 'mirror':
          var r = contextEl.getAttribute('data-rotate') || '0';
          var x = contextEl.getAttribute('data-rotateX') || '';
          var y = contextEl.getAttribute('data-rotateY') || '';
          if (value === 'h' && !this.context.resizing._rotateVertical || value === 'v' && this.context.resizing._rotateVertical) {
            y = y ? '' : '180';
          } else {
            x = x ? '' : '180';
          }
          contextEl.setAttribute('data-rotateX', x);
          contextEl.setAttribute('data-rotateY', y);
          this.plugins.resizing._setTransForm(contextEl, r, x, y);
          break;
        case 'rotate':
          var contextResizing = this.context.resizing;
          var slope = contextEl.getAttribute('data-rotate') * 1 + value * 1;
          var deg = this._w.Math.abs(slope) >= 360 ? 0 : slope;
          contextEl.setAttribute('data-rotate', deg);
          contextResizing._rotateVertical = /^(90|270)$/.test(this._w.Math.abs(deg).toString());
          this.plugins.resizing.setTransformSize.call(this, contextEl, null, null);
          this.selectComponent(contextEl, pluginName);
          break;
        case 'onalign':
          this.plugins.resizing.openAlignMenu.call(this);
          return;
        case 'align':
          var alignValue = value === 'basic' ? 'none' : value;
          currentModule.setAlign.call(this, alignValue, null, null, null);
          this.selectComponent(contextEl, pluginName);
          break;
        case 'caption':
          var caption = !currentContext._captionChecked;
          currentModule.openModify.call(this, true);
          currentContext._captionChecked = currentContext.captionCheckEl.checked = caption;
          currentModule.update_image.call(this, false, false, false);
          if (caption) {
            var captionText = this.util.getChildElement(currentContext._caption, function (current) {
              return current.nodeType === 3;
            });
            if (!captionText) {
              currentContext._caption.focus();
            } else {
              this.setRange(captionText, 0, captionText, captionText.textContent.length);
            }
            this.controllersOff();
          } else {
            this.selectComponent(contextEl, pluginName);
            currentModule.openModify.call(this, true);
          }
          break;
        case 'revert':
          currentModule.setOriginSize.call(this);
          this.selectComponent(contextEl, pluginName);
          break;
        case 'update':
          currentModule.openModify.call(this);
          this.controllersOff();
          break;
        case 'delete':
          currentModule.destroy.call(this);
          break;
      }

      // history stack
      this.history.push(false);
    },
    /**
     * @description Initialize the transform style (rotation) of the element.
     * @param {Element} element Target element
     */
    resetTransform: function resetTransform(element) {
      var size = (element.getAttribute('data-size') || element.getAttribute('data-origin') || '').split(',');
      this.context.resizing._rotateVertical = false;
      element.style.maxWidth = '';
      element.style.transform = '';
      element.style.transformOrigin = '';
      element.setAttribute('data-rotate', '');
      element.setAttribute('data-rotateX', '');
      element.setAttribute('data-rotateY', '');
      this.plugins[this.context.resizing._resize_plugin].setSize.call(this, size[0] ? size[0] : 'auto', size[1] ? size[1] : '', true);
    },
    /**
     * @description Set the transform style (rotation) of the element.
     * @param {Element} element Target element
     * @param {Number|null} width Element's width size
     * @param {Number|null} height Element's height size
     */
    setTransformSize: function setTransformSize(element, width, height) {
      var percentage = element.getAttribute('data-percentage');
      var isVertical = this.context.resizing._rotateVertical;
      var deg = element.getAttribute('data-rotate') * 1;
      var transOrigin = '';
      if (percentage && !isVertical) {
        percentage = percentage.split(',');
        if (percentage[0] === 'auto' && percentage[1] === 'auto') {
          this.plugins[this.context.resizing._resize_plugin].setAutoSize.call(this);
        } else {
          this.plugins[this.context.resizing._resize_plugin].setPercentSize.call(this, percentage[0], percentage[1]);
        }
      } else {
        var cover = this.util.getParentElement(element, 'FIGURE');
        var offsetW = width || element.offsetWidth;
        var offsetH = height || element.offsetHeight;
        var w = (isVertical ? offsetH : offsetW) + 'px';
        var h = (isVertical ? offsetW : offsetH) + 'px';
        this.plugins[this.context.resizing._resize_plugin].cancelPercentAttr.call(this);
        this.plugins[this.context.resizing._resize_plugin].setSize.call(this, offsetW + 'px', offsetH + 'px', true);
        cover.style.width = w;
        cover.style.height = !!this.context[this.context.resizing._resize_plugin]._caption ? '' : h;
        if (isVertical) {
          var transW = offsetW / 2 + 'px ' + offsetW / 2 + 'px 0';
          var transH = offsetH / 2 + 'px ' + offsetH / 2 + 'px 0';
          transOrigin = deg === 90 || deg === -270 ? transH : transW;
        }
      }
      element.style.transformOrigin = transOrigin;
      this.plugins.resizing._setTransForm(element, deg.toString(), element.getAttribute('data-rotateX') || '', element.getAttribute('data-rotateY') || '');
      if (isVertical) element.style.maxWidth = 'none';else element.style.maxWidth = '';
      this.plugins.resizing.setCaptionPosition.call(this, element);
    },
    _setTransForm: function _setTransForm(element, r, x, y) {
      var width = (element.offsetWidth - element.offsetHeight) * (/-/.test(r) ? 1 : -1);
      var translate = '';
      if (/[1-9]/.test(r) && (x || y)) {
        translate = x ? 'Y' : 'X';
        switch (r) {
          case '90':
            translate = x && y ? 'X' : y ? translate : '';
            break;
          case '270':
            width *= -1;
            translate = x && y ? 'Y' : x ? translate : '';
            break;
          case '-90':
            translate = x && y ? 'Y' : x ? translate : '';
            break;
          case '-270':
            width *= -1;
            translate = x && y ? 'X' : y ? translate : '';
            break;
          default:
            translate = '';
        }
      }
      if (r % 180 === 0) {
        element.style.maxWidth = '';
      }
      element.style.transform = 'rotate(' + r + 'deg)' + (x ? ' rotateX(' + x + 'deg)' : '') + (y ? ' rotateY(' + y + 'deg)' : '') + (translate ? ' translate' + translate + '(' + width + 'px)' : '');
    },
    /**
     * @description The position of the caption is set automatically.
     * @param {Element} element Target element (not caption element)
     */
    setCaptionPosition: function setCaptionPosition(element) {
      var figcaption = this.util.getChildElement(this.util.getParentElement(element, 'FIGURE'), 'FIGCAPTION');
      if (figcaption) {
        figcaption.style.marginTop = (this.context.resizing._rotateVertical ? element.offsetWidth - element.offsetHeight : 0) + 'px';
      }
    },
    /**
     * @description Mouse down event of resize handles
     * @param {MouseEvent} e Event object 
     */
    onMouseDown_resize_handle: function onMouseDown_resize_handle(e) {
      e.stopPropagation();
      e.preventDefault();
      var contextResizing = this.context.resizing;
      var direction = contextResizing._resize_direction = e.target.classList[0];
      contextResizing._resizeClientX = e.clientX;
      contextResizing._resizeClientY = e.clientY;
      this.context.element.resizeBackground.style.display = 'block';
      contextResizing.resizeButton.style.display = 'none';
      contextResizing.resizeDiv.style.float = /l/.test(direction) ? 'right' : /r/.test(direction) ? 'left' : 'none';
      var closureFunc_bind = function closureFunc(e) {
        if (e.type === 'keydown' && e.keyCode !== 27) return;
        var change = contextResizing._isChange;
        contextResizing._isChange = false;
        this.removeDocEvent('mousemove', resizing_element_bind);
        this.removeDocEvent('mouseup', closureFunc_bind);
        this.removeDocEvent('keydown', closureFunc_bind);
        if (e.type === 'keydown') {
          this.controllersOff();
          this.context.element.resizeBackground.style.display = 'none';
          this.plugins[this.context.resizing._resize_plugin].init.call(this);
        } else {
          // element resize
          this.plugins.resizing.cancel_controller_resize.call(this, direction);
          // history stack
          if (change) this.history.push(false);
        }
      }.bind(this);
      var resizing_element_bind = this.plugins.resizing.resizing_element.bind(this, contextResizing, direction, this.context[contextResizing._resize_plugin]);
      this.addDocEvent('mousemove', resizing_element_bind);
      this.addDocEvent('mouseup', closureFunc_bind);
      this.addDocEvent('keydown', closureFunc_bind);
    },
    /**
     * @description Mouse move event after call "onMouseDown_resize_handle" of resize handles
     * The size of the module's "div" is adjusted according to the mouse move event.
     * @param {Object} contextResizing "core.context.resizing" object (binding argument)
     * @param {String} direction Direction ("tl", "tr", "bl", "br", "lw", "th", "rw", "bh") (binding argument)
     * @param {Object} plugin "core.context[currentPlugin]" object (binding argument)
     * @param {MouseEvent} e Event object
     */
    resizing_element: function resizing_element(contextResizing, direction, plugin, e) {
      var clientX = e.clientX;
      var clientY = e.clientY;
      var resultW = plugin._element_w;
      var resultH = plugin._element_h;
      var w = plugin._element_w + (/r/.test(direction) ? clientX - contextResizing._resizeClientX : contextResizing._resizeClientX - clientX);
      var h = plugin._element_h + (/b/.test(direction) ? clientY - contextResizing._resizeClientY : contextResizing._resizeClientY - clientY);
      var wh = plugin._element_h / plugin._element_w * w;
      if (/t/.test(direction)) contextResizing.resizeDiv.style.top = plugin._element_h - (/h/.test(direction) ? h : wh) + 'px';
      if (/l/.test(direction)) contextResizing.resizeDiv.style.left = plugin._element_w - w + 'px';
      if (/r|l/.test(direction)) {
        contextResizing.resizeDiv.style.width = w + 'px';
        resultW = w;
      }
      if (/^(t|b)[^h]$/.test(direction)) {
        contextResizing.resizeDiv.style.height = wh + 'px';
        resultH = wh;
      } else if (/^(t|b)h$/.test(direction)) {
        contextResizing.resizeDiv.style.height = h + 'px';
        resultH = h;
      }
      contextResizing._resize_w = resultW;
      contextResizing._resize_h = resultH;
      this.util.changeTxt(contextResizing.resizeDisplay, this._w.Math.round(resultW) + ' x ' + this._w.Math.round(resultH));
      contextResizing._isChange = true;
    },
    /**
     * @description Resize the element to the size of the "div" adjusted in the "resizing_element" method.
     * Called at the mouse-up event registered in "onMouseDown_resize_handle".
     * @param {String} direction Direction ("tl", "tr", "bl", "br", "lw", "th", "rw", "bh")
     */
    cancel_controller_resize: function cancel_controller_resize(direction) {
      var isVertical = this.context.resizing._rotateVertical;
      this.controllersOff();
      this.context.element.resizeBackground.style.display = 'none';
      var w = this._w.Math.round(isVertical ? this.context.resizing._resize_h : this.context.resizing._resize_w);
      var h = this._w.Math.round(isVertical ? this.context.resizing._resize_w : this.context.resizing._resize_h);
      if (!isVertical && !/%$/.test(w)) {
        var padding = 16;
        var limit = this.context.element.wysiwygFrame.clientWidth - padding * 2 - 2;
        if (this.util.getNumber(w, 0) > limit) {
          h = this._w.Math.round(h / w * limit);
          w = limit;
        }
      }
      var pluginName = this.context.resizing._resize_plugin;
      this.plugins[pluginName].setSize.call(this, w, h, false, direction);
      if (isVertical) this.plugins.resizing.setTransformSize.call(this, this.context[this.context.resizing._resize_plugin]._element, w, h);
      this.selectComponent(this.context[pluginName]._element, pluginName);
    }
  };
  if (typeof noGlobal === typeof undefined) {
    if (!window.SUNEDITOR_MODULES) {
      Object.defineProperty(window, 'SUNEDITOR_MODULES', {
        enumerable: true,
        writable: false,
        configurable: false,
        value: {}
      });
    }
    Object.defineProperty(window.SUNEDITOR_MODULES, 'resizing', {
      enumerable: true,
      writable: false,
      configurable: false,
      value: resizing
    });
  }
  return resizing;
});

/***/ }),

/***/ 2066:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buttonList = void 0;
var SunEditor_1 = __importDefault(__webpack_require__(2067));
exports.buttonList = __importStar(__webpack_require__(2072));
exports.default = SunEditor_1.default;

/***/ }),

/***/ 2067:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var __assign = this && this.__assign || function () {
  __assign = Object.assign || function (t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = {
      enumerable: true,
      get: function get() {
        return m[k];
      }
    };
  }
  Object.defineProperty(o, k2, desc);
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});
var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  __setModuleDefault(result, mod);
  return result;
};
var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};
Object.defineProperty(exports, "__esModule", {
  value: true
});
var react_1 = __importStar(__webpack_require__(4));
var getLanguage_1 = __importDefault(__webpack_require__(2068));
var plugins_1 = __importDefault(__webpack_require__(708));
var suneditor_1 = __importDefault(__webpack_require__(2114));
var SunEditor = function SunEditor(props) {
  var name = props.name,
    lang = props.lang,
    _a = props.setOptions,
    setOptions = _a === void 0 ? {} : _a,
    placeholder = props.placeholder,
    _b = props.width,
    width = _b === void 0 ? "100%" : _b,
    height = props.height,
    defaultValue = props.defaultValue,
    setContents = props.setContents,
    onSave = props.onSave,
    onSetToolbarButtons = props.onSetToolbarButtons,
    setDefaultStyle = props.setDefaultStyle,
    onResizeEditor = props.onResizeEditor,
    getSunEditorInstance = props.getSunEditorInstance,
    appendContents = props.appendContents,
    _c = props.setAllPlugins,
    setAllPlugins = _c === void 0 ? true : _c,
    _d = props.disable,
    disable = _d === void 0 ? false : _d,
    _e = props.readOnly,
    readOnly = _e === void 0 ? false : _e,
    _f = props.hide,
    hide = _f === void 0 ? false : _f,
    _g = props.hideToolbar,
    hideToolbar = _g === void 0 ? false : _g,
    _h = props.disableToolbar,
    disableToolbar = _h === void 0 ? false : _h,
    onChange = props.onChange,
    autoFocus = props.autoFocus,
    onBlur = props.onBlur,
    onLoad = props.onLoad,
    toggleCodeView = props.toggleCodeView,
    toggleFullScreen = props.toggleFullScreen,
    showInline = props.showInline,
    showController = props.showController,
    imageUploadHandler = props.imageUploadHandler;
  var txtArea = (0, react_1.useRef)(null);
  var editor = (0, react_1.useRef)();
  var initialEffect = (0, react_1.useRef)(true);
  (0, react_1.useEffect)(function () {
    setOptions.lang = setOptions.lang || (0, getLanguage_1.default)(lang);
    setOptions.width = setOptions.width || width;
    setOptions.placeholder = setOptions.placeholder || placeholder;
    if (!setOptions.plugins && setAllPlugins) setOptions.plugins = plugins_1.default;
    if (height) setOptions.height = height;
    if (name && defaultValue) txtArea.current.value = defaultValue;
    editor.current = suneditor_1.default.create(txtArea.current, __assign({
      value: defaultValue
    }, setOptions));
    if (getSunEditorInstance) getSunEditorInstance(editor.current);
    editor.current.onChange = function (content) {
      if (name && txtArea.current) txtArea.current.value = content;
      if (onChange) onChange(content);
    };
    if (onBlur) editor.current.onBlur = function (e) {
      return editor.current && onBlur(e, editor.current.getContents(true));
    };
    if (onSave) editor.current.onSave = function (content) {
      return onSave(content);
    };
    if (onSetToolbarButtons) editor.current.onSetToolbarButtons = function (buttonList) {
      return onSetToolbarButtons(buttonList);
    };
    if (onResizeEditor) editor.current.onResizeEditor = function (height, prevHeight) {
      return onResizeEditor(height, prevHeight);
    };
    var fromClipBoardEvents = ["onCopy", "onCut"];
    var toClipBoardEvents = ["onDrop", "onPaste"];
    var singleEvents = ["onMouseDown", "onScroll", "onInput", "onClick", "onKeyUp", "onKeyDown", "onFocus"];
    var uploadBeforeEvents = ["onImageUploadBefore", "onVideoUploadBefore", "onAudioUploadBefore"];
    var uploadEvents = ["onImageUpload", "onImageUpload", "onAudioUpload", "onVideoUpload"];
    var uploadErrorEvents = ["onImageUploadError", "onVideoUploadError", "onAudioUploadError"];
    fromClipBoardEvents.forEach(function (event) {
      var value = props[event];
      if (editor.current && event && value) editor.current[event] = function (e, clipboardData) {
        return value(e, clipboardData);
      };
    });
    singleEvents.forEach(function (event) {
      var value = props[event];
      if (editor.current && event && value) editor.current[event] = function (e) {
        return value(e);
      };
    });
    uploadBeforeEvents.forEach(function (event) {
      var value = props[event];
      if (editor.current && event && value) editor.current[event] = function (files, info, _, uploadHandler) {
        return value(files, info, uploadHandler);
      };
    });
    uploadEvents.forEach(function (event) {
      var value = props[event];
      if (editor.current && event && value) editor.current[event] = function (targetElement, index, state, info, remainingFilesCount) {
        return value(targetElement, index, state, info, remainingFilesCount);
      };
    });
    uploadErrorEvents.forEach(function (event) {
      var value = props[event];
      if (editor.current && event && value) editor.current[event] = function (errorMessage, result) {
        return value(errorMessage, result);
      };
    });
    toClipBoardEvents.forEach(function (event) {
      var value = props[event];
      if (editor.current && event && value) editor.current[event] = function (e, cleanData, maxCharCount) {
        return value(e, cleanData, maxCharCount);
      };
    });
    editor.current.onload = function (_, reload) {
      if (reload === false) {
        if (setContents) {
          editor.current.setContents(setContents);
          editor.current.core.focusEdge(null);
        }
        if (setDefaultStyle) editor.current.setDefaultStyle(setDefaultStyle);
        if (appendContents) editor.current.appendContents(appendContents);
        if (editor.current.util.isIE) editor.current.core._createDefaultRange();
        if (disable === true) editor.current.disable();
        if (readOnly === true) editor.current.readOnly(true);
        if (hide === true) editor.current.hide();
        if (hideToolbar === true) editor.current.toolbar.hide();
        if (disableToolbar === true) editor.current.toolbar.disable();
        if (autoFocus === false) editor.current.core.context.element.wysiwyg.blur();else if (autoFocus === true) editor.current.core.context.element.wysiwyg.focus();
      }
      if (onLoad) onLoad(reload);
    };
    if (imageUploadHandler && typeof imageUploadHandler === "function") editor.current.imageUploadHandler = imageUploadHandler;
    if (toggleCodeView && typeof toggleCodeView === "function") editor.current.toggleCodeView = function (isCodeView) {
      return toggleCodeView(isCodeView);
    };
    if (toggleFullScreen && typeof toggleFullScreen === "function") editor.current.toggleFullScreen = function (isFullScreen) {
      return toggleFullScreen(isFullScreen);
    };
    if (showInline && typeof showInline === "function") editor.current.showInline = function (toolbar, context) {
      return showInline(toolbar, context);
    };
    if (showController && typeof showController === "function") editor.current.showController = function (name, controllers) {
      return showController(name, controllers);
    };
    return function () {
      if (editor.current) editor.current.destroy();
    };
  }, []);
  (0, react_1.useEffect)(function () {
    var _a;
    if (!initialEffect.current) {
      (_a = editor.current) === null || _a === void 0 ? void 0 : _a.setOptions({
        lang: (0, getLanguage_1.default)(lang),
        placeholder: placeholder,
        height: height,
        width: width
      });
    }
  }, [lang, placeholder, height, width]);
  (0, react_1.useEffect)(function () {
    var _a;
    if (setDefaultStyle && !initialEffect.current) (_a = editor.current) === null || _a === void 0 ? void 0 : _a.setDefaultStyle(setDefaultStyle);
  }, [setDefaultStyle]);
  (0, react_1.useEffect)(function () {
    var _a, _b;
    if (!initialEffect.current) {
      if (setContents !== undefined) !((_a = editor.current) === null || _a === void 0 ? void 0 : _a.core.hasFocus) && ((_b = editor.current) === null || _b === void 0 ? void 0 : _b.setContents(setContents));
    }
  }, [setContents]);
  (0, react_1.useEffect)(function () {
    var _a, _b;
    if (!initialEffect.current) {
      if (appendContents !== undefined) (_a = editor.current) === null || _a === void 0 ? void 0 : _a.appendContents(appendContents);
      (_b = editor.current) === null || _b === void 0 ? void 0 : _b.core.focusEdge(null);
    }
  }, [appendContents]);
  (0, react_1.useEffect)(function () {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    if (!initialEffect.current) {
      if (hideToolbar === true) (_a = editor.current) === null || _a === void 0 ? void 0 : _a.toolbar.hide();else (_b = editor.current) === null || _b === void 0 ? void 0 : _b.toolbar.show();
      if (disableToolbar === true) (_c = editor.current) === null || _c === void 0 ? void 0 : _c.toolbar.disable();else (_d = editor.current) === null || _d === void 0 ? void 0 : _d.toolbar.enable();
      if (disable === true) (_e = editor.current) === null || _e === void 0 ? void 0 : _e.disable();else (_f = editor.current) === null || _f === void 0 ? void 0 : _f.enable();
      if (readOnly === true) (_g = editor.current) === null || _g === void 0 ? void 0 : _g.readOnly(true);else (_h = editor.current) === null || _h === void 0 ? void 0 : _h.readOnly(false);
      if (hide === true) (_j = editor.current) === null || _j === void 0 ? void 0 : _j.hide();else (_k = editor.current) === null || _k === void 0 ? void 0 : _k.show();
    }
  }, [disable, hideToolbar, disableToolbar, hide, readOnly]);
  (0, react_1.useEffect)(function () {
    initialEffect.current = false;
  }, []);
  return react_1.default.createElement("textarea", __assign({
    style: {
      visibility: "hidden"
    },
    ref: txtArea
  }, {
    name: name
  }));
};
exports.default = SunEditor;

/***/ }),

/***/ 2068:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
var getLanguage = function getLanguage(lang) {
  switch (typeof lang) {
    case "object":
      return lang;
    case "string":
      return __webpack_require__(2069)("./".concat(lang, ".js"));
    default:
      return undefined;
  }
};
exports.default = getLanguage;

/***/ }),

/***/ 2070:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ckb__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1009);
/* harmony import */ var _ckb__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_ckb__WEBPACK_IMPORTED_MODULE_0__);
/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, "ckb", function() { return _ckb__WEBPACK_IMPORTED_MODULE_0___default.a; });
/* harmony import */ var _da__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1010);
/* harmony import */ var _da__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_da__WEBPACK_IMPORTED_MODULE_1__);
/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, "da", function() { return _da__WEBPACK_IMPORTED_MODULE_1___default.a; });
/* harmony import */ var _de__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(1011);
/* harmony import */ var _de__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_de__WEBPACK_IMPORTED_MODULE_2__);
/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, "de", function() { return _de__WEBPACK_IMPORTED_MODULE_2___default.a; });
/* harmony import */ var _en__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(707);
/* harmony import */ var _en__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_en__WEBPACK_IMPORTED_MODULE_3__);
/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, "en", function() { return _en__WEBPACK_IMPORTED_MODULE_3___default.a; });
/* harmony import */ var _es__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(1012);
/* harmony import */ var _es__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_es__WEBPACK_IMPORTED_MODULE_4__);
/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, "es", function() { return _es__WEBPACK_IMPORTED_MODULE_4___default.a; });
/* harmony import */ var _fr__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(1013);
/* harmony import */ var _fr__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_fr__WEBPACK_IMPORTED_MODULE_5__);
/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, "fr", function() { return _fr__WEBPACK_IMPORTED_MODULE_5___default.a; });
/* harmony import */ var _he__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(1014);
/* harmony import */ var _he__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_he__WEBPACK_IMPORTED_MODULE_6__);
/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, "he", function() { return _he__WEBPACK_IMPORTED_MODULE_6___default.a; });
/* harmony import */ var _it__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(1015);
/* harmony import */ var _it__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(_it__WEBPACK_IMPORTED_MODULE_7__);
/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, "it", function() { return _it__WEBPACK_IMPORTED_MODULE_7___default.a; });
/* harmony import */ var _ja__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(1016);
/* harmony import */ var _ja__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(_ja__WEBPACK_IMPORTED_MODULE_8__);
/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, "ja", function() { return _ja__WEBPACK_IMPORTED_MODULE_8___default.a; });
/* harmony import */ var _ko__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(1017);
/* harmony import */ var _ko__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(_ko__WEBPACK_IMPORTED_MODULE_9__);
/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, "ko", function() { return _ko__WEBPACK_IMPORTED_MODULE_9___default.a; });
/* harmony import */ var _lv__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(1018);
/* harmony import */ var _lv__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_lv__WEBPACK_IMPORTED_MODULE_10__);
/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, "lv", function() { return _lv__WEBPACK_IMPORTED_MODULE_10___default.a; });
/* harmony import */ var _nl__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(1019);
/* harmony import */ var _nl__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(_nl__WEBPACK_IMPORTED_MODULE_11__);
/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, "nl", function() { return _nl__WEBPACK_IMPORTED_MODULE_11___default.a; });
/* harmony import */ var _pl__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(1020);
/* harmony import */ var _pl__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(_pl__WEBPACK_IMPORTED_MODULE_12__);
/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, "pl", function() { return _pl__WEBPACK_IMPORTED_MODULE_12___default.a; });
/* harmony import */ var _pt_br__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(1021);
/* harmony import */ var _pt_br__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(_pt_br__WEBPACK_IMPORTED_MODULE_13__);
/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, "pt_br", function() { return _pt_br__WEBPACK_IMPORTED_MODULE_13___default.a; });
/* harmony import */ var _ro__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(1022);
/* harmony import */ var _ro__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(_ro__WEBPACK_IMPORTED_MODULE_14__);
/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, "ro", function() { return _ro__WEBPACK_IMPORTED_MODULE_14___default.a; });
/* harmony import */ var _ru__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(1023);
/* harmony import */ var _ru__WEBPACK_IMPORTED_MODULE_15___default = /*#__PURE__*/__webpack_require__.n(_ru__WEBPACK_IMPORTED_MODULE_15__);
/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, "ru", function() { return _ru__WEBPACK_IMPORTED_MODULE_15___default.a; });
/* harmony import */ var _se__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(1024);
/* harmony import */ var _se__WEBPACK_IMPORTED_MODULE_16___default = /*#__PURE__*/__webpack_require__.n(_se__WEBPACK_IMPORTED_MODULE_16__);
/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, "se", function() { return _se__WEBPACK_IMPORTED_MODULE_16___default.a; });
/* harmony import */ var _ua__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(1025);
/* harmony import */ var _ua__WEBPACK_IMPORTED_MODULE_17___default = /*#__PURE__*/__webpack_require__.n(_ua__WEBPACK_IMPORTED_MODULE_17__);
/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, "ua", function() { return _ua__WEBPACK_IMPORTED_MODULE_17___default.a; });
/* harmony import */ var _zh_cn__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(1026);
/* harmony import */ var _zh_cn__WEBPACK_IMPORTED_MODULE_18___default = /*#__PURE__*/__webpack_require__.n(_zh_cn__WEBPACK_IMPORTED_MODULE_18__);
/* harmony reexport (default from non-harmony) */ __webpack_require__.d(__webpack_exports__, "zh_cn", function() { return _zh_cn__WEBPACK_IMPORTED_MODULE_18___default.a; });






















/* harmony default export */ __webpack_exports__["default"] = ({
  ckb: _ckb__WEBPACK_IMPORTED_MODULE_0___default.a,
  da: _da__WEBPACK_IMPORTED_MODULE_1___default.a,
  de: _de__WEBPACK_IMPORTED_MODULE_2___default.a,
  en: _en__WEBPACK_IMPORTED_MODULE_3___default.a,
  es: _es__WEBPACK_IMPORTED_MODULE_4___default.a,
  fr: _fr__WEBPACK_IMPORTED_MODULE_5___default.a,
  he: _he__WEBPACK_IMPORTED_MODULE_6___default.a,
  it: _it__WEBPACK_IMPORTED_MODULE_7___default.a,
  ja: _ja__WEBPACK_IMPORTED_MODULE_8___default.a,
  ko: _ko__WEBPACK_IMPORTED_MODULE_9___default.a,
  lv: _lv__WEBPACK_IMPORTED_MODULE_10___default.a,
  nl: _nl__WEBPACK_IMPORTED_MODULE_11___default.a,
  pl: _pl__WEBPACK_IMPORTED_MODULE_12___default.a,
  pt_br: _pt_br__WEBPACK_IMPORTED_MODULE_13___default.a,
  ro: _ro__WEBPACK_IMPORTED_MODULE_14___default.a,
  ru: _ru__WEBPACK_IMPORTED_MODULE_15___default.a,
  se: _se__WEBPACK_IMPORTED_MODULE_16___default.a,
  ua: _ua__WEBPACK_IMPORTED_MODULE_17___default.a,
  zh_cn: _zh_cn__WEBPACK_IMPORTED_MODULE_18___default.a
});

/***/ }),

/***/ 2071:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2017 JiHong Lee.
 * MIT license.
 */


(function (global, factory) {
  if ( true && typeof module.exports === 'object') {
    module.exports = global.document ? factory(global, true) : function (w) {
      if (!w.document) {
        throw new Error('SUNEDITOR_MODULES a window with a document');
      }
      return factory(w);
    };
  } else {
    factory(global);
  }
})(typeof window !== 'undefined' ? window : this, function (window, noGlobal) {
  var fileBrowser = {
    name: 'fileBrowser',
    _xmlHttp: null,
    _loading: null,
    /**
     * @description Constructor
     * @param {Object} core Core object 
     */
    add: function add(core) {
      var context = core.context;
      context.fileBrowser = {
        _closeSignal: false,
        area: null,
        header: null,
        tagArea: null,
        body: null,
        list: null,
        tagElements: null,
        items: [],
        selectedTags: [],
        selectorHandler: null,
        contextPlugin: '',
        columnSize: 4
      };

      /** fileBrowser */
      var browser_div = core.util.createElement('DIV');
      browser_div.className = 'se-file-browser sun-editor-common';
      var back = core.util.createElement('DIV');
      back.className = 'se-file-browser-back';
      var content = core.util.createElement('DIV');
      content.className = 'se-file-browser-inner';
      content.innerHTML = this.set_browser(core);
      browser_div.appendChild(back);
      browser_div.appendChild(content);
      this._loading = browser_div.querySelector('.se-loading-box');
      context.fileBrowser.area = browser_div;
      context.fileBrowser.header = content.querySelector('.se-file-browser-header');
      context.fileBrowser.titleArea = content.querySelector('.se-file-browser-title');
      context.fileBrowser.tagArea = content.querySelector('.se-file-browser-tags');
      context.fileBrowser.body = content.querySelector('.se-file-browser-body');
      context.fileBrowser.list = content.querySelector('.se-file-browser-list');

      /** add event listeners */
      context.fileBrowser.tagArea.addEventListener('click', this.onClickTag.bind(core));
      context.fileBrowser.list.addEventListener('click', this.onClickFile.bind(core));
      content.addEventListener('mousedown', this._onMouseDown_browser.bind(core));
      content.addEventListener('click', this._onClick_browser.bind(core));

      /** append html */
      context.element.relative.appendChild(browser_div);

      /** empty memory */
      browser_div = null, back = null, content = null;
    },
    set_browser: function set_browser(core) {
      var lang = core.lang;
      return '<div class="se-file-browser-content">' + '<div class="se-file-browser-header">' + '<button type="button" data-command="close" class="se-btn se-file-browser-close" class="close" title="' + lang.dialogBox.close + '" aria-label="' + lang.dialogBox.close + '">' + core.icons.cancel + '</button>' + '<span class="se-file-browser-title"></span>' + '<div class="se-file-browser-tags"></div>' + '</div>' + '<div class="se-file-browser-body">' + '<div class="se-loading-box sun-editor-common"><div class="se-loading-effect"></div></div>' + '<div class="se-file-browser-list"></div>' + '</div>' + '</div>';
    },
    /**
     * @description Event to control the behavior of closing the browser
     * @param {MouseEvent} e Event object
     * @private
     */
    _onMouseDown_browser: function _onMouseDown_browser(e) {
      if (/se-file-browser-inner/.test(e.target.className)) {
        this.context.fileBrowser._closeSignal = true;
      } else {
        this.context.fileBrowser._closeSignal = false;
      }
    },
    /**
     * @description Event to close the window when the outside area of the browser or close button is click
     * @param {MouseEvent} e Event object
     * @private
     */
    _onClick_browser: function _onClick_browser(e) {
      e.stopPropagation();
      if (/close/.test(e.target.getAttribute('data-command')) || this.context.fileBrowser._closeSignal) {
        this.plugins.fileBrowser.close.call(this);
      }
    },
    /**
     * @description Open a file browser plugin
     * @param {String} pluginName Plugin name using the file browser
     * @param {Function|null} selectorHandler When the function comes as an argument value, it substitutes "context.selectorHandler".
     */
    open: function open(pluginName, selectorHandler) {
      if (this.plugins.fileBrowser._bindClose) {
        this._d.removeEventListener('keydown', this.plugins.fileBrowser._bindClose);
        this.plugins.fileBrowser._bindClose = null;
      }
      this.plugins.fileBrowser._bindClose = function (e) {
        if (!/27/.test(e.keyCode)) return;
        this.plugins.fileBrowser.close.call(this);
      }.bind(this);
      this._d.addEventListener('keydown', this.plugins.fileBrowser._bindClose);
      var fileBrowserContext = this.context.fileBrowser;
      fileBrowserContext.contextPlugin = pluginName;
      fileBrowserContext.selectorHandler = selectorHandler;
      var pluginContext = this.context[pluginName];
      var listClassName = pluginContext.listClass;
      if (!this.util.hasClass(fileBrowserContext.list, listClassName)) {
        fileBrowserContext.list.className = 'se-file-browser-list ' + listClassName;
      }
      if (this.options.popupDisplay === 'full') {
        fileBrowserContext.area.style.position = 'fixed';
      } else {
        fileBrowserContext.area.style.position = 'absolute';
      }
      fileBrowserContext.titleArea.textContent = pluginContext.title;
      fileBrowserContext.area.style.display = 'block';
      this.plugins.fileBrowser._drawFileList.call(this, this.context[pluginName].url, this.context[pluginName].header);
    },
    _bindClose: null,
    /**
     * @description Close a fileBrowser plugin
     * The plugin's "init" method is called.
     */
    close: function close() {
      var fileBrowserPlugin = this.plugins.fileBrowser;
      if (fileBrowserPlugin._xmlHttp) {
        fileBrowserPlugin._xmlHttp.abort();
      }
      if (fileBrowserPlugin._bindClose) {
        this._d.removeEventListener('keydown', fileBrowserPlugin._bindClose);
        fileBrowserPlugin._bindClose = null;
      }
      var fileBrowserContext = this.context.fileBrowser;
      fileBrowserContext.area.style.display = 'none';
      fileBrowserContext.selectorHandler = null;
      fileBrowserContext.selectedTags = [];
      fileBrowserContext.items = [];
      fileBrowserContext.list.innerHTML = fileBrowserContext.tagArea.innerHTML = fileBrowserContext.titleArea.textContent = '';
      if (typeof this.plugins[fileBrowserContext.contextPlugin].init === 'function') this.plugins[fileBrowserContext.contextPlugin].init.call(this);
      fileBrowserContext.contextPlugin = '';
    },
    /**
     * @description Show file browser loading box
     */
    showBrowserLoading: function showBrowserLoading() {
      this._loading.style.display = 'block';
    },
    /**
     * @description Close file browser loading box
     */
    closeBrowserLoading: function closeBrowserLoading() {
      this._loading.style.display = 'none';
    },
    _drawFileList: function _drawFileList(url, browserHeader) {
      var fileBrowserPlugin = this.plugins.fileBrowser;
      var xmlHttp = fileBrowserPlugin._xmlHttp = this.util.getXMLHttpRequest();
      xmlHttp.onreadystatechange = fileBrowserPlugin._callBackGet.bind(this, xmlHttp);
      xmlHttp.open('get', url, true);
      if (browserHeader !== null && typeof browserHeader === 'object' && this._w.Object.keys(browserHeader).length > 0) {
        for (var key in browserHeader) {
          xmlHttp.setRequestHeader(key, browserHeader[key]);
        }
      }
      xmlHttp.send(null);
      this.plugins.fileBrowser.showBrowserLoading();
    },
    _callBackGet: function _callBackGet(xmlHttp) {
      if (xmlHttp.readyState === 4) {
        this.plugins.fileBrowser._xmlHttp = null;
        if (xmlHttp.status === 200) {
          try {
            var res = JSON.parse(xmlHttp.responseText);
            if (res.result.length > 0) {
              this.plugins.fileBrowser._drawListItem.call(this, res.result, true);
            } else if (res.nullMessage) {
              this.context.fileBrowser.list.innerHTML = res.nullMessage;
            }
          } catch (e) {
            throw Error('[SUNEDITOR.fileBrowser.drawList.fail] cause : "' + e.message + '"');
          } finally {
            this.plugins.fileBrowser.closeBrowserLoading();
            this.context.fileBrowser.body.style.maxHeight = this._w.innerHeight - this.context.fileBrowser.header.offsetHeight - 50 + 'px';
          }
        } else {
          // exception
          this.plugins.fileBrowser.closeBrowserLoading();
          if (xmlHttp.status !== 0) {
            var _res = !xmlHttp.responseText ? xmlHttp : JSON.parse(xmlHttp.responseText);
            var err = '[SUNEDITOR.fileBrowser.get.serverException] status: ' + xmlHttp.status + ', response: ' + (_res.errorMessage || xmlHttp.responseText);
            throw Error(err);
          }
        }
      }
    },
    _drawListItem: function _drawListItem(items, update) {
      var fileBrowserContext = this.context.fileBrowser;
      var pluginContext = this.context[fileBrowserContext.contextPlugin];
      var _tags = [];
      var len = items.length;
      var columnSize = pluginContext.columnSize || fileBrowserContext.columnSize;
      var splitSize = columnSize <= 1 ? 1 : Math.round(len / columnSize) || 1;
      var drawItemHandler = pluginContext.itemTemplateHandler;
      var tagsHTML = '';
      var listHTML = '<div class="se-file-item-column">';
      var columns = 1;
      for (var i = 0, item, tags; i < len; i++) {
        item = items[i];
        tags = !item.tag ? [] : typeof item.tag === 'string' ? item.tag.split(',') : item.tag;
        tags = item.tag = tags.map(function (v) {
          return v.trim();
        });
        listHTML += drawItemHandler(item);
        if ((i + 1) % splitSize === 0 && columns < columnSize && i + 1 < len) {
          columns++;
          listHTML += '</div><div class="se-file-item-column">';
        }
        if (update && tags.length > 0) {
          for (var t = 0, tLen = tags.length, tag; t < tLen; t++) {
            tag = tags[t];
            if (tag && _tags.indexOf(tag) === -1) {
              _tags.push(tag);
              tagsHTML += '<a title="' + tag + '" aria-label="' + tag + '">' + tag + '</a>';
            }
          }
        }
      }
      listHTML += '</div>';
      fileBrowserContext.list.innerHTML = listHTML;
      if (update) {
        fileBrowserContext.items = items;
        fileBrowserContext.tagArea.innerHTML = tagsHTML;
        fileBrowserContext.tagElements = fileBrowserContext.tagArea.querySelectorAll('A');
      }
    },
    onClickTag: function onClickTag(e) {
      var target = e.target;
      if (!this.util.isAnchor(target)) return;
      var tagName = target.textContent;
      var fileBrowserPlugin = this.plugins.fileBrowser;
      var fileBrowserContext = this.context.fileBrowser;
      var selectTag = fileBrowserContext.tagArea.querySelector('a[title="' + tagName + '"]');
      var selectedTags = fileBrowserContext.selectedTags;
      var sTagIndex = selectedTags.indexOf(tagName);
      if (sTagIndex > -1) {
        selectedTags.splice(sTagIndex, 1);
        this.util.removeClass(selectTag, 'on');
      } else {
        selectedTags.push(tagName);
        this.util.addClass(selectTag, 'on');
      }
      fileBrowserPlugin._drawListItem.call(this, selectedTags.length === 0 ? fileBrowserContext.items : fileBrowserContext.items.filter(function (item) {
        return item.tag.some(function (tag) {
          return selectedTags.indexOf(tag) > -1;
        });
      }), false);
    },
    onClickFile: function onClickFile(e) {
      e.preventDefault();
      e.stopPropagation();
      var fileBrowserContext = this.context.fileBrowser;
      var listEl = fileBrowserContext.list;
      var target = e.target;
      var command = null;
      if (target === listEl) return;
      while (listEl !== target.parentNode) {
        command = target.getAttribute('data-command');
        if (command) break;
        target = target.parentNode;
      }
      if (!command) return;
      var handler = fileBrowserContext.selectorHandler || this.context[fileBrowserContext.contextPlugin].selectorHandler;
      this.plugins.fileBrowser.close.call(this);
      handler(target);
    }
  };
  if (typeof noGlobal === typeof undefined) {
    if (!window.SUNEDITOR_MODULES) {
      Object.defineProperty(window, 'SUNEDITOR_MODULES', {
        enumerable: true,
        writable: false,
        configurable: false,
        value: {}
      });
    }
    Object.defineProperty(window.SUNEDITOR_MODULES, 'fileBrowser', {
      enumerable: true,
      writable: false,
      configurable: false,
      value: fileBrowser
    });
  }
  return fileBrowser;
});

/***/ }),

/***/ 2072:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.formatting = exports.complex = exports.basic = void 0;
exports.basic = [["font", "fontSize"], ["fontColor"], ["horizontalRule"], ["link", "image"]];
exports.complex = [["undo", "redo"], ["font", "fontSize", "formatBlock"], ["bold", "underline", "italic", "strike", "subscript", "superscript"], ["removeFormat"], "/", ["fontColor", "hiliteColor"], ["outdent", "indent"], ["align", "horizontalRule", "list", "table"], ["link", "image", "video"], ["fullScreen", "showBlocks", "codeView"], ["preview", "print"], ["save", "template"]];
exports.formatting = [["undo", "redo"], ["bold", "underline", "italic", "strike", "subscript", "superscript"], ["removeFormat"], ["outdent", "indent"], ["fullScreen", "showBlocks", "codeView"], ["preview", "print"]];

/***/ }),

/***/ 2073:
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ 2114:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// CONCATENATED MODULE: ./node_modules/suneditor/src/assets/defaultIcons.js
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2020 JiHong Lee.
 * MIT license.
 */


/* harmony default export */ var defaultIcons = ({
  // rtl icon
  rtl: {
    italic: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 10.5 15.8" xml:space="preserve"><g><path d="M0.3,0.1c0.3,0,0.5,0,0.7,0c1,0.1,1.7,0.1,2.2,0.1H4L7.2,0l0.2,1.1H7c-0.5,0-1,0.1-1.5,0.3v0.4l0.3,1.9L6,4.4L6.3,6 l0.1,0.4l0.1,0.5c0.1,0.2,0.1,0.4,0.2,0.7s0.1,0.6,0.2,0.9L7,9.1l0.6,2.8l0.3,1.4c0.1,0.4,0.2,0.7,0.4,1c0.4,0.2,0.8,0.3,1.2,0.4 l0.8,0.2l0.2,0.9l-1.1,0c-0.9-0.1-1.5-0.1-1.8-0.1h-2c-0.9,0.1-1.4,0.2-1.5,0.2c-0.1,0-0.2,0-0.3,0H3.4c-0.1,0-0.2,0-0.2,0 l-0.1-0.4c0-0.2-0.1-0.4-0.1-0.6l0.7-0.1c0.4,0,0.8-0.1,1.2-0.2c0-0.1,0-0.2,0-0.3l-0.1-0.5l-0.4-2.4L4,9.6L3.4,6.4 C3.2,5.7,3,4.7,2.7,3.3c0-0.3-0.1-0.5-0.1-0.8C2.5,2.1,2.4,1.9,2.3,1.6C2,1.4,1.6,1.3,1.3,1.2C0.9,1.2,0.5,1.1,0.2,0.9L0,0.4L0,0 L0.3,0.1L0.3,0.1z"/></g></svg>',
    indent: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.7 12.4" xml:space="preserve"><g><g><path d="M15.5,10.1L15.5,10.1c0.1,0,0.3,0.1,0.3,0.3v1.7c0,0.1,0,0.1-0.1,0.2c-0.1,0.1-0.1,0.1-0.2,0.1l-15.2,0 c-0.1,0-0.1,0-0.2-0.1C0,12.2,0,12.2,0,12.1l0-1.7c0-0.1,0-0.1,0.1-0.2c0.1-0.1,0.1-0.1,0.2-0.1C0.3,10.1,15.5,10.1,15.5,10.1z M9.8,6.7c0.1,0,0.1,0,0.2,0.1C10.1,6.9,10.1,7,10.1,7v1.7c0,0.1,0,0.2-0.1,0.2C10,9,9.9,9,9.8,9L0.3,9C0.2,9,0.1,9,0.1,8.9 C0,8.9,0,8.8,0,8.7V7C0,7,0,6.9,0.1,6.8c0.1-0.1,0.1-0.1,0.2-0.1C0.3,6.7,9.8,6.7,9.8,6.7z M0.3,3.4h9.6h0c0.1,0,0.3,0.1,0.3,0.3 v1.7v0c0,0.1-0.1,0.3-0.3,0.3H0.3c-0.1,0-0.1,0-0.2-0.1C0,5.5,0,5.4,0,5.3V3.6c0-0.1,0-0.1,0.1-0.2C0.1,3.4,0.2,3.4,0.3,3.4 L0.3,3.4z M0.3,0l15.2,0c0.1,0,0.1,0,0.2,0.1c0.1,0.1,0.1,0.1,0.1,0.2V2c0,0.1,0,0.2-0.1,0.2c-0.1,0.1-0.1,0.1-0.2,0.1H0.3 c-0.1,0-0.1,0-0.2-0.1C0,2.1,0,2,0,2l0-1.7c0-0.1,0-0.1,0.1-0.2C0.1,0,0.2,0,0.3,0z"/></g><path d="M13.1,3.5L15.7,6c0.1,0.1,0.1,0.3,0,0.4l-2.5,2.5C13.1,9,13,9,12.9,9c-0.1,0-0.1,0-0.2-0.1c-0.1-0.1-0.1-0.1-0.1-0.2V3.7 c0-0.1,0-0.2,0.1-0.2c0.1-0.1,0.1-0.1,0.2-0.1C13,3.4,13.1,3.4,13.1,3.5z"/></g></svg>',
    outdent: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.7 12.4" xml:space="preserve"><g><g><path d="M15.5,10.1L15.5,10.1c0.1,0,0.3,0.1,0.3,0.3v1.7c0,0.1,0,0.1-0.1,0.2c-0.1,0.1-0.1,0.1-0.2,0.1l-15.2,0 c-0.1,0-0.1,0-0.2-0.1C0,12.2,0,12.2,0,12.1l0-1.7c0-0.1,0-0.1,0.1-0.2c0.1-0.1,0.1-0.1,0.2-0.1C0.3,10.1,15.5,10.1,15.5,10.1z M9.8,6.7c0.1,0,0.1,0,0.2,0.1C10.1,6.9,10.1,7,10.1,7v1.7c0,0.1,0,0.2-0.1,0.2C10,9,9.9,9,9.8,9L0.3,9C0.2,9,0.1,9,0.1,8.9 C0,8.9,0,8.8,0,8.7V7C0,7,0,6.9,0.1,6.8c0.1-0.1,0.1-0.1,0.2-0.1C0.3,6.7,9.8,6.7,9.8,6.7z M0.3,3.4h9.6h0c0.1,0,0.3,0.1,0.3,0.3 v1.7v0c0,0.1-0.1,0.3-0.3,0.3H0.3c-0.1,0-0.1,0-0.2-0.1C0,5.5,0,5.4,0,5.3V3.6c0-0.1,0-0.1,0.1-0.2C0.1,3.4,0.2,3.4,0.3,3.4 L0.3,3.4z M0.3,0l15.2,0c0.1,0,0.1,0,0.2,0.1c0.1,0.1,0.1,0.1,0.1,0.2V2c0,0.1,0,0.2-0.1,0.2c-0.1,0.1-0.1,0.1-0.2,0.1H0.3 c-0.1,0-0.1,0-0.2-0.1C0,2.1,0,2,0,2l0-1.7c0-0.1,0-0.1,0.1-0.2C0.1,0,0.2,0,0.3,0z"/></g><path d="M15.5,3.4c0.1,0,0.1,0,0.2,0.1c0.1,0.1,0.1,0.1,0.1,0.2v5.1c0,0.1,0,0.1-0.1,0.2C15.6,9,15.5,9,15.5,9 c-0.1,0-0.1,0-0.2-0.1l-2.5-2.5c-0.1-0.1-0.1-0.3,0-0.4l2.5-2.5C15.3,3.4,15.4,3.4,15.5,3.4z"/></g></svg>',
    list_bullets: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.7 12.4" xml:space="preserve"><g><path d="M12.4,10.7c0,0.9,0.8,1.7,1.7,1.7c0.9,0,1.7-0.8,1.7-1.7C15.7,9.8,15,9,14.1,9c-0.4,0-0.9,0.2-1.2,0.5 C12.5,9.8,12.4,10.2,12.4,10.7C12.4,10.7,12.4,10.7,12.4,10.7z M12.4,6.2c0,0.9,0.8,1.7,1.7,1.7c0.4,0,0.9-0.2,1.2-0.5 c0.3-0.3,0.4-0.7,0.4-1.1c0-0.9-0.7-1.7-1.6-1.7C13.1,4.6,12.4,5.3,12.4,6.2C12.4,6.2,12.4,6.2,12.4,6.2z M0,9.8v1.7 c0,0.1,0,0.1,0.1,0.2c0.1,0.1,0.1,0.1,0.2,0.1l10.7,0c0,0,0,0,0,0c0.1,0,0.3-0.1,0.3-0.3V9.8c0-0.1,0-0.1-0.1-0.2 C11.1,9.6,11,9.6,11,9.6l-10.7,0c-0.1,0-0.1,0-0.2,0.1C0,9.7,0,9.8,0,9.8L0,9.8z M12.9,2.9c0.3,0.3,0.7,0.5,1.2,0.5 c0.4,0,0.9-0.2,1.2-0.5c0.7-0.7,0.7-1.7,0-2.4C14.9,0.2,14.5,0,14.1,0c-0.4,0-0.9,0.2-1.2,0.5c-0.3,0.3-0.5,0.7-0.5,1.2 C12.4,2.1,12.5,2.6,12.9,2.9z M0,5.3V7c0,0.1,0,0.1,0.1,0.2c0.1,0.1,0.1,0.1,0.2,0.1H11c0.1,0,0.1,0,0.2-0.1 c0.1-0.1,0.1-0.1,0.1-0.2V5.3c0,0,0,0,0,0c0-0.1-0.1-0.3-0.3-0.3H0.3c-0.1,0-0.1,0-0.2,0.1C0,5.2,0,5.3,0,5.3L0,5.3z M0,0.8v1.7 c0,0.1,0,0.1,0.1,0.2c0.1,0.1,0.1,0.1,0.2,0.1h10.7c0.1,0,0.1,0,0.2-0.1c0,0,0.1-0.1,0.1-0.2V0.8c0-0.1,0-0.1-0.1-0.2 c0-0.1-0.1-0.1-0.2-0.1H0.3c-0.1,0-0.1,0-0.2,0.1C0,0.7,0,0.8,0,0.8L0,0.8z"/></g></svg>',
    list_number: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.7 15.7" xml:space="preserve"><g><path d="M0,11.5l0,1.7c0,0.1,0,0.1,0.1,0.2c0.1,0.1,0.1,0.1,0.2,0.1H11c0.1,0,0.2,0,0.2-0.1c0.1-0.1,0.1-0.1,0.1-0.2v-1.7 c0-0.1,0-0.1-0.1-0.2c-0.1-0.1-0.1-0.1-0.2-0.1H0.3c-0.1,0-0.2,0-0.2,0.1C0,11.4,0,11.4,0,11.5L0,11.5z M0,8.7c0,0.1,0,0.1,0.1,0.2 C0.1,8.9,0.2,9,0.3,9H11c0.1,0,0.2,0,0.2-0.1c0.1-0.1,0.1-0.1,0.1-0.2V7c0-0.1,0-0.1-0.1-0.2c-0.1-0.1-0.1-0.1-0.2-0.1l-10.7,0 c-0.1,0-0.2,0-0.2,0.1C0,6.8,0,6.9,0,7C0,7,0,8.7,0,8.7z M0,2.5v1.7c0,0.1,0,0.1,0.1,0.2c0,0,0.1,0.1,0.2,0.1l10.7,0 c0.1,0,0.2,0,0.2-0.1c0.1-0.1,0.1-0.1,0.1-0.2V2.4c0-0.1,0-0.1-0.1-0.2c-0.1,0-0.1,0-0.2,0H0.3c-0.1,0-0.1,0-0.2,0 C0,2.3,0,2.4,0,2.5L0,2.5z"/></g><path d="M15.6,14.2c0-0.3-0.1-0.6-0.3-0.8c-0.2-0.2-0.4-0.4-0.7-0.4l0.9-1v-0.8h-2.9v1.3h0.9v-0.5h0.9l0,0c-0.1,0.1-0.2,0.2-0.3,0.3 s-0.2,0.3-0.4,0.5l-0.3,0.3l0.2,0.5c0.6,0,0.9,0.1,0.9,0.5c0,0.1-0.1,0.3-0.2,0.4c-0.1,0.1-0.3,0.1-0.4,0.1c-0.3,0-0.7-0.1-0.9-0.3 l-0.5,0.8c0.4,0.4,0.9,0.6,1.5,0.6c0.4,0,0.9-0.1,1.2-0.4C15.5,15.1,15.6,14.7,15.6,14.2z"/><path d="M15.6,8.7h-0.9v0.5h-1.1c0-0.2,0.2-0.4,0.4-0.5c0.2-0.2,0.4-0.3,0.7-0.4c0.3-0.2,0.5-0.3,0.7-0.6c0.2-0.2,0.3-0.5,0.3-0.8 c0-0.4-0.2-0.8-0.5-1c-0.6-0.4-1.4-0.5-2-0.1c-0.3,0.2-0.5,0.4-0.6,0.7L13.3,7c0.1-0.3,0.4-0.5,0.7-0.5c0.1,0,0.3,0,0.3,0.1 c0.1,0.1,0.1,0.2,0.1,0.3c0,0.2-0.1,0.3-0.2,0.4c-0.2,0.1-0.3,0.3-0.5,0.4c-0.2,0.1-0.4,0.3-0.6,0.4c-0.2,0.2-0.4,0.4-0.5,0.6 c-0.1,0.2-0.2,0.5-0.2,0.8c0,0.2,0,0.3,0,0.5h3.2L15.6,8.7L15.6,8.7z"/><path d="M15.6,3.6h-1V0h-0.9l-1.2,1.1l0.6,0.7c0.2-0.1,0.3-0.3,0.4-0.5l0,0v2.2h-0.9v0.9h3L15.6,3.6L15.6,3.6z"/></svg>',
    link: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.7 15.7" xml:space="preserve"><g><path d="M7.4,9.9l3.1,3.1c0.3,0.3,0.8,0.5,1.3,0.5c0.5,0,0.9-0.2,1.3-0.5c0,0,0,0,0,0c0.7-0.7,0.7-1.9,0-2.6L9.9,7.3 c0-0.1,0-0.2,0-0.3C9.9,7,10,7,10.1,7l2.2-0.2c0.1,0,0.1,0,0.2,0.1l2.1,2.1c0.4,0.4,0.7,0.8,0.9,1.3c0.2,0.5,0.3,1,0.3,1.5 c0,0.5-0.1,1-0.3,1.5c-0.8,2-3.2,3-5.2,2.2c-0.5-0.2-0.9-0.5-1.3-0.9l-2.1-2.1c-0.1,0-0.1-0.1-0.1-0.2L7,10.1C7,10,7,9.9,7.1,9.9 C7.2,9.8,7.3,9.9,7.4,9.9z M1.2,1.1C1.6,0.7,2,0.4,2.5,0.3c1-0.4,2.1-0.4,3.1,0C6,0.4,6.5,0.7,6.8,1.1L9,3.2C9,3.3,9.1,3.3,9,3.4 L8.8,5.6c0,0.1-0.1,0.2-0.2,0.2c-0.1,0.1-0.2,0.1-0.3,0L5.3,2.7C5,2.3,4.5,2.1,4,2.1c-0.5,0-0.9,0.2-1.3,0.5c0,0,0,0,0,0 C2,3.4,2,4.5,2.7,5.2l3.1,3.2c0.1,0.1,0.1,0.2,0,0.3c0,0.1-0.1,0.1-0.2,0.1L3.5,9C3.4,9,3.4,9,3.3,8.9L1.2,6.8c0,0,0,0,0,0 C-0.4,5.2-0.4,2.7,1.2,1.1L1.2,1.1z M14.3,6h-2.6c0,0,0,0,0,0c-0.1,0-0.2-0.1-0.2-0.2c0-0.1,0-0.2,0.1-0.3l2.5-0.7 c0.1,0,0.1,0,0.2,0c0.1,0,0.1,0.1,0.1,0.2l0.1,0.8c0,0.1,0,0.1-0.1,0.2C14.5,6,14.4,6,14.3,6L14.3,6z M10.2,4.1 c0,0.1-0.1,0.2-0.2,0.2l0,0c0,0,0,0,0,0C9.8,4.2,9.7,4.1,9.8,4L9.7,1.4c0-0.1,0-0.1,0.1-0.2c0.1,0,0.1,0,0.2,0h0.8 c0.1,0,0.1,0,0.2,0.1c0,0.1,0,0.1,0,0.2L10.2,4.1L10.2,4.1z M1.5,9.7h1.3h1.3c0.1,0,0.2,0.1,0.2,0.2c0,0.1,0,0.2-0.1,0.3l-2.5,0.6 H1.6c0,0-0.1,0-0.1,0c-0.1,0-0.1-0.1-0.1-0.2L1.2,9.9c0-0.1,0-0.1,0.1-0.2c0-0.1,0.1-0.1,0.2-0.1L1.5,9.7z M5.6,11.6 C5.6,11.6,5.6,11.6,5.6,11.6c0-0.1,0.1-0.2,0.3-0.1c0,0,0,0,0,0c0.1,0,0.2,0.1,0.2,0.2v2.6c0,0.1,0,0.1-0.1,0.2 c0,0-0.1,0.1-0.2,0.1L5,14.5c-0.1,0-0.1,0-0.2-0.1c0-0.1,0-0.1,0-0.2L5.6,11.6L5.6,11.6z"/></g></svg>',
    unlink: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.7 15.7" xml:space="preserve"><g><path d="M14.6,14.6c1.6-1.6,1.6-4.1,0-5.7l0,0l-3.1-3.1l-1.2,1.6l2.9,2.9c0.4,0.4,0.6,0.9,0.6,1.5c0,1.1-0.9,2.1-2.1,2.1l0,0 c-0.6,0-1.1-0.2-1.5-0.6l-0.4-0.4l-1.7,1l0.8,0.8C10.4,16.2,13,16.2,14.6,14.6L14.6,14.6L14.6,14.6z M3.6,6C3,5.9,2.6,5.5,2.3,5 S1.9,4,2.1,3.4C2.3,2.9,2.6,2.5,3,2.2C3.5,2,4.1,1.9,4.6,2l3.3,1.4l0.5-2L5.1,0.1C4-0.1,2.9,0,2,0.5C1.1,1.1,0.4,1.9,0.2,3 C-0.1,4,0,5.1,0.6,6C1.1,6.9,1.9,7.6,3,7.8l5.4,2l0.5-2L6.2,6.9L3.6,6z"/></g></svg>'
  },
  // common, ltr icon
  redo: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.59 14.18"><g><path d="M11.58,18.48a6.84,6.84,0,1,1,6.85-6.85s0,.26,0,.67a8,8,0,0,1-.22,1.44l.91-.55a.51.51,0,0,1,.36,0,.45.45,0,0,1,.29.22.47.47,0,0,1,.06.36.45.45,0,0,1-.22.29L17.42,15.3l-.12,0h-.25l-.12-.06-.09-.09-.06-.07,0-.06-.87-2.12a.43.43,0,0,1,0-.37.49.49,0,0,1,.27-.26.41.41,0,0,1,.36,0,.53.53,0,0,1,.27.26l.44,1.09a6.51,6.51,0,0,0,.24-1.36,4.58,4.58,0,0,0,0-.64,5.83,5.83,0,0,0-1.73-4.17,5.88,5.88,0,0,0-8.34,0,5.9,5.9,0,0,0,4.17,10.06.51.51,0,0,1,.33.15.48.48,0,0,1,0,.68.53.53,0,0,1-.33.12Z" transform="translate(-4.48 -4.54)"/></g></svg>',
  undo: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.59 14.18"><g><path d="M5,14a.43.43,0,0,1-.22-.29.46.46,0,0,1,.06-.36.43.43,0,0,1,.29-.22.56.56,0,0,1,.36,0l.91.55a8.27,8.27,0,0,1-.22-1.45,5.07,5.07,0,0,1,0-.67A6.85,6.85,0,1,1,13,18.47a.44.44,0,0,1-.33-.13.48.48,0,0,1,0-.68.51.51,0,0,1,.33-.15A5.89,5.89,0,0,0,17.15,7.45a5.88,5.88,0,0,0-8.33,0,5.84,5.84,0,0,0-1.73,4.17s0,.25,0,.65a6.49,6.49,0,0,0,.24,1.37l.44-1.09a.57.57,0,0,1,.27-.26.41.41,0,0,1,.36,0,.53.53,0,0,1,.27.26.43.43,0,0,1,0,.37L7.82,15l0,.09-.09.09-.1.07-.06,0H7.28l-.13,0-1.09-.63c-.65-.36-1-.57-1.1-.63Z" transform="translate(-4.49 -4.53)"/></g></svg>',
  bold: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 11.76 15.75"><g><path d="M6.4,3.76V19.5h6.76a5.55,5.55,0,0,0,2-.32,4.93,4.93,0,0,0,1.52-1,4.27,4.27,0,0,0,1.48-3.34,3.87,3.87,0,0,0-.69-2.37,5.74,5.74,0,0,0-.71-.83,3.44,3.44,0,0,0-1.1-.65,3.6,3.6,0,0,0,1.58-1.36,3.66,3.66,0,0,0,.53-1.93,3.7,3.7,0,0,0-1.21-2.87,4.65,4.65,0,0,0-3.25-1.1H6.4Zm2.46,6.65V5.57h3.52a4.91,4.91,0,0,1,1.36.15,2.3,2.3,0,0,1,.85.45,2.06,2.06,0,0,1,.74,1.71,2.3,2.3,0,0,1-.78,1.92,2.54,2.54,0,0,1-.86.46,4.7,4.7,0,0,1-1.32.15H8.86Zm0,7.27V12.15H12.7a4.56,4.56,0,0,1,1.38.17,3.43,3.43,0,0,1,.95.49,2.29,2.29,0,0,1,.92,2,2.73,2.73,0,0,1-.83,2.1,2.66,2.66,0,0,1-.83.58,3.25,3.25,0,0,1-1.26.2H8.86Z" transform="translate(-6.4 -3.75)"/></g></svg>',
  underline: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 9.78 15.74"><g><path d="M14.64,3.76h2.52v7.72a4.51,4.51,0,0,1-.59,2.31,3.76,3.76,0,0,1-1.71,1.53,6.12,6.12,0,0,1-2.64.53,5,5,0,0,1-3.57-1.18,4.17,4.17,0,0,1-1.27-3.24V3.76H9.9v7.3a3,3,0,0,0,.55,2,2.3,2.3,0,0,0,1.83.65,2.26,2.26,0,0,0,1.8-.65,3.09,3.09,0,0,0,.55-2V3.76Zm2.52,13.31V19.5H7.39V17.08h9.77Z" transform="translate(-7.38 -3.76)"/></g></svg>',
  italic: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 10.49 15.76"><g><path d="M17.16,3.79l.37,0-.06.38-.14.52A10,10,0,0,1,16.21,5a9.37,9.37,0,0,0-1,.32,6.68,6.68,0,0,0-.25.89c-.06.31-.11.59-.14.85-.3,1.36-.52,2.41-.68,3.14l-.61,3.18L13.1,15l-.43,2.4-.12.46a.62.62,0,0,0,0,.28c.44.1.85.17,1.23.22l.68.11a4.51,4.51,0,0,1-.08.6l-.09.42a.92.92,0,0,0-.23,0l-.43,0a1.37,1.37,0,0,1-.29,0c-.13,0-.63-.08-1.49-.16l-2,0c-.28,0-.87,0-1.78.12L7,19.5l.17-.88.8-.2A6.61,6.61,0,0,0,9.19,18,2.62,2.62,0,0,0,9.61,17l.28-1.41.58-2.75.12-.66c.05-.3.11-.58.17-.86s.12-.51.17-.69l.12-.48.12-.43.31-1.6.15-.65.31-1.91V5.14a3.86,3.86,0,0,0-1.48-.29l-.38,0,.2-1.06,3.24.14.75,0c.45,0,1.18,0,2.18-.09.23,0,.46,0,.71,0Z" transform="translate(-7.04 -3.76)"/></g></svg>',
  strike: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 14.9"><g><path d="M12.94,13a4.27,4.27,0,0,1,1.32.58,1.46,1.46,0,0,1,.55,1.2,1.87,1.87,0,0,1-.88,1.64,4.17,4.17,0,0,1-2.35.59,4.44,4.44,0,0,1-2.74-.71,2.72,2.72,0,0,1-1-2.17H5.57a4.56,4.56,0,0,0,1.55,3.7,7,7,0,0,0,4.47,1.23,6,6,0,0,0,4.07-1.3,4.24,4.24,0,0,0,1.52-3.37,4,4,0,0,0-.26-1.4h-4ZM6.37,10.24A3.27,3.27,0,0,1,6,8.68a4,4,0,0,1,1.48-3.3,5.92,5.92,0,0,1,3.88-1.21,5.58,5.58,0,0,1,3.91,1.24,4.36,4.36,0,0,1,1.45,3.17H14.44a2.12,2.12,0,0,0-.91-1.81,4.45,4.45,0,0,0-2.44-.55,3.69,3.69,0,0,0-2,.51A1.64,1.64,0,0,0,8.3,8.22a1.3,1.3,0,0,0,.48,1.11,7,7,0,0,0,2.1.78l.28.06.28.08H6.37Zm13.09.68a.73.73,0,0,1,.49.21.66.66,0,0,1,.2.48.64.64,0,0,1-.2.48.71.71,0,0,1-.49.19H5.1a.67.67,0,0,1-.49-.19.66.66,0,0,1-.2-.48.64.64,0,0,1,.2-.48.73.73,0,0,1,.49-.21H19.46Z" transform="translate(-4.41 -4.17)"/></g></svg>',
  subscript: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.75 14.61"><g><path d="M15.38,4.33H12.74L11.19,7c-.28.46-.51.87-.69,1.21L10.07,9h0l-.44-.8c-.22-.4-.45-.81-.71-1.23L7.34,4.33H4.68L8.26,10,4.4,16.08H7.1l1.69-2.83c.38-.63.72-1.22,1-1.78l.25-.46h0l.49.92c.24.45.48.89.74,1.32L13,16.08h2.61L11.84,10l1.77-2.84,1.77-2.85Zm4.77,13.75H17v-.15c0-.4.05-.64.16-.72a4.42,4.42,0,0,1,1.16-.31,3.3,3.3,0,0,0,1.54-.56A1.84,1.84,0,0,0,20.15,15a1.78,1.78,0,0,0-.44-1.41A2.8,2.8,0,0,0,18,13.25a2.71,2.71,0,0,0-1.69.37,1.83,1.83,0,0,0-.44,1.43v.23H17v-.23q0-.63.18-.78a1.62,1.62,0,0,1,.88-.15,1.59,1.59,0,0,1,.88.15q.18.15.18.75t-.18.75a3.58,3.58,0,0,1-1.18.33,3.33,3.33,0,0,0-1.52.51,1.57,1.57,0,0,0-.32,1.18v1.15h4.27v-.86Z" transform="translate(-4.4 -4.33)"/></g></svg>',
  superscript: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.75 15.42"><g><path d="M12,13.14l3.61-5.81H12.94L11.33,10c-.28.46-.51.88-.69,1.25l-.45.83h0l-.45-.85c-.22-.41-.45-.82-.71-1.24L7.4,7.33H4.68l3.66,5.81L4.4,19.33H7.14l1.74-2.87q.58-1,1-1.83l.25-.48h0l.51.94.75,1.37,1.72,2.87h2.67l-1.92-3.09c-1.12-1.8-1.76-2.83-1.92-3.1Zm4.84-4.41h0l0,.15h3.27v.86H15.77V8.58a1.66,1.66,0,0,1,.33-1.22,3.51,3.51,0,0,1,1.56-.51,3.68,3.68,0,0,0,1.21-.34c.13-.1.19-.36.19-.77S19,5.07,18.87,5A1.63,1.63,0,0,0,18,4.8a1.58,1.58,0,0,0-.91.17c-.13.11-.19.38-.19.8V6H15.78V5.76a1.87,1.87,0,0,1,.45-1.47A2.84,2.84,0,0,1,18,3.91a2.8,2.8,0,0,1,1.72.38,1.84,1.84,0,0,1,.45,1.44,1.91,1.91,0,0,1-.34,1.35,3.24,3.24,0,0,1-1.58.57A3.69,3.69,0,0,0,17,8c-.12.1-.17.35-.17.76Z" transform="translate(-4.4 -3.91)"/></g></svg>',
  erase: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 13.76"><g><path d="M13.69,17.2h6.46v1.31H8.56L4.41,14.37,14,4.75l6.06,6.06L16.89,14l-3.2,3.19Zm-4.61,0h2.77L14.09,15,9.88,10.75,6.25,14.38l1.41,1.41c.84.82,1.31,1.29,1.42,1.41Z" transform="translate(-4.41 -4.75)"/></g></svg>',
  indent: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 12.36"><g><path d="M4.68,14.45a.27.27,0,0,1-.19-.08.3.3,0,0,1-.08-.21V9.1a.27.27,0,0,1,.08-.19.28.28,0,0,1,.2-.08.25.25,0,0,1,.19.07l2.54,2.54a.29.29,0,0,1,0,.4L4.88,14.36a.24.24,0,0,1-.2.09Zm15.19,1.12a.27.27,0,0,1,.19.08.25.25,0,0,1,.08.19v1.69a.27.27,0,0,1-.08.19.25.25,0,0,1-.19.08H4.68a.27.27,0,0,1-.19-.08.25.25,0,0,1-.08-.19V15.84a.27.27,0,0,1,.27-.27H19.87Zm0-3.38a.27.27,0,0,1,.19.08.28.28,0,0,1,.08.21v1.68a.32.32,0,0,1-.08.21.25.25,0,0,1-.19.08H10.31a.27.27,0,0,1-.19-.08.3.3,0,0,1-.08-.21V12.48a.32.32,0,0,1,.08-.21.24.24,0,0,1,.19-.08h9.56Zm0-3.37a.27.27,0,0,1,.19.08.25.25,0,0,1,.08.19v1.69a.27.27,0,0,1-.08.19.25.25,0,0,1-.19.08H10.31a.27.27,0,0,1-.27-.27V9.1a.27.27,0,0,1,.27-.27h9.56Zm.2-3.29a.28.28,0,0,1,.08.2V7.41a.32.32,0,0,1-.08.21.25.25,0,0,1-.19.08H4.68a.27.27,0,0,1-.19-.08.3.3,0,0,1-.08-.21V5.73a.32.32,0,0,1,.08-.21.25.25,0,0,1,.19-.08H19.87a.28.28,0,0,1,.2.09Z" transform="translate(-4.41 -5.44)"/></g></svg>',
  outdent: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 12.36"><g><path d="M19.87,15.57a.27.27,0,0,1,.19.08.25.25,0,0,1,.08.19v1.69a.27.27,0,0,1-.08.19.25.25,0,0,1-.19.08H4.68a.27.27,0,0,1-.19-.08.25.25,0,0,1-.08-.19V15.84a.27.27,0,0,1,.27-.27H19.87ZM7.5,14.45a.25.25,0,0,1-.2-.09L4.76,11.84a.29.29,0,0,1,0-.4L7.3,8.9a.29.29,0,0,1,.4,0,.31.31,0,0,1,.07.2v5.06a.32.32,0,0,1-.08.21.26.26,0,0,1-.19.08ZM19.87,8.82a.27.27,0,0,1,.19.08.25.25,0,0,1,.08.19v1.69a.27.27,0,0,1-.08.19.25.25,0,0,1-.19.08H10.31a.27.27,0,0,1-.27-.27V9.1a.27.27,0,0,1,.27-.27h9.56Zm0,3.37a.27.27,0,0,1,.19.08.28.28,0,0,1,.08.21v1.68a.32.32,0,0,1-.08.21.25.25,0,0,1-.19.08H10.31a.27.27,0,0,1-.19-.08.3.3,0,0,1-.08-.21V12.48a.32.32,0,0,1,.08-.21.24.24,0,0,1,.19-.08h9.56Zm.2-6.66a.28.28,0,0,1,.08.2V7.41a.32.32,0,0,1-.08.21.25.25,0,0,1-.19.08H4.68a.27.27,0,0,1-.19-.08.3.3,0,0,1-.08-.21V5.73a.32.32,0,0,1,.08-.21.25.25,0,0,1,.19-.08H19.87a.28.28,0,0,1,.2.09Z" transform="translate(-4.41 -5.44)"/></g></svg>',
  expansion: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 15.74"><g><path d="M11.8,13.06l-5.1,5.1H9.51V19.5H4.41V14.4H5.75v2.81L8.3,14.66q2.25-2.23,2.55-2.55Zm8.35-9.3v5.1H18.81V6.05l-5.1,5.1-1-1,5.1-5.1H15.05V3.76Z" transform="translate(-4.41 -3.76)"/></g></svg>',
  reduction: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 15.74"><g><path d="M14.91,10h2.87v1.38H12.55V6.12h1.38V9l5.24-5.24.48.49.49.48ZM6.77,11.92H12v5.23H10.62V14.26L5.37,19.5l-1-1L9.63,13.3H6.77Z" transform="translate(-4.4 -3.76)"/></g></svg>',
  code_view: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.73 11.8"><g><path d="M8.09,7.94a.76.76,0,0,1,.53.22.72.72,0,0,1,.21.52.76.76,0,0,1-.22.54L6.18,11.63l2.43,2.44a.69.69,0,0,1,.2.51.66.66,0,0,1-.21.51.75.75,0,0,1-.51.22.63.63,0,0,1-.51-.21h0L4.63,12.15a.7.7,0,0,1-.22-.53.67.67,0,0,1,.25-.55L7.57,8.16a.82.82,0,0,1,.52-.22Zm12.05,3.69a.7.7,0,0,1-.23.52L17,15.1h0a.66.66,0,0,1-.51.21.73.73,0,0,1-.51-.22.75.75,0,0,1-.22-.51.63.63,0,0,1,.21-.51l2.43-2.44L15.92,9.22a.73.73,0,0,1-.22-.53A.74.74,0,0,1,17,8.18h0l2.91,2.91a.67.67,0,0,1,.27.54Zm-5.9-5.9a.73.73,0,0,1,.61.32.71.71,0,0,1,.07.68L11,17a1,1,0,0,1-.22.32.6.6,0,0,1-.35.16.75.75,0,0,1-.69-.26.69.69,0,0,1-.12-.72L13.56,6.23a.75.75,0,0,1,.26-.35.74.74,0,0,1,.42-.15Z" transform="translate(-4.41 -5.73)"/></g></svg>',
  preview: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.65 15.66"><g><path d="M16.19,14.43l2.49,2.49a.73.73,0,0,1,.21.52.67.67,0,0,1-.22.51.7.7,0,0,1-.52.22.69.69,0,0,1-.51-.21l-2.49-2.48a5.17,5.17,0,0,1-1.34.69,4.64,4.64,0,0,1-1.48.24,4.78,4.78,0,1,1,0-9.56,4.79,4.79,0,0,1,1.84.36,4.9,4.9,0,0,1,1.56,1,4.77,4.77,0,0,1,.46,6.18ZM10,14a3.3,3.3,0,0,0,2.34.93A3.37,3.37,0,0,0,14.7,14a3.3,3.3,0,0,0-1.08-5.41,3.47,3.47,0,0,0-2.56,0A3,3,0,0,0,10,9.28,3.31,3.31,0,0,0,10,14ZM16,4a3.86,3.86,0,0,1,2.77,1.14A3.9,3.9,0,0,1,20,7.85v4a.77.77,0,0,1-.22.53.7.7,0,0,1-.52.21.72.72,0,0,1-.74-.74v-4a2.46,2.46,0,0,0-.72-1.73A2.37,2.37,0,0,0,16,5.45H8.53A2.42,2.42,0,0,0,6.08,7.89v7.52a2.41,2.41,0,0,0,.71,1.73,2.46,2.46,0,0,0,1.74.72h4.08a.73.73,0,0,1,0,1.46H8.53a3.85,3.85,0,0,1-2.78-1.14A3.93,3.93,0,0,1,4.6,15.4V7.87A3.94,3.94,0,0,1,5.76,5.09,3.88,3.88,0,0,1,8.54,4H16Z" transform="translate(-4.45 -3.8)"/></g></svg>',
  print: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16.05 16.04"><g><path d="M19.76,15.84a1.29,1.29,0,0,0,.39-.92V8.35A2.05,2.05,0,0,0,19.57,7a1.93,1.93,0,0,0-1.38-.57H6.37a1.95,1.95,0,0,0-2,2v6.56a1.23,1.23,0,0,0,.38.92,1.35,1.35,0,0,0,.93.38h2V14.9l-2,0V8.35a.67.67,0,0,1,.18-.47.62.62,0,0,1,.48-.19H18.18a.6.6,0,0,1,.46.19.66.66,0,0,1,.18.47V14.9h-2v1.32h2A1.35,1.35,0,0,0,19.76,15.84ZM17.52,7.69V5.06a1.31,1.31,0,0,0-.38-.92,1.34,1.34,0,0,0-.94-.38H8.34A1.3,1.3,0,0,0,7,5.06V7.69H8.34V5.06h7.87V7.69h1.31ZM8.34,12.93h7.87l0,5.26H8.34V12.93Zm7.87,5.26v0Zm.65,1.31a.6.6,0,0,0,.46-.19.72.72,0,0,0,.2-.47V12.29a.74.74,0,0,0-.2-.47.6.6,0,0,0-.46-.19H7.68a.6.6,0,0,0-.46.19.72.72,0,0,0-.2.47v6.55a.74.74,0,0,0,.2.47.6.6,0,0,0,.46.19h9.18ZM16.67,9.28a.7.7,0,0,0-.94,0,.63.63,0,0,0-.18.46.67.67,0,0,0,.18.47.68.68,0,0,0,.94,0,.66.66,0,0,0,.18-.47A.58.58,0,0,0,16.67,9.28Z" transform="translate(-4.25 -3.61)"/></g></svg>',
  template: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 14.27 15.64"><g><path d="M18.18,19.16a1,1,0,0,0,1-1V5.73a1,1,0,0,0-1-1h-2v1h2V18.19H6.37V5.73h2v-1h-2A.94.94,0,0,0,5.68,5a1,1,0,0,0-.29.7V18.18a.94.94,0,0,0,.29.69,1,1,0,0,0,.69.29H18.18ZM9.82,10.31h4.92a.49.49,0,0,0,.35-.15.47.47,0,0,0,.15-.35.49.49,0,0,0-.15-.35.47.47,0,0,0-.35-.15H9.82a.49.49,0,0,0-.35.15.47.47,0,0,0-.15.35.49.49,0,0,0,.15.35.47.47,0,0,0,.35.15Zm5.9,4.92H8.83a.49.49,0,0,0-.35.15.47.47,0,0,0-.15.35.49.49,0,0,0,.15.35.47.47,0,0,0,.35.15h6.89a.49.49,0,0,0,.35-.15.47.47,0,0,0,.15-.35.51.51,0,0,0-.5-.5ZM7.36,12.77a.49.49,0,0,0,.15.35.47.47,0,0,0,.35.15h8.85a.49.49,0,0,0,.35-.15.47.47,0,0,0,.15-.35.49.49,0,0,0-.15-.35.47.47,0,0,0-.35-.15H7.85a.49.49,0,0,0-.35.15.52.52,0,0,0-.14.35Z" transform="translate(-5.14 -3.77)"/><path d="M14.24,6.71a1,1,0,0,0,1-1,1,1,0,0,0-1-1,1,1,0,0,0-1-1h-2a.94.94,0,0,0-.69.28,1,1,0,0,0-.29.7A.94.94,0,0,0,9.62,5a.91.91,0,0,0-.29.69,1,1,0,0,0,.29.7,1,1,0,0,0,.69.29h3.93Z" transform="translate(-5.14 -3.77)"/></g></svg>',
  line_height: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.76 13.56"><g><path d="M4.4,4.88V8.26a2,2,0,0,0,.5.39s.1,0,.18-.12a.62.62,0,0,0,.17-.28c.06-.19.13-.44.21-.74s.14-.52.19-.66a.58.58,0,0,1,.21-.3,2.41,2.41,0,0,1,.63-.21,3.83,3.83,0,0,1,.88-.12,9.15,9.15,0,0,1,1.31.06.16.16,0,0,1,.11,0,.26.26,0,0,1,.06.14,4,4,0,0,1,0,.49v2l.05,3.77c0,1.41,0,2.68-.05,3.81a1.79,1.79,0,0,1-.11.49,10.68,10.68,0,0,1-1.4.45,1.12,1.12,0,0,0-.69.43v.31l0,.22.61,0c.85-.08,1.54-.12,2.06-.12a19.76,19.76,0,0,1,2.09.08,15.08,15.08,0,0,0,1.64.08,1.4,1.4,0,0,0,.29,0,1.58,1.58,0,0,0,0-.26l-.05-.43a2.26,2.26,0,0,0-.43-.17l-.77-.22-.15,0a2.55,2.55,0,0,1-.78-.28,2.56,2.56,0,0,1-.11-.75l0-1.29,0-3.15V7.53a10.51,10.51,0,0,1,.06-1.2,3.83,3.83,0,0,1,.6,0l1.88,0a2.18,2.18,0,0,1,.38,0,.45.45,0,0,1,.23.17.9.9,0,0,1,.05.25c0,.16.06.35.1.58a3.33,3.33,0,0,0,.14.55A6.39,6.39,0,0,0,15,9a2.91,2.91,0,0,0,.6-.15,2.77,2.77,0,0,0,0-.46l0-.51,0-2.95-.25,0-.38,0L15,4.94a.71.71,0,0,1-.18.15.45.45,0,0,1-.25.07l-.29,0H8.75l-.15,0H7.45a17,17,0,0,1-1.86,0L5.36,5l-.25-.13ZM19.75,16.14h-.69v-9h.69A.4.4,0,0,0,20.13,7c.06-.11,0-.24-.1-.39L18.92,5.15a.52.52,0,0,0-.86,0L17,6.58c-.12.15-.16.28-.1.39s.18.16.38.16h.69v9h-.69a.4.4,0,0,0-.38.16c-.06.11,0,.24.1.39l1.11,1.43a.52.52,0,0,0,.86,0L20,16.69c.12-.15.16-.28.1-.39a.4.4,0,0,0-.38-.16Z" transform="translate(-4.4 -4.86)"/></g></svg>',
  paragraph_style: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 11.81 15.74"><g><path d="M18.18,3.76v2h-2V19.5h-2V5.73h-2V19.5h-2V11.63a3.94,3.94,0,0,1,0-7.87h7.87Z" transform="translate(-6.37 -3.76)"/></g></svg>',
  text_style: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 13.76 15.74"><g><path d="M17.68,6.71a2.22,2.22,0,0,0,1.06-.22.74.74,0,0,0,.42-.7.73.73,0,0,0-.08-.33.67.67,0,0,0-.17-.22,1,1,0,0,0-.31-.15L18.26,5l-.45-.09A15.27,15.27,0,0,0,13.26,5V4.74c0-.66-.63-1-1.92-1-.24,0-.43.15-.59.46a4,4,0,0,0-.36,1.14h0v0a26.45,26.45,0,0,1-3.5.35A2,2,0,0,0,5.77,6a.84.84,0,0,0-.37.79,2.14,2.14,0,0,0,.41,1.29,1.23,1.23,0,0,0,1.05.63,16.62,16.62,0,0,0,3.29-.45l-.34,3.35c-.16,1.61-.29,2.9-.37,3.86s-.12,1.66-.12,2.09l0,.65a5.15,5.15,0,0,0,.05.6,1.28,1.28,0,0,0,.16.54.34.34,0,0,0,.28.18,1.16,1.16,0,0,0,.79-.46,3.66,3.66,0,0,0,.68-1,22.08,22.08,0,0,0,1-4.33q.49-3.1.78-6.15a24.69,24.69,0,0,1,4.62-.84Z" transform="translate(-5.4 -3.76)"/></g></svg>',
  save: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 15.74"><g><path d="M18.53,19.5l.2-.05A1.78,1.78,0,0,0,20.13,18l0-.09V7.14a2,2,0,0,0-.28-.64A3.18,3.18,0,0,0,19.43,6c-.5-.52-1-1-1.55-1.54A2.59,2.59,0,0,0,17.37,4a1.83,1.83,0,0,0-.61-.25H6l-.21,0a1.78,1.78,0,0,0-1.4,1.49l0,.1V17.87a2.49,2.49,0,0,0,.09.37,1.79,1.79,0,0,0,1.44,1.23l.09,0Zm-6.25-.6H6.92a.61.61,0,0,1-.68-.48.78.78,0,0,1,0-.22V12.3a.62.62,0,0,1,.69-.68H17.64a.62.62,0,0,1,.69.69V18.2a.64.64,0,0,1-.71.69H12.28ZM12,9.81H8.15a.63.63,0,0,1-.72-.71v-4a.64.64,0,0,1,.72-.72h7.66a.64.64,0,0,1,.72.72v4a.65.65,0,0,1-.74.72ZM13.5,5V9.18h1.78V5Z" transform="translate(-4.41 -3.76)"/></g></svg>',
  blockquote: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 475.082 475.081"><g><path d="M164.45,219.27h-63.954c-7.614,0-14.087-2.664-19.417-7.994c-5.327-5.33-7.994-11.801-7.994-19.417v-9.132c0-20.177,7.139-37.401,21.416-51.678c14.276-14.272,31.503-21.411,51.678-21.411h18.271c4.948,0,9.229-1.809,12.847-5.424c3.616-3.617,5.424-7.898,5.424-12.847V54.819c0-4.948-1.809-9.233-5.424-12.85c-3.617-3.612-7.898-5.424-12.847-5.424h-18.271c-19.797,0-38.684,3.858-56.673,11.563c-17.987,7.71-33.545,18.132-46.68,31.267c-13.134,13.129-23.553,28.688-31.262,46.677C3.855,144.039,0,162.931,0,182.726v200.991c0,15.235,5.327,28.171,15.986,38.834c10.66,10.657,23.606,15.985,38.832,15.985h109.639c15.225,0,28.167-5.328,38.828-15.985c10.657-10.663,15.987-23.599,15.987-38.834V274.088c0-15.232-5.33-28.168-15.994-38.832C192.622,224.6,179.675,219.27,164.45,219.27z"/><path d="M459.103,235.256c-10.656-10.656-23.599-15.986-38.828-15.986h-63.953c-7.61,0-14.089-2.664-19.41-7.994c-5.332-5.33-7.994-11.801-7.994-19.417v-9.132c0-20.177,7.139-37.401,21.409-51.678c14.271-14.272,31.497-21.411,51.682-21.411h18.267c4.949,0,9.233-1.809,12.848-5.424c3.613-3.617,5.428-7.898,5.428-12.847V54.819c0-4.948-1.814-9.233-5.428-12.85c-3.614-3.612-7.898-5.424-12.848-5.424h-18.267c-19.808,0-38.691,3.858-56.685,11.563c-17.984,7.71-33.537,18.132-46.672,31.267c-13.135,13.129-23.559,28.688-31.265,46.677c-7.707,17.987-11.567,36.879-11.567,56.674v200.991c0,15.235,5.332,28.171,15.988,38.834c10.657,10.657,23.6,15.985,38.828,15.985h109.633c15.229,0,28.171-5.328,38.827-15.985c10.664-10.663,15.985-23.599,15.985-38.834V274.088C475.082,258.855,469.76,245.92,459.103,235.256z"/></g></svg>',
  arrow_down: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.73 8.67"><g><path d="M18.79,7.52a.8.8,0,0,1,.56-.23.82.82,0,0,1,.79.79.8.8,0,0,1-.23.56l-7.07,7.07a.79.79,0,0,1-.57.25.77.77,0,0,1-.57-.25h0L4.64,8.65a.8.8,0,0,1-.23-.57.82.82,0,0,1,.79-.79.8.8,0,0,1,.56.23L12.28,14l3.26-3.26,3.25-3.26Z" transform="translate(-4.41 -7.29)"/></g></svg>',
  align_justify: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 13.77"><g><path d="M4.41,4.74v2H20.15v-2H4.41Zm0,5.9H20.15v-2H4.41v2Zm0,3.94H20.15v-2H4.41v2Zm0,3.93h7.87v-2H4.41v2Z" transform="translate(-4.41 -4.74)"/></g></svg>',
  align_left: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 13.77"><g><path d="M4.41,4.74v2H20.15v-2H4.41Zm11.8,3.94H4.41v2H16.22v-2Zm-11.8,5.9H18.18v-2H4.41v2Zm0,3.93h9.84v-2H4.41v2Z" transform="translate(-4.41 -4.74)"/></g></svg>',
  align_right: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 13.77"><g><path d="M4.41,4.74v2H20.15v-2H4.41Zm3.93,5.9H20.15v-2H8.34v2Zm-2,3.94H20.14v-2H6.37v2Zm3.94,3.93h9.84v-2H10.31v2Z" transform="translate(-4.41 -4.74)"/></g></svg>',
  align_center: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 13.77"><g><path d="M4.41,4.74v2H20.15v-2H4.41Zm2,3.94v2H18.18v-2H6.37Zm-1,5.9H19.16v-2H5.39v2Zm2,3.93H17.2v-2H7.36v2Z" transform="translate(-4.41 -4.74)"/></g></svg>',
  font_color: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 14.61"><g><path d="M18.5,15.57,14.28,4.32h-3.4L6.65,15.57h3l.8-2.26h4.23l.8,2.26h3ZM14,11.07H11.14L12.54,7,13.25,9c.41,1.18.64,1.86.7,2ZM4.41,16.69v2.24H20.15V16.69H4.41Z" transform="translate(-4.41 -4.32)"/></g></svg>',
  highlight_color: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.66 15.74"><g><path d="M12.32,9.31,13.38,13H11.21l.52-1.83q.46-1.61.54-1.83ZM4.44,3.76H20.1V19.5H4.44V3.76ZM14.71,17.32h2.63L13.7,6H10.89L7.26,17.32H9.89l.63-2.24h3.55l.32,1.12c.18.65.29,1,.32,1.12Z" transform="translate(-4.44 -3.76)"/></g></svg>',
  list_bullets: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 12.37"><g><path d="M7.77,16.12a1.59,1.59,0,0,0-.49-1.18,1.62,1.62,0,0,0-1.19-.49,1.68,1.68,0,1,0,0,3.36,1.67,1.67,0,0,0,1.68-1.69Zm0-4.48A1.67,1.67,0,0,0,6.09,10,1.68,1.68,0,0,0,4.9,12.82a1.62,1.62,0,0,0,1.19.49,1.67,1.67,0,0,0,1.68-1.67Zm12.38,3.64a.27.27,0,0,0-.08-.19.28.28,0,0,0-.2-.09H9.19a.28.28,0,0,0-.2.08.29.29,0,0,0-.08.19V17a.27.27,0,0,0,.28.28H19.87a.27.27,0,0,0,.19-.08.24.24,0,0,0,.08-.2V15.28ZM7.77,7.13a1.63,1.63,0,0,0-.49-1.2,1.61,1.61,0,0,0-1.19-.49,1.61,1.61,0,0,0-1.19.49,1.71,1.71,0,0,0,0,2.4,1.62,1.62,0,0,0,1.19.49,1.61,1.61,0,0,0,1.19-.49,1.63,1.63,0,0,0,.49-1.2Zm12.38,3.66a.28.28,0,0,0-.08-.2.29.29,0,0,0-.19-.08H9.19a.27.27,0,0,0-.28.28v1.69a.27.27,0,0,0,.08.19.24.24,0,0,0,.2.08H19.87a.27.27,0,0,0,.19-.08.25.25,0,0,0,.08-.19V10.79Zm0-4.5a.27.27,0,0,0-.08-.19A.25.25,0,0,0,19.88,6H9.19A.28.28,0,0,0,9,6.1a.26.26,0,0,0-.08.19V8A.27.27,0,0,0,9,8.17a.24.24,0,0,0,.2.08H19.87a.27.27,0,0,0,.19-.08A.25.25,0,0,0,20.14,8V6.29Z" transform="translate(-4.41 -5.44)"/></g></svg>',
  list_number: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.69 15.74"><g><path d="M7.66,18a1.24,1.24,0,0,0-.26-.78,1.17,1.17,0,0,0-.72-.42l.85-1V15H4.58v1.34h.94v-.46l.85,0h0c-.11.11-.22.23-.32.35s-.23.27-.37.47L5.39,17l.23.51c.61-.05.92.11.92.49a.42.42,0,0,1-.18.37.79.79,0,0,1-.45.12A1.41,1.41,0,0,1,5,18.15l-.51.77A2.06,2.06,0,0,0,6,19.5a1.8,1.8,0,0,0,1.2-.41A1.38,1.38,0,0,0,7.66,18Zm0-5.54H6.75V13H5.63A.72.72,0,0,1,6,12.51a5.45,5.45,0,0,1,.66-.45,2.71,2.71,0,0,0,.67-.57,1.19,1.19,0,0,0,.31-.81,1.29,1.29,0,0,0-.45-1,1.86,1.86,0,0,0-2-.11,1.51,1.51,0,0,0-.62.7l.74.52A.87.87,0,0,1,6,10.28a.51.51,0,0,1,.35.12.42.42,0,0,1,.13.33.55.55,0,0,1-.21.4,3,3,0,0,1-.5.38c-.19.13-.39.27-.58.42a2,2,0,0,0-.5.6,1.63,1.63,0,0,0-.21.81,3.89,3.89,0,0,0,.05.48h3.2V12.44Zm12.45,2.82a.27.27,0,0,0-.08-.19.28.28,0,0,0-.21-.08H9.1a.32.32,0,0,0-.21.08.24.24,0,0,0-.08.2V17a.27.27,0,0,0,.08.19.3.3,0,0,0,.21.08H19.83a.32.32,0,0,0,.21-.08.25.25,0,0,0,.08-.19V15.26ZM7.69,7.32h-1V3.76H5.8L4.6,4.88l.63.68a1.85,1.85,0,0,0,.43-.48h0l0,2.24H4.74V8.2h3V7.32Zm12.43,3.42a.27.27,0,0,0-.08-.19.28.28,0,0,0-.21-.08H9.1a.32.32,0,0,0-.21.08.24.24,0,0,0-.08.2v1.71a.27.27,0,0,0,.08.19.3.3,0,0,0,.21.08H19.83a.32.32,0,0,0,.21-.08.25.25,0,0,0,.08-.19V10.74Zm0-4.52A.27.27,0,0,0,20,6,.28.28,0,0,0,19.83,6H9.1A.32.32,0,0,0,8.89,6a.24.24,0,0,0-.08.19V7.93a.27.27,0,0,0,.08.19.32.32,0,0,0,.21.08H19.83A.32.32,0,0,0,20,8.12a.26.26,0,0,0,.08-.2V6.22Z" transform="translate(-4.43 -3.76)"/></g></svg>',
  table: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 15.74"><g><path d="M4.41,8.05V3.76H8.7V8.05H4.41Zm5.71,0V3.76h4.3V8.05h-4.3Zm5.74-4.29h4.29V8.05H15.86V3.76Zm-11.45,10V9.48H8.7v4.3H4.41Zm5.71,0V9.48h4.3v4.3h-4.3Zm5.74,0V9.48h4.29v4.3H15.86ZM4.41,19.5V15.21H8.7V19.5H4.41Zm5.71,0V15.21h4.3V19.5h-4.3Zm5.74,0V15.21h4.29V19.5H15.86Z" transform="translate(-4.41 -3.76)"/></g></svg>',
  horizontal_rule: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 2.24"><g><path d="M20.15,12.75V10.51H4.41v2.24H20.15Z" transform="translate(-4.41 -10.51)"/></g></svg>',
  show_blocks: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.66 15.67"><g><path d="M19.72,5.58a1.64,1.64,0,0,0-1.64-1.64H6.23a1.62,1.62,0,0,0-1.16.48,1.63,1.63,0,0,0-.48,1.16V9.63a1.6,1.6,0,0,0,.48,1.16,1.62,1.62,0,0,0,1.16.47H18.09a1.67,1.67,0,0,0,1.16-.47,1.62,1.62,0,0,0,.48-1.16V5.58Zm-.94,4.05a.68.68,0,0,1-.7.7H6.23a.66.66,0,0,1-.48-.2.74.74,0,0,1-.21-.5V5.58a.66.66,0,0,1,.2-.48.71.71,0,0,1,.48-.21H18.08a.74.74,0,0,1,.5.21.66.66,0,0,1,.2.48ZM6.48,7.72a.21.21,0,0,0,.17-.07.22.22,0,0,0,.07-.17V7.06a1.27,1.27,0,0,1,.11-.52.37.37,0,0,1,.36-.23H8.77A.25.25,0,0,0,9,6.17a.19.19,0,0,0,0-.23.27.27,0,0,0-.2-.12H7.19a.88.88,0,0,0-.72.39,1.51,1.51,0,0,0-.23.85v.42a.24.24,0,0,0,.24.24Zm-.19.81a.21.21,0,0,0,.17-.07.26.26,0,0,0,.07-.17.24.24,0,0,0-.24-.24.2.2,0,0,0-.16.09.2.2,0,0,0-.07.16.22.22,0,0,0,.07.17.23.23,0,0,0,.16.06Zm8.46,5.1a1.63,1.63,0,0,0-.47-1.16A1.61,1.61,0,0,0,13.12,12H6.23a1.6,1.6,0,0,0-1.16.46,1.62,1.62,0,0,0-.48,1.16v4.05a1.64,1.64,0,0,0,1.64,1.64h6.89a1.6,1.6,0,0,0,1.16-.48,1.62,1.62,0,0,0,.47-1.16Zm-.94,4a.7.7,0,0,1-.2.49.65.65,0,0,1-.5.2H6.23a.66.66,0,0,1-.48-.2.75.75,0,0,1-.21-.49v-4a.74.74,0,0,1,.21-.5.66.66,0,0,1,.48-.2h6.89a.68.68,0,0,1,.7.7v4Zm6.15,0v-4a1.6,1.6,0,0,0-.48-1.16A1.67,1.67,0,0,0,18.32,12H17.1a1.63,1.63,0,0,0-1.16.47,1.61,1.61,0,0,0-.47,1.16v4a1.67,1.67,0,0,0,.47,1.16,1.62,1.62,0,0,0,1.16.48h1.22A1.64,1.64,0,0,0,20,17.68Zm-.94-4v4a.75.75,0,0,1-.21.49.62.62,0,0,1-.48.2H17.11a.69.69,0,0,1-.5-.2.7.7,0,0,1-.2-.49v-4a.68.68,0,0,1,.7-.7h1.22a.66.66,0,0,1,.48.2.72.72,0,0,1,.21.5Z" transform="translate(-4.44 -3.79)"/></g></svg>',
  cancel: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 15.74"><g><path d="M14.15,11.63l5.61,5.61a1.29,1.29,0,0,1,.38.93,1.27,1.27,0,0,1-.4.93,1.25,1.25,0,0,1-.92.4,1.31,1.31,0,0,1-.94-.4l-5.61-5.61L6.67,19.1a1.31,1.31,0,0,1-.94.4,1.24,1.24,0,0,1-.92-.4,1.27,1.27,0,0,1-.4-.93,1.33,1.33,0,0,1,.38-.93l5.61-5.63L4.79,6a1.26,1.26,0,0,1-.38-.93,1.22,1.22,0,0,1,.4-.92,1.28,1.28,0,0,1,.92-.39,1.38,1.38,0,0,1,.94.38l5.61,5.61,5.61-5.61a1.33,1.33,0,0,1,.94-.38,1.26,1.26,0,0,1,.92.39,1.24,1.24,0,0,1,.4.92,1.29,1.29,0,0,1-.39.93L17,8.81l-2.8,2.82Z" transform="translate(-4.41 -3.76)"/></g></svg>',
  image: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.75 15.77"><g><path d="M8.77,8.72a.88.88,0,0,1-.61-.27.82.82,0,0,1-.25-.61.89.89,0,0,1,.25-.62A.82.82,0,0,1,8.77,7a.81.81,0,0,1,.61.25.83.83,0,0,1,.27.62.81.81,0,0,1-.25.61.91.91,0,0,1-.63.27Zm9.62-5a1.74,1.74,0,0,1,1.76,1.76V17.76a1.74,1.74,0,0,1-1.76,1.76H6.16A1.74,1.74,0,0,1,4.4,17.76V5.51A1.74,1.74,0,0,1,6.16,3.75H18.39Zm0,1.75H6.16v8L8.53,11.8a.94.94,0,0,1,.54-.17.86.86,0,0,1,.54.2L11.09,13l3.64-4.55a.78.78,0,0,1,.34-.25.85.85,0,0,1,.42-.07.89.89,0,0,1,.39.12.78.78,0,0,1,.28.29l2.24,3.67V5.51Zm0,12.24V15.6L15.3,10.53,11.89,14.8a.89.89,0,0,1-.59.32.82.82,0,0,1-.64-.18L9,13.62,6.16,15.74v2Z" transform="translate(-4.4 -3.75)"/></g></svg>',
  video: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 14.55"><g><path d="M20.15,10.26V18.9l-3.94-1.57v1.2H4.41V10.66H16.22v1.23l2-.81,2-.82ZM14.64,17h0V12.54h0v-.31H6V17h8.67Zm3.94-.37v-4l-2.37,1v2l1.18.48,1.19.48ZM7.94,9.86A2.77,2.77,0,0,1,5.19,7.11a2.76,2.76,0,0,1,5.51,0A2.78,2.78,0,0,1,7.94,9.86Zm0-3.93a1.21,1.21,0,0,0-.83.35,1.15,1.15,0,0,0-.34.84A1.09,1.09,0,0,0,7.11,8,1.15,1.15,0,0,0,8,8.28,1.13,1.13,0,0,0,9.11,7.12,1.16,1.16,0,0,0,7.94,5.93Zm5.9,3.93a2.34,2.34,0,0,1-1.67-.68,2.3,2.3,0,0,1-.68-1.67,2.35,2.35,0,0,1,4-1.67,2.37,2.37,0,0,1,0,3.34,2.33,2.33,0,0,1-1.68.68Zm0-3.14a.75.75,0,1,0,.55.22.73.73,0,0,0-.55-.22Z" transform="translate(-4.41 -4.35)"/></g></svg>',
  link: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 15.72"><g><path d="M13.05,13.63a.24.24,0,0,1,.15.22L13.42,16a.19.19,0,0,1-.08.18l-2.12,2.14a4.08,4.08,0,0,1-1.29.85A4,4,0,0,1,4.71,17a3.92,3.92,0,0,1-.3-1.52A4,4,0,0,1,4.71,14a3.91,3.91,0,0,1,.87-1.3L7.7,10.56a.25.25,0,0,1,.2-.06l2.17.22a.21.21,0,0,1,.19.15.24.24,0,0,1,0,.25L7.12,14.23a1.81,1.81,0,0,0,0,2.58,1.78,1.78,0,0,0,1.29.52,1.74,1.74,0,0,0,1.28-.52L12.8,13.7a.24.24,0,0,1,.25-.07ZM19,4.92a4,4,0,0,1,0,5.66L16.86,12.7a.25.25,0,0,1-.17.08l-2.2-.23a.21.21,0,0,1-.19-.15.22.22,0,0,1,0-.25L17.44,9a1.81,1.81,0,0,0,0-2.58,1.78,1.78,0,0,0-1.29-.52,1.74,1.74,0,0,0-1.28.52L11.76,9.57a.21.21,0,0,1-.25,0,.24.24,0,0,1-.16-.21l-.22-2.17a.19.19,0,0,1,.08-.18l2.12-2.14a4.08,4.08,0,0,1,1.29-.85,4.05,4.05,0,0,1,3.06,0,3.85,3.85,0,0,1,1.3.85ZM5.84,9.82a.25.25,0,0,1-.18-.08.19.19,0,0,1-.07-.19l.11-.77a.2.2,0,0,1,.11-.17.24.24,0,0,1,.2,0l2.5.72a.25.25,0,0,1,.15.27.22.22,0,0,1-.23.21l-2.59,0Zm4.12-2-.73-2.5a.27.27,0,0,1,0-.2A.21.21,0,0,1,9.41,5L10.19,5a.25.25,0,0,1,.19,0,.23.23,0,0,1,.08.18l-.05,2.61a.2.2,0,0,1-.19.23h0A.22.22,0,0,1,10,7.85Zm8.76,5.58a.25.25,0,0,1,.18.08.23.23,0,0,1,.06.2l-.11.77a.25.25,0,0,1-.11.17.21.21,0,0,1-.12,0l-.08,0L16,14a.25.25,0,0,1-.15-.27.22.22,0,0,1,.22-.21l1.29,0,1.33,0Zm-4.12,2,.74,2.51a.28.28,0,0,1,0,.2.23.23,0,0,1-.18.11l-.8.11a.23.23,0,0,1-.17-.07.25.25,0,0,1-.08-.18l0-2.61a.22.22,0,0,1,.22-.22.21.21,0,0,1,.26.15Z" transform="translate(-4.41 -3.77)"/></g></svg>',
  math: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 11.81 15.73"><g><path d="M17.19,5.73a1,1,0,0,0,.71-.29,1,1,0,0,0,.28-.7,1,1,0,0,0-1-1H7.35a1,1,0,0,0-1,1,.77.77,0,0,0,.13.47h0l4.58,6.43L6.68,17.81a1.25,1.25,0,0,0-.29.71.94.94,0,0,0,.28.7.92.92,0,0,0,.69.28H17.2a1,1,0,0,0,.71-.28,1,1,0,0,0,0-1.39.92.92,0,0,0-.71-.29H9.26l3.87-5.43a.86.86,0,0,0,0-.95L9.26,5.73h7.93Z" transform="translate(-6.38 -3.77)"/></g></svg>',
  unlink: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 15.72"><g><path d="M19,18.32a4,4,0,0,0,0-5.68L15.85,9.5l-1.17,1.55L17.57,14a2,2,0,0,1,.61,1.47,2.08,2.08,0,0,1-2.09,2.09,2,2,0,0,1-1.47-.61l-.38-.37-1.74,1,.8.78a4,4,0,0,0,5.68,0ZM8,9.77a2,2,0,0,1-1.27-1,1.89,1.89,0,0,1-.21-1.57A2.1,2.1,0,0,1,7.45,6,2,2,0,0,1,9,5.76L12.27,7.2l.49-2L9.48,3.9a4,4,0,0,0-3.06.41A3.82,3.82,0,0,0,4.56,6.73a3.8,3.8,0,0,0,.4,3A3.78,3.78,0,0,0,7.39,11.6l5.38,2,.49-2-2.64-.94L8,9.77Z" transform="translate(-4.41 -3.76)"/></g></svg>',
  table_header: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.75 15.74"><g><path d="M17,19.5v-.78H15.5v.78H17Zm-3,0v-.78H12.5v.78H14Zm-3,0v-.78H9.53v.78H11Zm-3,0v-.78H6.53v.78H8Zm10.55,0a1.73,1.73,0,0,0,.85-.35,1.67,1.67,0,0,0,.56-.76l-.71-.31a1.21,1.21,0,0,1-.35.4,1.34,1.34,0,0,1-.53.23l.08.38c.06.24.09.38.1.41Zm-13.7-.63.55-.55A.77.77,0,0,1,5.25,18a1.31,1.31,0,0,1-.06-.38v-.38H4.41v.38a2,2,0,0,0,.12.68,1.6,1.6,0,0,0,.35.57Zm15.27-2.12V15.26h-.78v1.49h.78Zm-15-1V14.23H4.41v1.49h.78Zm15-2V12.26h-.78v1.49h.78Zm-15-1V11.22H4.41v1.51h.78Zm15-2V9.26h-.78v1.51h.78Zm-15-1V8.17H4.41V9.74h.78Zm15-2V6.28h-.78V7.77h.78Zm-15-1.11V5.33L4.48,5.1a.77.77,0,0,0-.07.27,2.72,2.72,0,0,0,0,.28v1h.79ZM19.21,5l.63-.4A1.62,1.62,0,0,0,19.16,4a1.94,1.94,0,0,0-.91-.22v.78a1.31,1.31,0,0,1,.56.12.88.88,0,0,1,.4.36ZM6,4.54H7.78V3.76H6a.82.82,0,0,0-.28.06l.12.35c.07.21.1.33.11.36Zm10.8,0V3.76H15.28v.78h1.49Zm-3,0V3.76H12.28v.78h1.49Zm-3,0V3.76H9.28v.78h1.51ZM6,10.84h12.6V6.91H6Z" transform="translate(-4.4 -3.76)"/></g></svg>',
  merge_cell: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.76 15.74"><g><path d="M18.92,13.5h1.23v4.15A1.84,1.84,0,0,1,18.3,19.5H14V18.27H18.3a.6.6,0,0,0,.44-.18.59.59,0,0,0,.18-.44V13.5ZM18.3,3.76a1.84,1.84,0,0,1,1.85,1.85V9.82H18.92V5.6a.6.6,0,0,0-.18-.44A.59.59,0,0,0,18.3,5H14V3.76H18.3Zm1.85,8.51H15.6L17.26,14l-.86.86-3.14-3.17L16.4,8.51l.86.86L15.62,11h4.54v1.24Zm-13.9,6h4.27V19.5H6.25A1.84,1.84,0,0,1,4.4,17.65V13.5H5.63v4.15a.61.61,0,0,0,.62.62Zm0-14.51h4.27V5H6.25a.6.6,0,0,0-.44.18.57.57,0,0,0-.17.43V9.81H4.41V5.6A1.83,1.83,0,0,1,6.25,3.76Zm5,7.9L8.15,14.83,7.3,14,9,12.27H4.41V11H8.94L7.3,9.38,7.73,9l.43-.43Z" transform="translate(-4.4 -3.76)"/></g></svg>',
  split_cell: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.75 15.74"><g><path d="M10.37,12.25H6.74L8.4,13.94l-.87.86L4.41,11.63,7.53,8.5l.87.86L6.74,11h3.62v1.23Zm9.78-.61L17,14.81,16.13,14l1.66-1.69H14.16V11h3.63L16.13,9.37l.43-.43A5.24,5.24,0,0,1,17,8.51ZM18.9,8.22V5.61a.57.57,0,0,0-.18-.43A.65.65,0,0,0,18.29,5H12.88V18.28h5.41a.7.7,0,0,0,.44-.18.57.57,0,0,0,.18-.43V15h1.23v2.64a1.84,1.84,0,0,1-1.85,1.83h-12A1.84,1.84,0,0,1,4.94,19a1.81,1.81,0,0,1-.54-1.29V15H5.63v2.64a.57.57,0,0,0,.18.43.67.67,0,0,0,.44.18h5.41V5H6.25a.7.7,0,0,0-.44.18.56.56,0,0,0-.17.43V8.22H4.41V5.61A1.8,1.8,0,0,1,5,4.31a1.91,1.91,0,0,1,1.31-.55h12a1.89,1.89,0,0,1,1.31.55,1.8,1.8,0,0,1,.54,1.3V8.23H18.9Z" transform="translate(-4.4 -3.76)"/></g></svg>',
  caption: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 13.79"><g><path d="M4.41,18.52H20.15v-2H4.41ZM20,4.73H18.07V6h.65v.65H20V4.73ZM17,6V4.73H14.55V6H17ZM13.49,6V4.73H11V6h2.47ZM10,6V4.73H7.5V6H10ZM5.79,6h.65V4.73H4.5V6.67H5.8V6ZM4.5,11.34H5.79V8.48H4.5ZM6.44,13.8H5.79v-.65H4.5v1.94H6.44ZM17,15.09V13.8H14.55v1.29H17Zm-3.52,0V13.8H11v1.29h2.47Zm-3.53,0V13.8H7.5v1.29H10ZM20,13.16H18.72v.65h-.65V15.1H20Zm-1.29-1.82H20V8.48h-1.3v2.86Z" transform="translate(-4.41 -4.73)"/></g></svg>',
  edit: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 15.73"><g><path d="M7.51,5.68h6l1.52-1.57H6.94a2.4,2.4,0,0,0-1.79.82A2.8,2.8,0,0,0,4.41,6.8V17a2.55,2.55,0,0,0,.75,1.8A2.48,2.48,0,0,0,7,19.5H17.22a2.57,2.57,0,0,0,1.83-.74,2.52,2.52,0,0,0,.77-1.8V8.83l-1.58,1.54v6a1.54,1.54,0,0,1-1.53,1.53H7.51A1.54,1.54,0,0,1,6,16.41V7.21A1.52,1.52,0,0,1,7.51,5.68Zm5.63,7.47h0L10.7,10.74l-1,3.38,1.71-.48,1.7-.49Zm.34-.34h0l5.36-5.32L16.4,5.08,11,10.4l1.23,1.21,1.21,1.2ZM19.93,6.4a.82.82,0,0,0,.22-.48A.54.54,0,0,0,20,5.47L18.45,4A.67.67,0,0,0,18,3.77a.7.7,0,0,0-.48.21l-.74.72,2.44,2.43.37-.37.35-.36Z" transform="translate(-4.41 -3.77)"/></g></svg>',
  delete: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.73 15.74"><g><path d="M19.16,6.71a.94.94,0,0,0,.69-.28.91.91,0,0,0,.29-.68A1,1,0,0,0,19.85,5a.93.93,0,0,0-.69-.3H14.24A.94.94,0,0,0,14,4.06a.92.92,0,0,0-.7-.3h-2a1,1,0,0,0-.7.3.93.93,0,0,0-.28.68H5.39A.92.92,0,0,0,4.7,5a1,1,0,0,0-.29.71.91.91,0,0,0,.29.68,1,1,0,0,0,.69.28H19.16Zm-12.79,1a1,1,0,0,0-.7.3.94.94,0,0,0-.28.69v8.85A1.88,1.88,0,0,0,6,18.93a1.9,1.9,0,0,0,1.39.57H17.2a1.87,1.87,0,0,0,1.39-.58,1.91,1.91,0,0,0,.58-1.39V8.68A1,1,0,0,0,18.88,8a.89.89,0,0,0-.7-.29,1,1,0,0,0-.69.29.92.92,0,0,0-.29.68v7.87a1,1,0,0,1-1,1H8.34a.94.94,0,0,1-.69-.28,1,1,0,0,1-.29-.71V8.68a1,1,0,0,0-1-1Z" transform="translate(-4.41 -3.76)"/></g></svg>',
  modify: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.7 15.74"><g><path d="M19.79,15.23a.66.66,0,0,1,.3.38.59.59,0,0,1-.07.48l-.8,1.38a.66.66,0,0,1-.38.3.59.59,0,0,1-.48-.07l-.68-.38a4.55,4.55,0,0,1-1.34.77v.78a.64.64,0,0,1-.18.45.61.61,0,0,1-.45.18h-1.6a.6.6,0,0,1-.44-.18.66.66,0,0,1-.19-.45v-.78a4.36,4.36,0,0,1-1.32-.77l-.69.38a.58.58,0,0,1-.48.07.66.66,0,0,1-.38-.3l-.38-.66h.83a1.77,1.77,0,0,0,1.23-.52,1.72,1.72,0,0,0,.51-1.23v-.18a3,3,0,0,0,.49-.28l.15.09a1.83,1.83,0,0,0,.88.23A1.75,1.75,0,0,0,15.84,14l.88-1.52a1.7,1.7,0,0,0,.17-1.32,1.66,1.66,0,0,0-.3-.61,1.84,1.84,0,0,0-.51-.45l-.15-.09,0-.29,0-.28.15-.09a1,1,0,0,0,.26-.18l0,.06v.78a4.34,4.34,0,0,1,1.34.77l.68-.38a.68.68,0,0,1,.48-.06.64.64,0,0,1,.38.29l.8,1.38a.58.58,0,0,1,.07.48.63.63,0,0,1-.3.38l-.68.4a3.84,3.84,0,0,1,.08.76,4.13,4.13,0,0,1-.08.78l.34.18.32.2ZM10.17,7.86a1.9,1.9,0,0,1,1.35,3.23,1.85,1.85,0,0,1-1.35.55A1.9,1.9,0,0,1,8.83,8.41a1.92,1.92,0,0,1,1.34-.55Zm1.58,7.2a.73.73,0,0,1-.21.49.66.66,0,0,1-.48.2H9.29a.68.68,0,0,1-.69-.69V14.2a4.75,4.75,0,0,1-1.48-.86l-.75.45a.73.73,0,0,1-.7,0,.63.63,0,0,1-.25-.26L4.54,12a.67.67,0,0,1-.08-.53.71.71,0,0,1,.32-.42l.75-.43a4.8,4.8,0,0,1-.08-.85,4.71,4.71,0,0,1,.08-.85l-.74-.44a.71.71,0,0,1-.32-.42.65.65,0,0,1,.07-.54L5.42,6a.66.66,0,0,1,.42-.32l.18,0a.73.73,0,0,1,.35.09l.75.43A4.68,4.68,0,0,1,8.6,5.33V4.45a.68.68,0,0,1,.69-.69h1.77a.64.64,0,0,1,.48.2.73.73,0,0,1,.21.49v.88a4.75,4.75,0,0,1,1.48.85L14,5.75a.67.67,0,0,1,.34-.09l.18,0a.71.71,0,0,1,.42.32l.89,1.54a.67.67,0,0,1,.06.52.73.73,0,0,1-.32.43l-.75.42a4.8,4.8,0,0,1,.08.85,4.71,4.71,0,0,1-.08.85l.75.43a.66.66,0,0,1,.32.42.73.73,0,0,1-.06.54l-.89,1.52a.69.69,0,0,1-.25.26.7.7,0,0,1-.35.09.64.64,0,0,1-.34-.09l-.75-.45a4.87,4.87,0,0,1-1.48.86v.87ZM7.23,9.75a3,3,0,0,0,.86,2.08,2.94,2.94,0,1,0,4.16-4.16,3,3,0,0,0-2.08-.85A2.94,2.94,0,0,0,7.23,9.75Z" transform="translate(-4.44 -3.76)"/></g></svg>',
  revert: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.76 14.69"><g><path d="M18.26,15V12.3l1.89-2V15a2.58,2.58,0,0,1-.24,1c-.2.58-.75.92-1.65,1H7.56v2L4.41,15.63,7.56,13v2h10.7ZM6.3,8.28V11L4.41,13V8.28a2.58,2.58,0,0,1,.24-1c.2-.58.75-.92,1.65-1H17v-2l3.15,3.34L17,10.3v-2H6.3Z" transform="translate(-4.4 -4.28)"/></g></svg>',
  auto_size: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 15.74"><g><path d="M6.71,17.19,6.89,16l1.21-.15A6,6,0,0,1,6.81,13.9a5.78,5.78,0,0,1-.45-2.27A6,6,0,0,1,8.1,7.45a5.83,5.83,0,0,1,4.17-1.73l1-1-1-1A7.89,7.89,0,0,0,5,14.64a7.73,7.73,0,0,0,1.71,2.55Zm5.57,2.31h0A7.86,7.86,0,0,0,17.85,6.07L17.67,7.3l-1.21.15a5.9,5.9,0,0,1,1.29,1.92,5.81,5.81,0,0,1,.45,2.26,5.91,5.91,0,0,1-5.9,5.9l-1,1,.49.49.47.5Z" transform="translate(-4.41 -3.76)"/></g></svg>',
  insert_row_below: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.8 15.8"><g><path d="M15.7,1.3c-0.1-0.1-0.1-0.2-0.2-0.2L15.3,1H0.4L0.3,1.1c0,0-0.1,0.1-0.1,0.1c0,0-0.1,0.1-0.1,0.1L0,1.4v7.7l0.1,0.1c0,0.1,0.1,0.1,0.2,0.2l0.1,0.1h2.3V9.3l0.1-0.5L3,8.5l0.1-0.2c-0.1,0-0.2,0-0.3,0H1.2v-6h13.3v6h-1.6c-0.1,0-0.2,0-0.3,0l0.1,0.2l0.2,0.4C12.9,9,13,9.2,13,9.3v0.1h2.3l0.2-0.1c0.1,0,0.1-0.1,0.2-0.2l0.1-0.1V1.4L15.7,1.3z"/><path d="M10.5,7.5C9.9,7.1,9.3,6.8,8.6,6.7c-0.2,0-0.5-0.1-0.7,0c-0.2,0-0.5,0-0.7,0C6.6,6.7,6.1,6.9,5.6,7.3C5.2,7.6,4.7,8,4.4,8.4C4.3,8.6,4.2,8.8,4.2,8.9C4.1,9.1,4,9.3,3.9,9.4C3.9,9.6,3.8,9.7,3.8,9.9c0,0.2-0.1,0.3-0.1,0.5v-0.1c-0.1,0.8,0.1,1.6,0.5,2.4c0.4,0.7,1,1.3,1.7,1.7c0.3,0.2,0.6,0.3,0.9,0.3c0.3,0.1,0.7,0.1,1,0.1c0.3,0,0.7,0,1-0.1c0.3-0.1,0.6-0.2,0.9-0.3c0.5-0.3,0.9-0.6,1.3-1c0.3-0.4,0.6-0.8,0.8-1.3c0.1-0.4,0.2-0.9,0.2-1.4c0-0.5-0.1-1-0.3-1.4C11.5,8.6,11.1,8,10.5,7.5z M10.1,11.3H8.5v1.6H8H7.9H7.3v0v-0.1v-1.4H5.7v-0.4v-0.2v-0.6h0h1.5V8.5h1.2v1.6h1.6V11.3z"/></g></svg>',
  insert_row_above: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.8 15.8"><g><path d="M0.1,14.5c0.1,0.1,0.1,0.2,0.2,0.2l0.1,0.1h14.9l0.1-0.1c0,0,0.1-0.1,0.1-0.1c0,0,0.1-0.1,0.1-0.1l0.1-0.1V6.7l-0.1-0.1c0-0.1-0.1-0.1-0.2-0.2l-0.1-0.1h-2.3v0.1l-0.1,0.5l-0.2,0.4l-0.1,0.2c0.1,0,0.2,0,0.3,0h1.6v6H1.3v-6h1.6c0.1,0,0.2,0,0.3,0L3.1,7.3L2.9,6.9C2.8,6.8,2.8,6.6,2.7,6.5V6.3H0.4L0.3,6.4c-0.1,0-0.1,0.1-0.2,0.2L0,6.7v7.7L0.1,14.5z"/><path d="M5.3,8.3c0.6,0.5,1.2,0.8,1.9,0.9c0.2,0,0.5,0.1,0.7,0c0.2,0,0.5,0,0.7,0c0.6-0.1,1.1-0.3,1.6-0.6c0.5-0.3,0.9-0.7,1.2-1.2c0.1-0.2,0.2-0.3,0.3-0.5c0.1-0.2,0.2-0.4,0.2-0.5c0.1-0.1,0.1-0.3,0.1-0.4C12,5.8,12,5.6,12,5.4v0.1c0.1-0.8-0.1-1.6-0.5-2.4c-0.4-0.7-1-1.3-1.7-1.7C9.5,1.3,9.2,1.2,8.9,1.1C8.5,1,8.2,1,7.9,1c-0.3,0-0.7,0-1,0.1C6.6,1.2,6.3,1.3,6,1.4C5.5,1.7,5.1,2,4.7,2.4C4.4,2.8,4.1,3.3,3.9,3.8C3.8,4.2,3.7,4.7,3.7,5.2c0,0.5,0.1,1,0.3,1.4C4.3,7.2,4.7,7.8,5.3,8.3z M5.7,4.5h1.6V2.9h0.5h0.1h0.6v0v0.1v1.4H10v0.4v0.2v0.6h0H8.5v1.6H7.3V5.7H5.7V4.5z"/></g></svg>',
  insert_column_left: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.8 15.8"><g><path d="M14.5,15.7c0.1-0.1,0.2-0.1,0.2-0.2l0.1-0.1V0.4l-0.1-0.1c0,0-0.1-0.1-0.1-0.1c0,0-0.1-0.1-0.1-0.1L14.4,0H6.7L6.6,0.1c-0.1,0-0.1,0.1-0.2,0.2L6.3,0.4v2.3h0.1l0.5,0.1L7.3,3l0.2,0.1c0-0.1,0-0.2,0-0.3V1.2h6v13.3h-6v-1.6c0-0.1,0-0.2,0-0.3l-0.2,0.1l-0.4,0.2C6.7,12.9,6.6,13,6.4,13H6.3v2.3l0.1,0.2c0,0.1,0.1,0.1,0.2,0.2l0.1,0.1h7.7L14.5,15.7z"/><path d="M8.3,10.5C8.7,10,9,9.3,9.1,8.6c0-0.2,0.1-0.5,0-0.7c0-0.2,0-0.5,0-0.7C9,6.7,8.8,6.1,8.5,5.7C8.2,5.2,7.8,4.8,7.3,4.5C7.2,4.4,7,4.3,6.9,4.2C6.7,4.1,6.5,4,6.4,4C6.2,3.9,6.1,3.9,5.9,3.8c-0.2,0-0.3-0.1-0.5-0.1h0.1C4.7,3.7,3.8,3.9,3.1,4.3C2.4,4.7,1.8,5.3,1.4,6C1.3,6.3,1.2,6.6,1.1,6.9C1,7.2,1,7.6,1,7.9c0,0.3,0,0.7,0.1,1c0.1,0.3,0.2,0.6,0.3,0.9c0.3,0.5,0.6,0.9,1,1.3c0.4,0.3,0.8,0.6,1.3,0.8C4.2,12,4.7,12.1,5.1,12c0.5,0,1-0.1,1.4-0.3C7.2,11.5,7.8,11.1,8.3,10.5zM4.5,10.1V8.5H2.9V8V7.9V7.3h0H3h1.4V5.7h0.4h0.2h0.6v0v1.5h1.6v1.2H5.7v1.6H4.5z"/></g></svg>',
  insert_column_right: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.8 15.8"><g><path d="M1.3,0.1C1.2,0.2,1.1,0.2,1.1,0.3L1,0.4v14.9l0.1,0.1c0,0,0.1,0.1,0.1,0.1c0,0,0.1,0.1,0.1,0.1l0.1,0.1h7.7l0.1-0.1c0.1,0,0.1-0.1,0.2-0.2l0.1-0.1v-2.3H9.3l-0.5-0.1l-0.4-0.2l-0.2-0.1c0,0.1,0,0.2,0,0.3v1.6h-6V1.3h6v1.6c0,0.1,0,0.2,0,0.3l0.2-0.1l0.4-0.2C9,2.9,9.2,2.8,9.3,2.8h0.1V0.5L9.4,0.3c0-0.1-0.1-0.1-0.2-0.2L9.1,0H1.4L1.3,0.1z"/><path d="M7.5,5.3C7,5.8,6.7,6.5,6.6,7.2c0,0.2-0.1,0.5,0,0.7c0,0.2,0,0.5,0,0.7c0.1,0.6,0.3,1.1,0.6,1.6c0.3,0.5,0.7,0.9,1.2,1.2c0.2,0.1,0.3,0.2,0.5,0.3c0.2,0.1,0.4,0.2,0.5,0.2c0.1,0.1,0.3,0.1,0.4,0.1c0.2,0,0.3,0.1,0.5,0.1h-0.1c0.8,0.1,1.6-0.1,2.4-0.5c0.7-0.4,1.3-1,1.7-1.7c0.2-0.3,0.3-0.6,0.3-0.9c0.1-0.3,0.1-0.7,0.1-1c0-0.3,0-0.7-0.1-1c-0.1-0.3-0.2-0.6-0.3-0.9c-0.3-0.5-0.6-0.9-1-1.3C13,4.4,12.5,4.2,12,4c-0.4-0.1-0.9-0.2-1.4-0.2c-0.5,0-1,0.1-1.4,0.2C8.5,4.3,7.9,4.7,7.5,5.3z M11.3,5.7v1.6h1.6v0.5v0.1v0.6h0h-0.1h-1.4v1.6h-0.4h-0.2h-0.6v0V8.5H8.5V7.3h1.6V5.7H11.3z"/></g></svg>',
  delete_row: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.75 13.83"><g><path d="M4.7,18.46l.12.08H19.73l.12-.08a.58.58,0,0,0,.22-.22l.08-.12,0-7.69-.08-.11a.77.77,0,0,0-.18-.18l-.11-.08-2.31,0-.08.28-.1.29a1.58,1.58,0,0,1-.12.29l-.14.34s0,0,.18,0H18.9v6H5.64v-6H7.35c.14,0,.2,0,.18,0l-.14-.34a2.85,2.85,0,0,1-.12-.29l-.1-.29-.07-.27-2.31,0-.11.08a.77.77,0,0,0-.18.18l-.08.11,0,7.69.08.12a.47.47,0,0,0,.09.12l.13.09ZM12.11,13a4,4,0,0,0,1.46-.21,4.51,4.51,0,0,0,1.31-.71A4,4,0,0,0,16.26,10a4.32,4.32,0,0,0-.08-2.54,4.34,4.34,0,0,0-1-1.52,4.15,4.15,0,0,0-1.54-1,4.34,4.34,0,0,0-1.35-.22A4.07,4.07,0,0,0,11,4.93,3.94,3.94,0,0,0,9.24,6.07,3.92,3.92,0,0,0,8.15,8.88a3.91,3.91,0,0,0,.12.95A4.16,4.16,0,0,0,12.11,13Zm2.35-4.14v.58H10.09V8.27h4.37v.58Z" transform="translate(-4.4 -4.71)"/></g></svg>',
  delete_column: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 13.81 15.74"><g><path d="M5.66,19.42l.12.08,7.69,0,.11-.08a.77.77,0,0,0,.18-.18l.08-.11,0-2.32-.15,0-.45-.15-.42-.18-.17-.07a1,1,0,0,0,0,.27v1.63h-6V5h6V6.62a.9.9,0,0,0,0,.26l.17-.07.42-.17a3.91,3.91,0,0,1,.45-.15l.15,0,0-2.32L13.75,4a.77.77,0,0,0-.18-.18l-.11-.08H5.79l-.13.07a.63.63,0,0,0-.21.22l-.08.12V19.08l.08.12a.47.47,0,0,0,.09.12.35.35,0,0,0,.12.1Zm9-3.67a4.16,4.16,0,0,0,2.36-.51,4.08,4.08,0,0,0,1.67-1.72,4,4,0,0,0,.35-.91,3.79,3.79,0,0,0,.1-1,4.71,4.71,0,0,0-.11-1,5,5,0,0,0-.3-.87,4.25,4.25,0,0,0-1-1.25,4.49,4.49,0,0,0-1.34-.81A4.26,4.26,0,0,0,15,7.48a3.88,3.88,0,0,0-1.41.25A4.32,4.32,0,0,0,11.86,9,4,4,0,0,0,11,10.94a4.4,4.4,0,0,0-.05.68,4.5,4.5,0,0,0,.05.68,3.93,3.93,0,0,0,.61,1.57,4.22,4.22,0,0,0,1.18,1.2,4.59,4.59,0,0,0,.48.27c.2.1.37.17.5.22a2.44,2.44,0,0,0,.45.12,4.61,4.61,0,0,0,.5.07Zm2.54-4.12v.58H12.87V11h4.37v.59Z" transform="translate(-5.37 -3.76)"/></g></svg>',
  fixed_column_width: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M6,5H18A1,1 0 0,1 19,6A1,1 0 0,1 18,7H6A1,1 0 0,1 5,6A1,1 0 0,1 6,5M21,2V4H3V2H21M15,8H17V22H15V8M7,8H9V22H7V8M11,8H13V22H11V8Z" /></svg>',
  rotate_left: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.8 15.8"><g><path d="M0.5,10.2c0,0.1,0,0.2,0,0.3v0.2l0,0c0.1,0.3,0.3,0.6,0.4,0.9l0,0C1,11.8,1.3,12,1.5,11.9h0.1h0.2h0.1c0.1-0.1,0.3-0.3,0.4-0.5v-0.2c0-0.1,0-0.2-0.1-0.3l0,0c-0.2-0.2-0.3-0.4-0.3-0.7l0,0C1.8,10,1.7,9.9,1.5,9.8c-0.1,0-0.2,0-0.3,0H0.9C0.7,9.9,0.6,10,0.5,10.2L0.5,10.2z"/><path d="M2.2,11.5L2.2,11.5L2.2,11.5z"/><path d="M5.9,3.6L5.9,3.6L5.9,3.6z"/><path d="M0.1,7.9c0,0.3,0,0.6,0,0.9l0,0l0,0l0,0l0,0c0,0.2,0.1,0.3,0.2,0.4l0,0c0.2,0.1,0.3,0.2,0.5,0.2l0,0l0,0c0.2,0,0.4-0.1,0.5-0.3l0,0c0-0.1,0.1-0.3,0.1-0.4V8.6l0,0c0-0.2,0-0.5,0-0.7l0,0c0-0.2-0.1-0.4-0.2-0.5C1.1,7.3,0.9,7.2,0.7,7.2S0.3,7.3,0.2,7.4C0.1,7.5,0,7.7,0.1,7.9z"/><path d="M1.9,12.7L1.9,12.7c0,0.2,0,0.4,0.2,0.5l0,0l0.2,0.3l0,0c0.2,0.1,0.3,0.2,0.5,0.4l0,0l0,0l0,0l0,0C2.9,14,3,14.1,3.2,14.1s0.4-0.1,0.5-0.2c0.1-0.2,0.2-0.3,0.2-0.5v-0.1c0-0.2-0.1-0.4-0.2-0.5l0,0l-0.4-0.4l-0.2-0.2l0,0C3,12.1,2.8,12,2.6,12l0,0c-0.2,0-0.4,0.1-0.5,0.2l0,0C2,12.3,1.9,12.5,1.9,12.7z"/><path d="M6.6,15c0,0.2,0.1,0.4,0.2,0.5c0.1,0.1,0.2,0.2,0.4,0.3l0,0c0.3,0,0.5,0,0.7,0h0.3l0,0c0.2,0,0.4-0.1,0.5-0.2c0.1-0.2,0.2-0.3,0.2-0.5l0,0l0,0c0-0.2-0.1-0.4-0.2-0.5l0,0c-0.1-0.1-0.3-0.2-0.5-0.2l0,0H7.9c-0.1,0-0.3,0-0.5,0l0,0H7.3c-0.2-0.1-0.3,0-0.5,0.1l0,0C6.7,14.6,6.6,14.8,6.6,15L6.6,15L6.6,15L6.6,15z"/><path d="M4.2,7.4C4,7.5,4,7.7,4,7.9c0,0.2,0,0.4,0.2,0.5l0,0l3.2,3.2l0,0c0.1,0.1,0.3,0.2,0.5,0.2s0.3-0.1,0.5-0.2l0,0l3.2-3.2l0,0c0.1-0.1,0.2-0.3,0.2-0.5c0-0.2-0.1-0.4-0.2-0.5l0,0C11.5,7.3,11,6.7,10,5.8l0,0L8.4,4.2l0,0C8.3,4.1,8.1,4,7.9,4S7.5,4.1,7.4,4.2L4.2,7.4L4.2,7.4z M6.8,9L5.7,7.9l2.2-2.2l2.3,2.2l-2.3,2.2C7.7,9.9,7.3,9.5,6.8,9L6.8,9z"/><path d="M4.1,14.1C4,14.2,4,14.3,4,14.4v0.2l0,0c0.1,0.1,0.2,0.3,0.4,0.4l0,0c0.3,0.1,0.6,0.2,0.9,0.4h0.1h0.1l0,0c0.2,0,0.3-0.1,0.5-0.1l0,0c0.2-0.1,0.3-0.3,0.3-0.4l0,0l0,0l0,0l0,0v-0.2c0-0.1-0.1-0.2-0.1-0.3l0,0C6.1,14.2,6,14.1,5.8,14l0,0c-0.3-0.1-0.5-0.2-0.8-0.2l0,0c-0.1-0.1-0.2-0.1-0.3-0.1H4.5C4.3,13.7,4.2,13.9,4.1,14.1z"/><path d="M9.3,14.4c0,0.1-0.1,0.3,0,0.4V15l0,0c0,0.1,0.1,0.3,0.5,0.4c0.1,0.1,0.3,0.1,0.4,0.1l0,0h0.1l0,0c0.3-0.1,0.6-0.2,0.9-0.3l0,0c0.1-0.1,0.2-0.2,0.3-0.4l0.1-0.3c0-0.1-0.1-0.2-0.1-0.3l0,0c-0.1-0.2-0.2-0.3-0.4-0.4l0,0h-0.3c-0.1,0-0.2,0-0.3,0l0,0c-0.2,0.1-0.5,0.2-0.8,0.3l0,0C9.5,14.1,9.4,14.2,9.3,14.4L9.3,14.4z"/><path d="M11.4,14.7L11.4,14.7L11.4,14.7z"/><path d="M9.5,15.3L9.5,15.3L9.5,15.3z"/><path d="M15.9,7.9c0-1-0.2-2-0.6-3l0,0c-0.4-1-1-1.9-1.7-2.6C12.8,1.6,12,1,11,0.6l0,0C10.1,0.2,9,0,8,0C7.3,0,6.5,0.1,5.8,0.3l0,0C5.2,0.5,4.6,0.8,4,1.1L3.1,0.2l0,0C2.9,0.1,2.8,0,2.6,0H2.4l0,0C2.2,0,2,0.2,1.9,0.4l0,0L0.1,4.9l0,0C0,5,0,5.1,0,5.2c0,0.2,0.1,0.4,0.2,0.5l0,0c0.2,0.1,0.3,0.2,0.5,0.2h0.1H1l0,0l4.7-1.8l0,0C5.9,4,6.1,3.8,6.1,3.6V3.4C6.1,3.2,6,3,5.9,2.9l0,0L5.1,2.1c0.4-0.2,0.8-0.4,1.3-0.5c0.5-0.1,1.1-0.2,1.7-0.2c0.9,0,1.7,0.2,2.5,0.5l0,0c0.8,0.3,1.5,0.8,2.1,1.4c0.6,0.6,1.1,1.3,1.4,2.1l0,0c0.3,0.8,0.5,1.6,0.5,2.5s-0.2,1.7-0.5,2.5l0,0c-0.3,0.8-0.8,1.5-1.4,2.1c-0.2,0.2-0.4,0.3-0.6,0.5l0,0c-0.2,0.1-0.3,0.3-0.3,0.5v0.1c0,0.1,0,0.3,0.1,0.4l0,0c0.1,0.2,0.3,0.3,0.5,0.3l0,0c0.1,0,0.3-0.1,0.4-0.2l0,0l0,0l0,0l0,0c0.2-0.2,0.5-0.4,0.7-0.6l0,0l0,0l0,0l0,0c0.7-0.8,1.3-1.6,1.7-2.6C15.6,10,15.8,9,15.9,7.9z M1.9,4C2,3.8,2.1,3.5,2.3,3.1l0,0L2.7,2l1.2,1.2L1.9,4z"/><path d="M6.8,15.5L6.8,15.5L6.8,15.5z"/></g></svg>',
  rotate_right: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.8 15.8"><g><path d="M9.9,15.3L9.9,15.3L9.9,15.3z"/><path d="M6.9,15.1L6.9,15.1c0,0.1,0.1,0.3,0.2,0.4l0,0c0.1,0.2,0.3,0.3,0.5,0.3l0,0h0.3c0.2,0,0.4,0,0.7,0l0,0c0.2-0.1,0.3-0.2,0.4-0.3c0.1-0.1,0.2-0.2,0.2-0.4V15c0-0.2-0.1-0.4-0.2-0.4c-0.2-0.1-0.3-0.2-0.5-0.2H8.4l0,0c-0.1,0-0.3,0-0.5,0H7.6l0,0c-0.2,0-0.4,0.1-0.5,0.2C7,14.7,6.9,14.9,6.9,15.1z"/><path d="M6.5,14.4L6.5,14.4L6.5,14.4z"/><path d="M5.8,5.8L5.8,5.8c-1,0.9-1.5,1.5-1.7,1.6l0,0C4,7.5,4,7.7,4,7.9c0,0.2,0,0.4,0.2,0.5l0,0l3.2,3.2l0,0c0.2,0.1,0.3,0.2,0.5,0.2s0.4-0.1,0.5-0.2l0,0l3.2-3.2l0,0c0.1-0.1,0.2-0.3,0.2-0.5c0-0.2-0.1-0.4-0.2-0.5l0,0L8.4,4.2C8.3,4.1,8.1,4,7.9,4C7.7,4,7.5,4.1,7.4,4.2l0,0L5.8,5.8z M5.6,7.9l2.3-2.2l2.2,2.2L9,9l0,0l0,0l0,0l0,0c-0.5,0.6-0.9,0.9-1.1,1.1L5.6,7.9z"/><path d="M9,15.5L9,15.5L9,15.5z"/><path d="M9.6,14.7v0.2l0,0l0,0l0,0l0,0c0.1,0.2,0.1,0.3,0.3,0.3c0.1,0.1,0.3,0.1,0.4,0.1l0,0h0.1h0.1c0.3-0.1,0.6-0.3,0.9-0.4l0,0c0.1-0.1,0.2-0.2,0.3-0.4l0,0v-0.2c0-0.1,0-0.2-0.1-0.3c-0.1-0.2-0.2-0.3-0.4-0.4H11c-0.1,0-0.2,0.1-0.3,0.1l0,0c-0.2,0.1-0.4,0.2-0.7,0.3l0,0l0,0c-0.1,0.1-0.3,0.2-0.4,0.4C9.6,14.5,9.6,14.6,9.6,14.7z"/><path d="M9,14.5L9,14.5L9,14.5z"/><path d="M9.6,14.4L9.6,14.4L9.6,14.4z"/><path d="M11.7,14L11.7,14L11.7,14z"/><path d="M15.6,7.4L15.6,7.4L15.6,7.4z"/><path d="M15,9.4c0.2,0,0.4,0,0.6-0.2l0,0c0.1-0.1,0.2-0.2,0.2-0.4l0,0l0,0l0,0l0,0c0-0.3,0-0.6,0-0.9c0-0.2-0.1-0.4-0.2-0.5c-0.1-0.1-0.3-0.2-0.5-0.2s-0.4,0.1-0.5,0.2c-0.1,0.1-0.2,0.3-0.2,0.5l0,0c0,0.2,0,0.4,0,0.7l0,0v0.1c0,0.1,0,0.3,0.1,0.4l0,0C14.6,9.3,14.8,9.4,15,9.4L15,9.4L15,9.4z"/><path d="M14,12h0.1h0.2h0.1c0.2,0,0.5-0.2,0.6-0.4l0,0c0.2-0.3,0.3-0.6,0.4-0.9l0,0v-0.2c0-0.1-0.1-0.2-0.1-0.3c-0.1-0.2-0.2-0.3-0.4-0.4h-0.3c-0.1,0-0.2,0-0.3,0C14.2,9.9,14,10,14,10.3l0,0c-0.1,0.2-0.2,0.5-0.3,0.7l0,0c-0.1,0.1-0.1,0.2-0.1,0.3v0.2l0,0l0,0C13.6,11.6,13.8,11.8,14,12z"/><path d="M14.6,7.4L14.6,7.4L14.6,7.4z"/><path d="M4.4,14.2c-0.1,0.1-0.1,0.2-0.1,0.3l0.1,0.2c0,0.2,0.2,0.3,0.3,0.4l0,0c0.3,0.1,0.6,0.3,1.1,0.4l0,0h0.1l0,0c0.1,0,0.2-0.1,0.4-0.2c0.1,0,0.2-0.2,0.3-0.3l0,0v-0.2c0-0.1-0.1-0.3-0.2-0.4c-0.1-0.1-0.2-0.2-0.4-0.3l0,0c-0.2-0.1-0.5-0.2-0.7-0.3l0,0c-0.1,0-0.2,0-0.3,0H4.7l0,0C4.6,13.9,4.4,14,4.4,14.2L4.4,14.2z"/><path d="M11.9,13.3c0,0.2,0.1,0.4,0.2,0.6c0.1,0.1,0.3,0.2,0.5,0.2s0.4-0.1,0.5-0.2l0,0l0,0l0,0l0,0c0.1-0.1,0.3-0.3,0.4-0.4l0,0l0.2-0.3l0,0c0.1-0.2,0.2-0.3,0.2-0.5l0,0c0-0.2-0.1-0.4-0.2-0.5l0,0c-0.1-0.1-0.3-0.2-0.5-0.2l0,0c-0.2,0-0.4,0.1-0.5,0.2l0,0l-0.2,0.2l-0.4,0.4l0,0C12,13,11.9,13.1,11.9,13.3L11.9,13.3z"/><path d="M12.1,13.8L12.1,13.8L12.1,13.8z"/><path d="M11.9,13.3L11.9,13.3L11.9,13.3z"/><path d="M15.9,5.2c0-0.1-0.1-0.2-0.1-0.3l0,0L14,0.4l0,0C13.9,0.2,13.7,0,13.5,0l0,0l0,0h-0.2c-0.2,0-0.4,0.1-0.5,0.2l0,0l-0.9,0.9c-0.5-0.3-1.1-0.6-1.8-0.8l0,0C9.4,0.1,8.7,0,7.9,0c-1,0-2,0.2-3,0.6S3,1.6,2.3,2.3C1.6,3.1,1,3.9,0.6,4.9l0,0C0.2,5.8,0,6.8,0,7.9c0,1,0.2,2,0.6,3s0.9,1.8,1.7,2.6l0,0l0,0l0,0l0,0c0.2,0.2,0.5,0.4,0.7,0.6l0,0l0,0l0,0l0,0c0.2,0.1,0.3,0.2,0.5,0.2l0,0c0.2,0,0.4-0.1,0.6-0.3l0,0c0.1-0.1,0.1-0.3,0.1-0.4v-0.1l0,0C4.1,13.3,4,13.1,3.9,13l0,0c-0.2-0.1-0.4-0.3-0.6-0.5c-0.6-0.6-1.1-1.3-1.4-2.1l0,0C1.6,9.6,1.4,8.8,1.4,7.9s0.2-1.7,0.5-2.5l0,0c0.3-0.8,0.8-1.5,1.4-2.1c0.6-0.6,1.3-1.1,2.1-1.4l0,0C6.2,1.6,7,1.4,7.9,1.4c0.6,0,1.1,0.1,1.7,0.2c0.5,0.1,0.9,0.3,1.3,0.5l-0.8,0.8l0,0C10,3.1,9.9,3.2,9.9,3.4v0.2l0,0l0,0c0,0.2,0.2,0.4,0.4,0.5l0,0l4.5,1.8l0,0H15h0.1c0.2,0,0.4-0.1,0.5-0.2l0,0C15.7,5.6,15.8,5.4,15.9,5.2z M11.8,3.2L13,2l0.4,1.1l0,0c0.2,0.4,0.3,0.7,0.4,0.9L11.8,3.2z"/></g></svg>',
  mirror_horizontal: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 14.75 15.74"><g><path d="M13.75,3.76l5.9,15.74h-5.9V3.76ZM4.9,19.5,10.8,3.76V19.5H4.9Z" transform="translate(-4.9 -3.76)"/></g></svg>',
  mirror_vertical: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.74 14.75"><g><path d="M20.15,13.1,4.41,19V13.1H20.15ZM4.41,4.25l15.74,5.9H4.41V4.25Z" transform="translate(-4.41 -4.25)"/></g></svg>',
  checked: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.75 12.1"><g><path d="M4.59,12.23l.12.18L9.43,17.5a.58.58,0,0,0,.84,0L20,7.45h0a.58.58,0,0,0,0-.84l-.85-.85a.58.58,0,0,0-.84,0H18.2l-8.12,8.41a.29.29,0,0,1-.42,0l-3.4-3.63a.58.58,0,0,0-.84,0l-.85.85a.6.6,0,0,0-.14.21.51.51,0,0,0,0,.44c.05.06.1.13.16.19Z" transform="translate(-4.38 -5.58)"/></g></svg>',
  line_break: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19,6a1,1,0,0,0-1,1v4a1,1,0,0,1-1,1H7.41l1.3-1.29A1,1,0,0,0,7.29,9.29l-3,3a1,1,0,0,0-.21.33,1,1,0,0,0,0,.76,1,1,0,0,0,.21.33l3,3a1,1,0,0,0,1.42,0,1,1,0,0,0,0-1.42L7.41,14H17a3,3,0,0,0,3-3V7A1,1,0,0,0,19,6Z"/></svg>',
  audio: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M14,3.23V5.29C16.89,6.15 19,8.83 19,12C19,15.17 16.89,17.84 14,18.7V20.77C18,19.86 21,16.28 21,12C21,7.72 18,4.14 14,3.23M16.5,12C16.5,10.23 15.5,8.71 14,7.97V16C15.5,15.29 16.5,13.76 16.5,12M3,9V15H7L12,20V4L7,9H3Z" /></svg>',
  image_gallery: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="30 30 150 150"><g><path d="M152.775,120.548V51.651c0-12.271-9.984-22.254-22.254-22.254H43.727c-12.271,0-22.254,9.983-22.254,22.254v68.896c0,12.27,9.983,22.254,22.254,22.254h86.795C142.791,142.802,152.775,132.817,152.775,120.548z M36.394,51.651c0-4.042,3.291-7.333,7.333-7.333h86.795c4.042,0,7.332,3.291,7.332,7.333v23.917l-14.938-17.767c-1.41-1.678-3.487-2.649-5.68-2.658h-0.029c-2.184,0-4.255,0.954-5.674,2.613L76.709,98.519l-9.096-9.398c-1.427-1.474-3.392-2.291-5.448-2.273c-2.052,0.025-4.004,0.893-5.396,2.4L36.394,111.32V51.651z M41.684,127.585l20.697-22.416l9.312,9.622c1.461,1.511,3.489,2.334,5.592,2.27c2.101-0.066,4.075-1.013,5.44-2.612l34.436-40.308l20.693,24.613v21.794c0,4.042-3.29,7.332-7.332,7.332H43.727C43.018,127.88,42.334,127.775,41.684,127.585z M182.616,152.5V75.657c0-4.12-3.34-7.46-7.461-7.46c-4.119,0-7.46,3.34-7.46,7.46V152.5c0,4.112-3.347,7.46-7.461,7.46h-94c-4.119,0-7.46,3.339-7.46,7.459c0,4.123,3.341,7.462,7.46,7.462h94C172.576,174.881,182.616,164.841,182.616,152.5z"/></g></svg>',
  bookmark: '<svg viewBox="0 0 24 24"><path d="M17,3H7A2,2 0 0,0 5,5V21L12,18L19,21V5C19,3.89 18.1,3 17,3Z" /></svg>',
  download: '<svg viewBox="0 0 24 24"><path d="M2 12H4V17H20V12H22V17C22 18.11 21.11 19 20 19H4C2.9 19 2 18.11 2 17V12M12 15L17.55 9.54L16.13 8.13L13 11.25V2H11V11.25L7.88 8.13L6.46 9.55L12 15Z" /></svg>',
  dir_ltr: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M9 4v4c-1.1 0-2-.9-2-2s.9-2 2-2m8-2H9C6.79 2 5 3.79 5 6s1.79 4 4 4v5h2V4h2v11h2V4h2V2zm0 12v3H5v2h12v3l4-4-4-4z"/></svg>',
  dir_rtl: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0V0z" fill="none"/><path d="M10 4v4c-1.1 0-2-.9-2-2s.9-2 2-2m8-2h-8C7.79 2 6 3.79 6 6s1.79 4 4 4v5h2V4h2v11h2V4h2V2zM8 14l-4 4 4 4v-3h12v-2H8v-3z"/></svg>',
  // Error
  alert_outline: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M11,15H13V17H11V15M11,7H13V13H11V7M12,2C6.47,2 2,6.5 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4A8,8 0 0,1 20,12A8,8 0 0,1 12,20Z" /></svg>',
  // More icons
  more_text: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="10 10 180 180"><g><path d="M49.711,142.188h49.027c2.328,0.002,4.394,1.492,5.129,3.699l9.742,29.252c0.363,1.092,1.385,1.828,2.537,1.83l15.883,0.01c0.859,0,1.667-0.412,2.17-1.109s0.641-1.594,0.37-2.41l-16.625-50.045L86.503,28.953c-0.36-1.097-1.383-1.839-2.537-1.842H64.532c-1.153-0.001-2.178,0.736-2.542,1.831L13.847,173.457c-0.271,0.816-0.135,1.713,0.369,2.412c0.503,0.697,1.311,1.109,2.171,1.109h15.872c1.151,0,2.173-0.736,2.537-1.828l9.793-29.287C45.325,143.66,47.39,142.18,49.711,142.188L49.711,142.188z M53.493,119.098l15.607-46.9c0.744-2.196,2.806-3.674,5.125-3.674s4.381,1.478,5.125,3.674l15.607,46.904c0.537,1.621,0.263,3.402-0.736,4.789c-1.018,1.408-2.649,2.24-4.386,2.24H58.615c-1.736,0-3.368-0.832-4.386-2.24C53.23,122.504,52.956,120.721,53.493,119.098L53.493,119.098z M190.465,63.32c0-2.919-1.015-5.396-3.059-7.428c-2.029-2.031-4.496-3.047-7.383-3.047c-2.889,0-5.355,1.016-7.388,3.047c-2.029,2.032-3.056,4.498-3.056,7.386c0,2.889,1.026,5.354,3.056,7.385c2.032,2.032,4.499,3.059,7.388,3.059c2.887,0,5.354-1.026,7.383-3.059C189.45,68.633,190.465,66.178,190.465,63.32L190.465,63.32z M190.465,101.994c0-2.858-1.015-5.313-3.059-7.333c-2.029-2.042-4.496-3.047-7.383-3.047c-2.889,0-5.355,1.005-7.388,3.047c-2.029,2.021-3.056,4.486-3.056,7.376c0,2.887,1.026,5.352,3.056,7.395c2.032,2.021,4.499,3.047,7.388,3.047c2.887,0,5.354-1.025,7.383-3.047C189.45,107.389,190.465,104.914,190.465,101.994L190.465,101.994z M190.465,140.76c0-2.918-1.015-5.395-3.059-7.438c-2.029-2.041-4.496-3.047-7.383-3.047c-2.889,0-5.355,1.006-7.388,3.047c-2.029,2.043-3.056,4.52-3.056,7.438c0,2.922,1.026,5.398,3.056,7.439c2.032,2.021,4.499,3.047,7.388,3.047c2.887,0,5.354-1.025,7.383-3.047C189.45,146.158,190.465,143.682,190.465,140.76L190.465,140.76z"/></g></svg>',
  more_paragraph: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="10 10 180 180"><g><path d="M128.39,28.499H63.493c-25.558,0-46.354,20.796-46.354,46.354c0,25.559,20.796,46.353,46.354,46.353h9.271v55.625h18.542V47.04h9.271V176.83h18.543V47.04h9.271V28.499z M72.764,102.664h-9.271c-15.337,0-27.813-12.475-27.813-27.812c0-15.336,12.476-27.813,27.813-27.813h9.271V102.664z M190.465,63.32c0-2.919-1.015-5.396-3.059-7.428c-2.029-2.031-4.496-3.047-7.383-3.047c-2.889,0-5.355,1.016-7.388,3.047c-2.029,2.032-3.056,4.498-3.056,7.386c0,2.889,1.026,5.354,3.056,7.385c2.032,2.032,4.499,3.059,7.388,3.059c2.887,0,5.354-1.026,7.383-3.059C189.45,68.633,190.465,66.178,190.465,63.32L190.465,63.32z M190.465,101.994c0-2.858-1.015-5.313-3.059-7.333c-2.029-2.042-4.496-3.047-7.383-3.047c-2.889,0-5.355,1.005-7.388,3.047c-2.029,2.021-3.056,4.486-3.056,7.376c0,2.887,1.026,5.352,3.056,7.395c2.032,2.021,4.499,3.047,7.388,3.047c2.887,0,5.354-1.025,7.383-3.047C189.45,107.389,190.465,104.914,190.465,101.994L190.465,101.994z M190.465,140.76c0-2.918-1.015-5.395-3.059-7.438c-2.029-2.041-4.496-3.047-7.383-3.047c-2.889,0-5.355,1.006-7.388,3.047c-2.029,2.043-3.056,4.52-3.056,7.438c0,2.922,1.026,5.398,3.056,7.439c2.032,2.021,4.499,3.047,7.388,3.047c2.887,0,5.354-1.025,7.383-3.047C189.45,146.158,190.465,143.682,190.465,140.76L190.465,140.76z"/></g></svg>',
  more_plus: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="35 30 140 140"><g><path d="M137.215,102.045c0,3.498-2.835,6.332-6.333,6.332H24.549c-3.498,0-6.334-2.834-6.334-6.332l0,0c0-3.498,2.836-6.333,6.334-6.333h106.333C134.38,95.711,137.215,98.547,137.215,102.045L137.215,102.045z M77.715,161.545c-3.498,0-6.333-2.836-6.333-6.334V48.878c0-3.498,2.836-6.333,6.333-6.333l0,0c3.498,0,6.334,2.835,6.334,6.333v106.333C84.049,158.709,81.213,161.545,77.715,161.545L77.715,161.545z M190.465,63.32c0-2.919-1.015-5.396-3.059-7.428c-2.029-2.031-4.496-3.047-7.383-3.047c-2.889,0-5.355,1.016-7.388,3.047c-2.029,2.032-3.056,4.498-3.056,7.386c0,2.889,1.026,5.354,3.056,7.385c2.032,2.032,4.499,3.059,7.388,3.059c2.887,0,5.354-1.026,7.383-3.059C189.45,68.632,190.465,66.177,190.465,63.32L190.465,63.32z M190.465,101.993c0-2.858-1.015-5.313-3.059-7.333c-2.029-2.042-4.496-3.047-7.383-3.047c-2.889,0-5.355,1.005-7.388,3.047c-2.029,2.021-3.056,4.486-3.056,7.376c0,2.888,1.026,5.353,3.056,7.396c2.032,2.021,4.499,3.047,7.388,3.047c2.887,0,5.354-1.025,7.383-3.047C189.45,107.389,190.465,104.914,190.465,101.993L190.465,101.993z M190.465,140.76c0-2.918-1.015-5.395-3.059-7.438c-2.029-2.041-4.496-3.047-7.383-3.047c-2.889,0-5.355,1.006-7.388,3.047c-2.029,2.043-3.056,4.52-3.056,7.438c0,2.922,1.026,5.398,3.056,7.439c2.032,2.021,4.499,3.047,7.388,3.047c2.887,0,5.354-1.025,7.383-3.047C189.45,146.158,190.465,143.682,190.465,140.76L190.465,140.76z"/></g></svg>',
  more_horizontal: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.76 3.58"><g><path d="M4.64,10.73a1.84,1.84,0,0,1,.65-.65,1.76,1.76,0,0,1,1.79,0A1.79,1.79,0,0,1,8,11.63a1.84,1.84,0,0,1-.25.9,1.69,1.69,0,0,1-.65.65,1.8,1.8,0,0,1-2.69-1.55A2.08,2.08,0,0,1,4.64,10.73Zm6.09,0a1.84,1.84,0,0,1,.65-.65,1.78,1.78,0,0,1,2.67,1.55,1.73,1.73,0,0,1-.24.9,1.84,1.84,0,0,1-.65.65,1.76,1.76,0,0,1-1.79,0,1.79,1.79,0,0,1-.64-2.44Zm6.08,0a1.69,1.69,0,0,1,.65-.65,1.76,1.76,0,0,1,1.79,0,1.79,1.79,0,0,1,.9,1.54,1.73,1.73,0,0,1-.24.9,1.84,1.84,0,0,1-.65.65,1.8,1.8,0,0,1-2.69-1.55A2,2,0,0,1,16.81,10.73Z" transform="translate(-4.39 -9.84)"/></g></svg>',
  more_vertical: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 3.94 15.75"><g><path d="M12.28,7.69a1.92,1.92,0,0,1-1.39-.58,2,2,0,0,1-.58-1.39,1.92,1.92,0,0,1,.58-1.39,2,2,0,0,1,1.39-.58,1.92,1.92,0,0,1,1.39.58,2,2,0,0,1,.58,1.39,1.92,1.92,0,0,1-.58,1.39,2,2,0,0,1-1.39.58Zm0,2a1.92,1.92,0,0,1,1.39.58,2,2,0,0,1,.58,1.39A1.92,1.92,0,0,1,13.67,13a2,2,0,0,1-1.39.58A1.92,1.92,0,0,1,10.89,13a2,2,0,0,1-.58-1.39,2,2,0,0,1,2-2Zm0,5.9a1.92,1.92,0,0,1,1.39.58,2,2,0,0,1,.58,1.39,1.92,1.92,0,0,1-.58,1.39,2,2,0,0,1-1.39.58,1.92,1.92,0,0,1-1.39-.58,2,2,0,0,1-.58-1.39,1.92,1.92,0,0,1,.58-1.39,1.94,1.94,0,0,1,1.39-.58Z" transform="translate(-10.31 -3.75)"/></g></svg>',
  // Not currently used
  attachment: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 8.38 15.68"><g><path d="M15.23,6h1v9.78a3.88,3.88,0,0,1-1.31,2.45,4,4,0,0,1-6.57-2.45V7A3,3,0,0,1,9.2,4.89a3,3,0,0,1,5,2.09v8.31a1.92,1.92,0,0,1-.58,1.39,2,2,0,0,1-1.39.58,1.92,1.92,0,0,1-1.39-.58,2,2,0,0,1-.58-1.39V8h1v7.32a1,1,0,0,0,.29.69,1,1,0,0,0,.69.28A.9.9,0,0,0,13,16a1,1,0,0,0,.29-.69V7a1.92,1.92,0,0,0-.58-1.39A2,2,0,0,0,11.27,5a1.92,1.92,0,0,0-1.39.58A2,2,0,0,0,9.33,7v8.31a3,3,0,1,0,5.9,0V6Z" transform="translate(-8.08 -3.78)"/></g></svg>',
  map: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 11.7 15.62"><g><path d="M12.05,12.42a2.93,2.93,0,1,1,2.07-5A2.88,2.88,0,0,1,15,9.49a3,3,0,0,1-.86,2.07,2.89,2.89,0,0,1-2.07.86Zm0-5.36a2.43,2.43,0,0,0-1.72,4.16,2.48,2.48,0,0,0,1.72.72,2.44,2.44,0,0,0,0-4.88Zm0-3.3A5.84,5.84,0,0,1,17.9,9.62a9.94,9.94,0,0,1-1.73,5A33.59,33.59,0,0,1,12.84,19a1.52,1.52,0,0,1-.23.2,1,1,0,0,1-.55.2h0a1,1,0,0,1-.55-.2,1.52,1.52,0,0,1-.23-.2,33.59,33.59,0,0,1-3.33-4.32,9.93,9.93,0,0,1-1.72-5,5.84,5.84,0,0,1,5.85-5.86ZM12,18.34l.08.05.06-.06a35.58,35.58,0,0,0,3.06-3.93,9.35,9.35,0,0,0,1.74-4.77,4.88,4.88,0,0,0-4.88-4.88A4.79,4.79,0,0,0,8.6,6.17,4.84,4.84,0,0,0,7.17,9.62,9.29,9.29,0,0,0,8.91,14.4,36,36,0,0,0,12,18.34Z" transform="translate(-6.2 -3.76)"/></g></svg>',
  magic_stick: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.73 15.75"><g><path d="M19.86,19.21a1,1,0,0,0,.28-.68,1,1,0,0,0-.28-.7L13,10.93a1,1,0,0,0-.7-.28,1,1,0,0,0-.68,1.65l6.9,6.9a1,1,0,0,0,.69.29.93.93,0,0,0,.69-.28ZM9.19,8.55a3,3,0,0,0,1.68,0,14.12,14.12,0,0,0,1.41-.32A11.26,11.26,0,0,0,10.8,7.06c-.56-.36-.86-.56-.91-.58S10,5.91,10,5.11s0-1.26-.15-1.37a4.35,4.35,0,0,0-1.19.71c-.53.4-.81.62-.87.68a9,9,0,0,0-2-.6,6.84,6.84,0,0,0-.76-.09s0,.27.08.77a8.6,8.6,0,0,0,.61,2q-.09.09-.69.87a3.59,3.59,0,0,0-.68,1.17c.12.17.57.23,1.36.15S7,9.26,7.15,9.23s.21.36.57.91a10.49,10.49,0,0,0,1.14,1.48c0-.1.14-.57.31-1.4a3,3,0,0,0,0-1.67Z" transform="translate(-4.41 -3.74)"/></g></svg>',
  empty_file: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12.78 15.75"><g><path d="M14.73,3.76,18.67,7.7v9.84a2,2,0,0,1-2,2H7.84a1.89,1.89,0,0,1-1.38-.58,2,2,0,0,1-.57-1.39V5.73a1.93,1.93,0,0,1,.57-1.38,2,2,0,0,1,1.38-.58h6.62l.26,0v0Zm2.95,4.92h-2a1.93,1.93,0,0,1-1.38-.57,2,2,0,0,1-.58-1.4V6.17c0-.36,0-.84,0-1.43H7.85a1,1,0,0,0-.7.29,1,1,0,0,0-.29.7V17.54a1,1,0,0,0,.29.69,1,1,0,0,0,.69.29h8.85a1,1,0,0,0,.71-.29.92.92,0,0,0,.28-.69Zm0-1L14.73,4.74v2A1,1,0,0,0,15,7.4a1,1,0,0,0,.69.29Z" transform="translate(-5.89 -3.76)"/></g></svg>'
});
// EXTERNAL MODULE: ./node_modules/suneditor/src/lang/en.js
var en = __webpack_require__(707);
var en_default = /*#__PURE__*/__webpack_require__.n(en);

// CONCATENATED MODULE: ./node_modules/suneditor/src/lib/util.js
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2017 JiHong Lee.
 * MIT license.
 */


/**
 * @description utility function
 */
var util_util = {
  _d: null,
  _w: null,
  isIE: null,
  isIE_Edge: null,
  isOSX_IOS: null,
  isChromium: null,
  _propertiesInit: function _propertiesInit() {
    if (this._d) return;
    this._d = document;
    this._w = window;
    this.isIE = navigator.userAgent.indexOf('Trident') > -1;
    this.isIE_Edge = navigator.userAgent.indexOf('Trident') > -1 || navigator.appVersion.indexOf('Edge') > -1;
    this.isOSX_IOS = /(Mac|iPhone|iPod|iPad)/.test(navigator.platform);
    this.isChromium = !!window.chrome;
  },
  _allowedEmptyNodeList: '.se-component, pre, blockquote, hr, li, table, img, iframe, video, audio, canvas',
  /**
   * @description HTML Reserved Word Converter.
   * @param {String} contents 
   * @returns {String} HTML string
   * @private
   */
  _HTMLConvertor: function _HTMLConvertor(contents) {
    var ec = {
      '&': '&amp;',
      "\xA0": '&nbsp;',
      '\'': '&apos;',
      '"': '&quot;',
      '<': '&lt;',
      '>': '&gt;'
    };
    return contents.replace(/&|\u00A0|'|"|<|>/g, function (m) {
      return typeof ec[m] === 'string' ? ec[m] : m;
    });
  },
  /**
   * @description Unicode Character 'ZERO WIDTH SPACE' (\u200B)
   */
  zeroWidthSpace: String.fromCharCode(8203),
  /**
   * @description Regular expression to find 'zero width space' (/\u200B/g)
   */
  zeroWidthRegExp: new RegExp(String.fromCharCode(8203), 'g'),
  /**
   * @description Regular expression to find only 'zero width space' (/^\u200B+$/)
   */
  onlyZeroWidthRegExp: new RegExp('^' + String.fromCharCode(8203) + '+$'),
  /**
   * @description A method that checks If the text is blank or to see if it contains 'ZERO WIDTH SPACE' or empty (util.zeroWidthSpace)
   * @param {String|Node} text String value or Node
   * @returns {Boolean}
   */
  onlyZeroWidthSpace: function onlyZeroWidthSpace(text) {
    if (text === null || text === undefined) return false;
    if (typeof text !== 'string') text = text.textContent;
    return text === '' || this.onlyZeroWidthRegExp.test(text);
  },
  /**
   * @description Gets XMLHttpRequest object
   * @returns {XMLHttpRequest|ActiveXObject}
   */
  getXMLHttpRequest: function getXMLHttpRequest() {
    /** IE */
    if (this._w.ActiveXObject) {
      try {
        return new ActiveXObject('Msxml2.XMLHTTP');
      } catch (e) {
        try {
          return new ActiveXObject('Microsoft.XMLHTTP');
        } catch (e1) {
          return null;
        }
      }
    }
    /** netscape */else if (this._w.XMLHttpRequest) {
      return new XMLHttpRequest();
    }
    /** fail */else {
      return null;
    }
  },
  /**
   * @description Object.values
   * @param {Object|null} obj Object parameter.
   * @returns {Array}
   */
  getValues: function getValues(obj) {
    return !obj ? [] : this._w.Object.keys(obj).map(function (i) {
      return obj[i];
    });
  },
  /**
   * @description Convert the CamelCase To the KebabCase.
   * @param {String|Array} param [Camel string]
   * @returns {String|Array}
   */
  camelToKebabCase: function camelToKebabCase(param) {
    if (typeof param === 'string') {
      return param.replace(/[A-Z]/g, function (letter) {
        return "-" + letter.toLowerCase();
      });
    } else {
      return param.map(function (str) {
        return util_util.camelToKebabCase(str);
      });
    }
  },
  /**
   * @description Convert the KebabCase To the CamelCase.
   * @param {String|Array} param [KebabCase string]
   * @returns {String|Array}
   */
  kebabToCamelCase: function kebabToCamelCase(param) {
    if (typeof param === 'string') {
      return param.replace(/-[a-zA-Z]/g, function (letter) {
        return letter.replace('-', '').toUpperCase();
      });
    } else {
      return param.map(function (str) {
        return util_util.camelToKebabCase(str);
      });
    }
  },
  /**
   * @description Create Element node
   * @param {String} elementName Element name
   * @returns {Element}
   */
  createElement: function createElement(elementName) {
    return this._d.createElement(elementName);
  },
  /**
   * @description Create text node
   * @param {String} text text contents
   * @returns {Node}
   */
  createTextNode: function createTextNode(text) {
    return this._d.createTextNode(text || '');
  },
  /**
   * @description The editor checks tags by string.
   * If there is "<" or ">" in the attribute of tag, HTML is broken when checking the tag.
   * When using an attribute with "<" or ">", use "HTMLEncoder" to save. (ex: math(katex))
   * @param {String} contents HTML or Text string
   * @returns {String}
   */
  HTMLEncoder: function HTMLEncoder(contents) {
    var ec = {
      '<': '$lt;',
      '>': '$gt;'
    };
    return contents.replace(/<|>/g, function (m) {
      return typeof ec[m] === 'string' ? ec[m] : m;
    });
  },
  /**
   * @description The editor checks tags by string.
   * If there is "<" or ">" in the attribute of tag, HTML is broken when checking the tag.
   * Decoder of data stored as "HTMLEncoder" (ex: math(katex))
   * @param {String} contents HTML or Text string
   * @returns {String}
   */
  HTMLDecoder: function HTMLDecoder(contents) {
    var ec = {
      '$lt;': '<',
      '$gt;': '>'
    };
    return contents.replace(/\$lt;|\$gt;/g, function (m) {
      return typeof ec[m] === 'string' ? ec[m] : m;
    });
  },
  /**
   * @description This method run Object.prototype.hasOwnProperty.call(obj, key)
   * @param {Object} obj Object
   * @param {String} key obj.key
   * @returns {Boolean}
   */
  hasOwn: function hasOwn(obj, key) {
    return this._hasOwn.call(obj, key);
  },
  _hasOwn: Object.prototype.hasOwnProperty,
  /**
   * @deprecated
   * @description Get the the tag path of the arguments value
   * If not found, return the first found value
   * @param {Array} nameArray File name array
   * @param {String} extension js, css
   * @returns {String}
   */
  getIncludePath: function getIncludePath(nameArray, extension) {
    var path = '';
    var pathList = [];
    var tagName = extension === 'js' ? 'script' : 'link';
    var src = extension === 'js' ? 'src' : 'href';
    var fileName = '(?:';
    for (var i = 0, len = nameArray.length; i < len; i++) {
      fileName += nameArray[i] + (i < len - 1 ? '|' : ')');
    }
    var regExp = new this._w.RegExp('(^|.*[\\/])' + fileName + '(\\.[^\\/]+)?\.' + extension + '(?:\\?.*|;.*)?$', 'i');
    var extRegExp = new this._w.RegExp('.+\\.' + extension + '(?:\\?.*|;.*)?$', 'i');
    for (var c = this._d.getElementsByTagName(tagName), _i = 0; _i < c.length; _i++) {
      if (extRegExp.test(c[_i][src])) {
        pathList.push(c[_i]);
      }
    }
    for (var _i2 = 0; _i2 < pathList.length; _i2++) {
      var editorTag = pathList[_i2][src].match(regExp);
      if (editorTag) {
        path = editorTag[0];
        break;
      }
    }
    if (path === '') path = pathList.length > 0 ? pathList[0][src] : '';
    -1 === path.indexOf(':/') && '//' !== path.slice(0, 2) && (path = 0 === path.indexOf('/') ? location.href.match(/^.*?:\/\/[^\/]*/)[0] + path : location.href.match(/^[^\?]*\/(?:)/)[0] + path);
    if (!path) throw '[SUNEDITOR.util.getIncludePath.fail] The SUNEDITOR installation path could not be automatically detected. (name: +' + name + ', extension: ' + extension + ')';
    return path;
  },
  /**
   * @deprecated
   * @description Returns the CSS text that has been applied to the current page.
   * @param {Document|null} doc To get the CSS text of an document(core._wd). If null get the current document.
   * @returns {String} Styles string
   */
  getPageStyle: function getPageStyle(doc) {
    var cssText = '';
    var sheets = (doc || this._d).styleSheets;
    for (var i = 0, len = sheets.length, rules; i < len; i++) {
      try {
        rules = sheets[i].cssRules;
      } catch (e) {
        continue;
      }
      if (rules) {
        for (var c = 0, cLen = rules.length; c < cLen; c++) {
          cssText += rules[c].cssText;
        }
      }
    }
    return cssText;
  },
  /**
   * @description Get the argument iframe's document object
   * @param {Element} iframe Iframe element (context.element.wysiwygFrame)
   * @returns {Document}
   */
  getIframeDocument: function getIframeDocument(iframe) {
    var wDocument = iframe.contentWindow || iframe.contentDocument;
    if (wDocument.document) wDocument = wDocument.document;
    return wDocument;
  },
  /**
   * @description Get attributes of argument element to string ('class="---" name="---" ')
   * @param {Element} element Element object
   * @param {Array|null} exceptAttrs Array of attribute names to exclude from the result
   * @returns {String}
   */
  getAttributesToString: function getAttributesToString(element, exceptAttrs) {
    if (!element.attributes) return '';
    var attrs = element.attributes;
    var attrString = '';
    for (var i = 0, len = attrs.length; i < len; i++) {
      if (exceptAttrs && exceptAttrs.indexOf(attrs[i].name) > -1) continue;
      attrString += attrs[i].name + '="' + attrs[i].value + '" ';
    }
    return attrString;
  },
  /**
   * @descriptionGets Get the length in bytes of a string.
   * referencing code: "https://github.com/shaan1974/myrdin/blob/master/expressions/string.js#L11"
   * @param {String} text String text
   * @returns {Number}
   */
  getByteLength: function getByteLength(text) {
    if (!text || !text.toString) return 0;
    text = text.toString();
    var encoder = this._w.encodeURIComponent;
    var cr, cl;
    if (this.isIE_Edge) {
      cl = this._w.unescape(encoder(text)).length;
      cr = 0;
      if (encoder(text).match(/(%0A|%0D)/gi) !== null) {
        cr = encoder(text).match(/(%0A|%0D)/gi).length;
      }
      return cl + cr;
    } else {
      cl = new this._w.TextEncoder('utf-8').encode(text).length;
      cr = 0;
      if (encoder(text).match(/(%0A|%0D)/gi) !== null) {
        cr = encoder(text).match(/(%0A|%0D)/gi).length;
      }
      return cl + cr;
    }
  },
  /**
   * @description It is judged whether it is the edit region top div element or iframe's body tag.
   * @param {Node} element The node to check
   * @returns {Boolean}
   */
  isWysiwygDiv: function isWysiwygDiv(element) {
    return element && element.nodeType === 1 && (this.hasClass(element, 'se-wrapper-wysiwyg') || /^BODY$/i.test(element.nodeName));
  },
  /**
   * @description It is judged whether it is the contenteditable property is false.
   * @param {Node} element The node to check
   * @returns {Boolean}
   */
  isNonEditable: function isNonEditable(element) {
    return element && element.nodeType === 1 && element.getAttribute('contenteditable') === 'false';
  },
  /**
   * @description It is judged whether it is a node related to the text style.
   * (strong|span|font|b|var|i|em|u|ins|s|strike|del|sub|sup|mark|a|label|code)
   * @param {Node} element The node to check
   * @returns {Boolean}
   */
  isTextStyleElement: function isTextStyleElement(element) {
    return element && element.nodeType !== 3 && /^(strong|span|font|b|var|i|em|u|ins|s|strike|del|sub|sup|mark|a|label|code|summary)$/i.test(element.nodeName);
  },
  /**
   * @description It is judged whether it is the format element (P, DIV, H[1-6], PRE, LI | class="__se__format__replace_xxx")
   * Format element also contain "free format Element"
   * @param {Node} element The node to check
   * @returns {Boolean}
   */
  isFormatElement: function isFormatElement(element) {
    return element && element.nodeType === 1 && (/^(P|DIV|H[1-6]|PRE|LI|TH|TD|DETAILS)$/i.test(element.nodeName) || this.hasClass(element, '(\\s|^)__se__format__replace_.+(\\s|$)|(\\s|^)__se__format__free_.+(\\s|$)')) && !this.isComponent(element) && !this.isWysiwygDiv(element);
  },
  /**
   * @description It is judged whether it is the range format element. (BLOCKQUOTE, OL, UL, FIGCAPTION, TABLE, THEAD, TBODY, TR, TH, TD | class="__se__format__range_xxx")
   * Range format element is wrap the "format element" and "component"
   * @param {Node} element The node to check
   * @returns {Boolean}
   */
  isRangeFormatElement: function isRangeFormatElement(element) {
    return element && element.nodeType === 1 && (/^(BLOCKQUOTE|OL|UL|FIGCAPTION|TABLE|THEAD|TBODY|TR|TH|TD|DETAILS)$/i.test(element.nodeName) || this.hasClass(element, '(\\s|^)__se__format__range_.+(\\s|$)'));
  },
  /**
   * @description It is judged whether it is the closure range format element. (TH, TD | class="__se__format__range__closure_xxx")
   * Closure range format elements is included in the range format element.
   *  - Closure range format element is wrap the "format element" and "component"
   * ※ You cannot exit this format with the Enter key or Backspace key.
   * ※ Use it only in special cases. ([ex] format of table cells)
   * @param {Node} element The node to check
   * @returns {Boolean}
   */
  isClosureRangeFormatElement: function isClosureRangeFormatElement(element) {
    return element && element.nodeType === 1 && (/^(TH|TD)$/i.test(element.nodeName) || this.hasClass(element, '(\\s|^)__se__format__range__closure_.+(\\s|$)'));
  },
  /**
   * @description It is judged whether it is the free format element. (PRE | class="__se__format__free_xxx")
   * Free format elements is included in the format element.
   * Free format elements's line break is "BR" tag.
   * ※ Entering the Enter key in the space on the last line ends "Free Format" and appends "Format".
   * @param {Node} element The node to check
   * @returns {Boolean}
   */
  isFreeFormatElement: function isFreeFormatElement(element) {
    return element && element.nodeType === 1 && (/^PRE$/i.test(element.nodeName) || this.hasClass(element, '(\\s|^)__se__format__free_.+(\\s|$)')) && !this.isComponent(element) && !this.isWysiwygDiv(element);
  },
  /**
   * @description It is judged whether it is the closure free format element. (class="__se__format__free__closure_xxx")
   * Closure free format elements is included in the free format element.
   *  - Closure free format elements's line break is "BR" tag.
   * ※ You cannot exit this format with the Enter key or Backspace key.
   * ※ Use it only in special cases. ([ex] format of table cells)
   * @param {Node} element The node to check
   * @returns {Boolean}
   */
  isClosureFreeFormatElement: function isClosureFreeFormatElement(element) {
    return element && element.nodeType === 1 && this.hasClass(element, '(\\s|^)__se__format__free__closure_.+(\\s|$)');
  },
  /**
   * @description It is judged whether it is the component[img, iframe, video, audio, table] cover(class="se-component") and table, hr
   * @param {Node} element The node to check
   * @returns {Boolean}
   */
  isComponent: function isComponent(element) {
    return element && (/se-component/.test(element.className) || /^(TABLE|HR)$/.test(element.nodeName));
  },
  /**
   * @description Checks for "__se__uneditable" in the class list.
   * Components with class "__se__uneditable" cannot be modified.
   * @param {Element} element The element to check
   * @returns {Boolean}
   */
  isUneditableComponent: function isUneditableComponent(element) {
    return element && this.hasClass(element, '__se__uneditable');
  },
  /**
   * @description It is judged whether it is the component [img, iframe] cover(class="se-component")
   * @param {Node} element The node to check
   * @returns {Boolean}
   */
  isMediaComponent: function isMediaComponent(element) {
    return element && /se-component/.test(element.className);
  },
  /**
   * @description It is judged whether it is the not checking node. (class="katex", "__se__tag")
   * @param {Node} element The node to check
   * @returns {Boolean}
   */
  isNotCheckingNode: function isNotCheckingNode(element) {
    return element && /katex|__se__tag/.test(element.className);
  },
  /**
   * @description If a parent node that contains an argument node finds a format node (util.isFormatElement), it returns that node.
   * @param {Node} element Reference node.
   * @param {Function|null} validation Additional validation function.
   * @returns {Element|null}
   */
  getFormatElement: function getFormatElement(element, validation) {
    if (!element) return null;
    if (!validation) {
      validation = function validation() {
        return true;
      };
    }
    while (element) {
      if (this.isWysiwygDiv(element)) return null;
      if (this.isRangeFormatElement(element)) element.firstElementChild;
      if (this.isFormatElement(element) && validation(element)) return element;
      element = element.parentNode;
    }
    return null;
  },
  /**
   * @description If a parent node that contains an argument node finds a format node (util.isRangeFormatElement), it returns that node.
   * @param {Node} element Reference node.
   * @param {Function|null} validation Additional validation function.
   * @returns {Element|null}
   */
  getRangeFormatElement: function getRangeFormatElement(element, validation) {
    if (!element) return null;
    if (!validation) {
      validation = function validation() {
        return true;
      };
    }
    while (element) {
      if (this.isWysiwygDiv(element)) return null;
      if (this.isRangeFormatElement(element) && !/^(THEAD|TBODY|TR)$/i.test(element.nodeName) && validation(element)) return element;
      element = element.parentNode;
    }
    return null;
  },
  /**
   * @description If a parent node that contains an argument node finds a free format node (util.isFreeFormatElement), it returns that node.
   * @param {Node} element Reference node.
   * @param {Function|null} validation Additional validation function.
   * @returns {Element|null}
   */
  getFreeFormatElement: function getFreeFormatElement(element, validation) {
    if (!element) return null;
    if (!validation) {
      validation = function validation() {
        return true;
      };
    }
    while (element) {
      if (this.isWysiwygDiv(element)) return null;
      if (this.isFreeFormatElement(element) && validation(element)) return element;
      element = element.parentNode;
    }
    return null;
  },
  /**
   * @description If a parent node that contains an argument node finds a closure free format node (util.isClosureFreeFormatElement), it returns that node.
   * @param {Node} element Reference node.
   * @param {Function|null} validation Additional validation function.
   * @returns {Element|null}
   */
  getClosureFreeFormatElement: function getClosureFreeFormatElement(element, validation) {
    if (!element) return null;
    if (!validation) {
      validation = function validation() {
        return true;
      };
    }
    while (element) {
      if (this.isWysiwygDiv(element)) return null;
      if (this.isClosureFreeFormatElement(element) && validation(element)) return element;
      element = element.parentNode;
    }
    return null;
  },
  /**
   * @description Add style and className of copyEl to originEl
   * @param {Element} originEl Origin element
   * @param {Element} copyEl Element to copy
   */
  copyTagAttributes: function copyTagAttributes(originEl, copyEl) {
    if (copyEl.style.cssText) {
      originEl.style.cssText += copyEl.style.cssText;
    }
    var classes = copyEl.classList;
    for (var i = 0, len = classes.length; i < len; i++) {
      this.addClass(originEl, classes[i]);
    }
    if (!originEl.style.cssText) originEl.removeAttribute('style');
    if (!originEl.className.trim()) originEl.removeAttribute('class');
  },
  /**
   * @description Copy and apply attributes of format tag that should be maintained. (style, class) Ignore "__se__format__" class
   * @param {Element} originEl Origin element
   * @param {Element} copyEl Element to copy
   */
  copyFormatAttributes: function copyFormatAttributes(originEl, copyEl) {
    copyEl = copyEl.cloneNode(false);
    copyEl.className = copyEl.className.replace(/(\s|^)__se__format__[^\s]+/g, '');
    this.copyTagAttributes(originEl, copyEl);
  },
  /**
   * @description Get the item from the array that matches the condition.
   * @param {Array|HTMLCollection|NodeList} array Array to get item
   * @param {Function|null} validation Conditional function
   * @param {Boolean} multi If true, returns all items that meet the criteria otherwise, returns an empty array.
   * If false, returns only one item that meet the criteria otherwise return null.
   * @returns {Array|Node|null}
   */
  getArrayItem: function getArrayItem(array, validation, multi) {
    if (!array || array.length === 0) return null;
    validation = validation || function () {
      return true;
    };
    var arr = [];
    for (var i = 0, len = array.length, a; i < len; i++) {
      a = array[i];
      if (validation(a)) {
        if (!multi) return a;else arr.push(a);
      }
    }
    return !multi ? null : arr;
  },
  /**
   * @description Check if an array contains an element 
   * @param {Array|HTMLCollection|NodeList} array element array
   * @param {Node} element The element to check for
   * @returns {Boolean}
   */
  arrayIncludes: function arrayIncludes(array, element) {
    for (var i = 0; i < array.length; i++) {
      if (array[i] === element) {
        return true;
      }
    }
    return false;
  },
  /**
   * @description Get the index of the argument value in the element array
   * @param {Array|HTMLCollection|NodeList} array element array
   * @param {Node} element The element to find index
   * @returns {Number}
   */
  getArrayIndex: function getArrayIndex(array, element) {
    var idx = -1;
    for (var i = 0, len = array.length; i < len; i++) {
      if (array[i] === element) {
        idx = i;
        break;
      }
    }
    return idx;
  },
  /**
   * @description Get the next index of the argument value in the element array
   * @param {Array|HTMLCollection|NodeList} array element array
   * @param {Node} item The element to find index
   * @returns {Number}
   */
  nextIdx: function nextIdx(array, item) {
    var idx = this.getArrayIndex(array, item);
    if (idx === -1) return -1;
    return idx + 1;
  },
  /**
   * @description Get the previous index of the argument value in the element array
   * @param {Array|HTMLCollection|NodeList} array Element array
   * @param {Node} item The element to find index
   * @returns {Number}
   */
  prevIdx: function prevIdx(array, item) {
    var idx = this.getArrayIndex(array, item);
    if (idx === -1) return -1;
    return idx - 1;
  },
  /**
   * @description Returns the index compared to other sibling nodes.
   * @param {Node} node The Node to find index
   * @returns {Number}
   */
  getPositionIndex: function getPositionIndex(node) {
    var idx = 0;
    while (node = node.previousSibling) {
      idx += 1;
    }
    return idx;
  },
  /**
   * @description Returns the position of the "node" in the "parentNode" in a numerical array.
   * ex) <p><span>aa</span><span>bb</span></p> : getNodePath(node: "bb", parentNode: "<P>") -> [1, 0]
   * @param {Node} node The Node to find position path
   * @param {Node|null} parentNode Parent node. If null, wysiwyg div area
   * @param {Object|null} _newOffsets If you send an object of the form "{s: 0, e: 0}", the text nodes that are attached together are merged into one, centered on the "node" argument.
   * "_newOffsets.s" stores the length of the combined characters after "node" and "_newOffsets.e" stores the length of the combined characters before "node".
   * Do not use unless absolutely necessary.
   * @returns {Array}
   */
  getNodePath: function getNodePath(node, parentNode, _newOffsets) {
    var path = [];
    var finds = true;
    this.getParentElement(node, function (el) {
      if (el === parentNode) finds = false;
      if (finds && !this.isWysiwygDiv(el)) {
        // merge text nodes
        if (_newOffsets && el.nodeType === 3) {
          var temp = null,
            tempText = null;
          _newOffsets.s = _newOffsets.e = 0;
          var previous = el.previousSibling;
          while (previous && previous.nodeType === 3) {
            tempText = previous.textContent.replace(this.zeroWidthRegExp, '');
            _newOffsets.s += tempText.length;
            el.textContent = tempText + el.textContent;
            temp = previous;
            previous = previous.previousSibling;
            this.removeItem(temp);
          }
          var next = el.nextSibling;
          while (next && next.nodeType === 3) {
            tempText = next.textContent.replace(this.zeroWidthRegExp, '');
            _newOffsets.e += tempText.length;
            el.textContent += tempText;
            temp = next;
            next = next.nextSibling;
            this.removeItem(temp);
          }
        }

        // index push
        path.push(el);
      }
      return false;
    }.bind(this));
    return path.map(this.getPositionIndex).reverse();
  },
  /**
   * @description Returns the node in the location of the path array obtained from "util.getNodePath".
   * @param {Array} offsets Position array, array obtained from "util.getNodePath"
   * @param {Node} parentNode Base parent element
   * @returns {Node}
   */
  getNodeFromPath: function getNodeFromPath(offsets, parentNode) {
    var current = parentNode;
    var nodes;
    for (var i = 0, len = offsets.length; i < len; i++) {
      nodes = current.childNodes;
      if (nodes.length === 0) break;
      if (nodes.length <= offsets[i]) {
        current = nodes[nodes.length - 1];
      } else {
        current = nodes[offsets[i]];
      }
    }
    return current;
  },
  /**
   * @description Compares the style and class for equal values.
   * Returns true if both are text nodes.
   * @param {Node} a Node to compare
   * @param {Node} b Node to compare
   * @returns {Boolean}
   */
  isSameAttributes: function isSameAttributes(a, b) {
    if (a.nodeType === 3 && b.nodeType === 3) return true;
    if (a.nodeType === 3 || b.nodeType === 3) return false;
    var style_a = a.style;
    var style_b = b.style;
    var compStyle = 0;
    for (var i = 0, len = style_a.length; i < len; i++) {
      if (style_a[style_a[i]] === style_b[style_a[i]]) compStyle++;
    }
    var class_a = a.classList;
    var class_b = b.classList;
    var reg = this._w.RegExp;
    var compClass = 0;
    for (var _i3 = 0, _len = class_a.length; _i3 < _len; _i3++) {
      if (reg('(\s|^)' + class_a[_i3] + '(\s|$)').test(class_b.value)) compClass++;
    }
    return compStyle === style_b.length && compStyle === style_a.length && compClass === class_b.length && compClass === class_a.length;
  },
  /**
   * @description Check the line element(util.isFormatElement) is empty.
   * @param {Element} element Format element node
   * @returns {Boolean}
   */
  isEmptyLine: function isEmptyLine(element) {
    return !element || !element.parentNode || !element.querySelector('IMG, IFRAME, AUDIO, VIDEO, CANVAS, TABLE') && this.onlyZeroWidthSpace(element.textContent);
  },
  /**
   * @description Check the span's attributes are empty.
   * @param {Element|null} element Element node
   * @returns {Boolean}
   */
  isSpanWithoutAttr: function isSpanWithoutAttr(element) {
    return !!element && element.nodeType === 1 && /^SPAN$/i.test(element.nodeName) && !element.className && !element.style.cssText;
  },
  /**
   * @description Check the node is a list (ol, ul)
   * @param {Node|String} node The element or element name to check
   * @returns {Boolean}
   */
  isList: function isList(node) {
    return node && /^(OL|UL)$/i.test(typeof node === 'string' ? node : node.nodeName);
  },
  /**
   * @description Check the node is a list cell (li)
   * @param {Node|String} node The element or element name to check
   * @returns {Boolean}
   */
  isListCell: function isListCell(node) {
    return node && /^LI$/i.test(typeof node === 'string' ? node : node.nodeName);
  },
  /**
   * @description Check the node is a table (table, thead, tbody, tr, th, td)
   * @param {Node|String} node The element or element name to check
   * @returns {Boolean}
   */
  isTable: function isTable(node) {
    return node && /^(TABLE|THEAD|TBODY|TR|TH|TD)$/i.test(typeof node === 'string' ? node : node.nodeName);
  },
  /**
   * @description Check the node is a table cell (td, th)
   * @param {Node|String} node The element or element name to check
   * @returns {Boolean}
   */
  isCell: function isCell(node) {
    return node && /^(TD|TH)$/i.test(typeof node === 'string' ? node : node.nodeName);
  },
  /**
   * @description Check the node is a break node (BR)
   * @param {Node|String} node The element or element name to check
   * @returns {Boolean}
   */
  isBreak: function isBreak(node) {
    return node && /^BR$/i.test(typeof node === 'string' ? node : node.nodeName);
  },
  /**
   * @description Check the node is a anchor node (A)
   * @param {Node|String} node The element or element name to check
   * @returns {Boolean}
   */
  isAnchor: function isAnchor(node) {
    return node && /^A$/i.test(typeof node === 'string' ? node : node.nodeName);
  },
  /**
   * @description Check the node is a media node (img, iframe, audio, video, canvas)
   * @param {Node|String} node The element or element name to check
   * @returns {Boolean}
   */
  isMedia: function isMedia(node) {
    return node && /^(IMG|IFRAME|AUDIO|VIDEO|CANVAS)$/i.test(typeof node === 'string' ? node : node.nodeName);
  },
  /**
   * @description Checks for numeric (with decimal point).
   * @param {String|Number} text Text string or number
   * @returns {Boolean}
   */
  isNumber: function isNumber(text) {
    return !!text && /^-?\d+(\.\d+)?$/.test(text + '');
  },
  /**
   * @description Get a number.
   * @param {String|Number} text Text string or number
   * @param {Number} maxDec Maximum number of decimal places (-1 : Infinity)
   * @returns {Number}
   */
  getNumber: function getNumber(text, maxDec) {
    if (!text) return 0;
    var number = (text + '').match(/-?\d+(\.\d+)?/);
    if (!number || !number[0]) return 0;
    number = number[0];
    return maxDec < 0 ? number * 1 : maxDec === 0 ? this._w.Math.round(number * 1) : (number * 1).toFixed(maxDec) * 1;
  },
  /**
   * @description Get all "children" of the argument value element (Without text nodes)
   * @param {Element} element element to get child node
   * @param {Function|null} validation Conditional function
   * @returns {Array}
   */
  getListChildren: function getListChildren(element, validation) {
    var children = [];
    if (!element || !element.children || element.children.length === 0) return children;
    validation = validation || function () {
      return true;
    };
    (function recursionFunc(current) {
      if (element !== current && validation(current)) {
        children.push(current);
      }
      if (!!current.children) {
        for (var i = 0, len = current.children.length; i < len; i++) {
          recursionFunc(current.children[i]);
        }
      }
    })(element);
    return children;
  },
  /**
   * @description Get all "childNodes" of the argument value element (Include text nodes)
   * @param {Node} element element to get child node
   * @param {Function|null} validation Conditional function
   * @returns {Array}
   */
  getListChildNodes: function getListChildNodes(element, validation) {
    var children = [];
    if (!element || element.childNodes.length === 0) return children;
    validation = validation || function () {
      return true;
    };
    (function recursionFunc(current) {
      if (element !== current && validation(current)) {
        children.push(current);
      }
      for (var i = 0, len = current.childNodes.length; i < len; i++) {
        recursionFunc(current.childNodes[i]);
      }
    })(element);
    return children;
  },
  /**
   * @description Returns the number of parents nodes.
   * "0" when the parent node is the WYSIWYG area.
   * "-1" when the element argument is the WYSIWYG area.
   * @param {Node} element The element to check
   * @returns {Number}
   */
  getElementDepth: function getElementDepth(element) {
    if (!element || this.isWysiwygDiv(element)) return -1;
    var depth = 0;
    element = element.parentNode;
    while (element && !this.isWysiwygDiv(element)) {
      depth += 1;
      element = element.parentNode;
    }
    return depth;
  },
  /**
   * @description Compares two elements to find a common ancestor, and returns the order of the two elements.
   * @param {Node} a Node to compare.
   * @param {Node} b Node to compare.
   * @returns {Object} { ancesstor, a, b, result: (a > b ? 1 : a < b ? -1 : 0) };
   */
  compareElements: function compareElements(a, b) {
    var aNode = a,
      bNode = b;
    while (aNode && bNode && aNode.parentNode !== bNode.parentNode) {
      aNode = aNode.parentNode;
      bNode = bNode.parentNode;
    }
    if (!aNode || !bNode) return {
      ancestor: null,
      a: a,
      b: b,
      result: 0
    };
    var children = aNode.parentNode.childNodes;
    var aIndex = this.getArrayIndex(children, aNode);
    var bIndex = this.getArrayIndex(children, bNode);
    return {
      ancestor: aNode.parentNode,
      a: aNode,
      b: bNode,
      result: aIndex > bIndex ? 1 : aIndex < bIndex ? -1 : 0
    };
  },
  /**
   * @description Get the parent element of the argument value.
   * A tag that satisfies the query condition is imported.
   * Returns null if not found.
   * @param {Node} element Reference element
   * @param {String|Function} query Query String (nodeName, .className, #ID, :name) or validation function.
   * Not use it like jquery.
   * Only one condition can be entered at a time.
   * @returns {Element|null}
   */
  getParentElement: function getParentElement(element, query) {
    var check;
    if (typeof query === 'function') {
      check = query;
    } else {
      var attr;
      if (/^\./.test(query)) {
        attr = 'className';
        query = query.split('.')[1];
      } else if (/^#/.test(query)) {
        attr = 'id';
        query = '^' + query.split('#')[1] + '$';
      } else if (/^:/.test(query)) {
        attr = 'name';
        query = '^' + query.split(':')[1] + '$';
      } else {
        attr = 'nodeName';
        query = '^' + query + '$';
      }
      var regExp = new this._w.RegExp(query, 'i');
      check = function check(el) {
        return regExp.test(el[attr]);
      };
    }
    while (element && !check(element)) {
      if (this.isWysiwygDiv(element)) {
        return null;
      }
      element = element.parentNode;
    }
    return element;
  },
  /**
   * @description Get the child element of the argument value.
   * A tag that satisfies the query condition is imported.
   * Returns null if not found.
   * @param {Node} element Reference element
   * @param {String|Function} query Query String (nodeName, .className, #ID, :name) or validation function.
   * @param {Boolean} last If true returns the last node among the found child nodes. (default: first node)
   * Not use it like jquery.
   * Only one condition can be entered at a time.
   * @returns {Element|null}
   */
  getChildElement: function getChildElement(element, query, last) {
    var check;
    if (typeof query === 'function') {
      check = query;
    } else {
      var attr;
      if (/^\./.test(query)) {
        attr = 'className';
        query = query.split('.')[1];
      } else if (/^#/.test(query)) {
        attr = 'id';
        query = '^' + query.split('#')[1] + '$';
      } else if (/^:/.test(query)) {
        attr = 'name';
        query = '^' + query.split(':')[1] + '$';
      } else {
        attr = 'nodeName';
        query = '^' + (query === 'text' ? '#' + query : query) + '$';
      }
      var regExp = new this._w.RegExp(query, 'i');
      check = function check(el) {
        return regExp.test(el[attr]);
      };
    }
    var childList = this.getListChildNodes(element, function (current) {
      return check(current);
    });
    return childList[last ? childList.length - 1 : 0];
  },
  /**
   * @description 1. The first node of all the child nodes of the "first" element is returned.
   * 2. The last node of all the child nodes of the "last" element is returned.
   * 3. When there is no "last" element, the first and last nodes of all the children of the "first" element are returned.
   * { sc: "first", ec: "last" }
   * @param {Node} first First element
   * @param {Node|null} last Last element
   * @returns {Object}
   */
  getEdgeChildNodes: function getEdgeChildNodes(first, last) {
    if (!first) return;
    if (!last) last = first;
    while (first && first.nodeType === 1 && first.childNodes.length > 0 && !this.isBreak(first)) first = first.firstChild;
    while (last && last.nodeType === 1 && last.childNodes.length > 0 && !this.isBreak(last)) last = last.lastChild;
    return {
      sc: first,
      ec: last || first
    };
  },
  /**
   * @description Returns the position of the left and top of argument. {left:0, top:0}
   * @param {Node} element Target node
   * @param {Element|null} wysiwygFrame When use iframe option, iframe object should be sent (context.element.wysiwygFrame)
   * @returns {Object}
   */
  getOffset: function getOffset(element, wysiwygFrame) {
    var offsetLeft = 0;
    var offsetTop = 0;
    var offsetElement = element.nodeType === 3 ? element.parentElement : element;
    var wysiwyg = this.getParentElement(element, this.isWysiwygDiv.bind(this));
    while (offsetElement && !this.hasClass(offsetElement, 'se-container') && offsetElement !== wysiwyg) {
      offsetLeft += offsetElement.offsetLeft;
      offsetTop += offsetElement.offsetTop;
      offsetElement = offsetElement.offsetParent;
    }
    var iframe = wysiwygFrame && /iframe/i.test(wysiwygFrame.nodeName);
    return {
      left: offsetLeft + (iframe ? wysiwygFrame.parentElement.offsetLeft : 0),
      top: offsetTop - (wysiwyg ? wysiwyg.scrollTop : 0) + (iframe ? wysiwygFrame.parentElement.offsetTop : 0)
    };
  },
  /**
   * @description It compares the start and end indexes of "a" and "b" and returns the number of overlapping indexes in the range.
   * ex) 1, 5, 4, 6 => "2" (4 ~ 5)
   * @param {Number} aStart Start index of "a"
   * @param {Number} aEnd End index of "a"
   * @param {Number} bStart Start index of "b"
   * @param {Number} bEnd Start index of "b"
   * @returns {Number}
   */
  getOverlapRangeAtIndex: function getOverlapRangeAtIndex(aStart, aEnd, bStart, bEnd) {
    if (aStart <= bEnd ? aEnd < bStart : aEnd > bStart) return 0;
    var overlap = (aStart > bStart ? aStart : bStart) - (aEnd < bEnd ? aEnd : bEnd);
    return (overlap < 0 ? overlap * -1 : overlap) + 1;
  },
  /**
   * @description Set the text content value of the argument value element
   * @param {Node} element Element to replace text content
   * @param {String} txt Text to be applied
   */
  changeTxt: function changeTxt(element, txt) {
    if (!element || !txt) return;
    element.textContent = txt;
  },
  /**
   * @description Replace element
   * @param {Element} element Target element
   * @param {String|Element} newElement String or element of the new element to apply
   */
  changeElement: function changeElement(element, newElement) {
    if (typeof newElement === 'string') {
      if (element.outerHTML) {
        element.outerHTML = newElement;
      } else {
        var doc = this.createElement('DIV');
        doc.innerHTML = newElement;
        newElement = doc.firstChild;
        element.parentNode.replaceChild(newElement, element);
      }
    } else if (newElement.nodeType === 1) {
      element.parentNode.replaceChild(newElement, element);
    }
  },
  /**
   * @description Set style, if all styles are deleted, the style properties are deleted.
   * @param {Element} element Element to set style
   * @param {String} styleName Style attribute name (marginLeft, textAlign...)
   * @param {String|Number} value Style value
   */
  setStyle: function setStyle(element, styleName, value) {
    element.style[styleName] = value;
    if (!value && !element.style.cssText) {
      element.removeAttribute('style');
    }
  },
  /**
   * @description Determine whether any of the matched elements are assigned the given class
   * @param {Element} element Elements to search class name
   * @param {String} className Class name to search for
   * @returns {Boolean}
   */
  hasClass: function hasClass(element, className) {
    if (!element) return;
    return new this._w.RegExp(className).test(element.className);
  },
  /**
   * @description Append the className value of the argument value element
   * @param {Element} element Elements to add class name
   * @param {String} className Class name to be add
   */
  addClass: function addClass(element, className) {
    if (!element) return;
    var check = new this._w.RegExp('(\\s|^)' + className + '(\\s|$)');
    if (check.test(element.className)) return;
    element.className += (element.className.length > 0 ? ' ' : '') + className;
  },
  /**
   * @description Delete the className value of the argument value element
   * @param {Element} element Elements to remove class name
   * @param {String} className Class name to be remove
   */
  removeClass: function removeClass(element, className) {
    if (!element) return;
    var check = new this._w.RegExp('(\\s|^)' + className + '(\\s|$)');
    element.className = element.className.replace(check, ' ').trim();
    if (!element.className.trim()) element.removeAttribute('class');
  },
  /**
   * @description Argument value If there is no class name, insert it and delete the class name if it exists
   * @param {Element} element Elements to replace class name
   * @param {String} className Class name to be change
   * @returns {Boolean|undefined}
   */
  toggleClass: function toggleClass(element, className) {
    if (!element) return;
    var result = false;
    var check = new this._w.RegExp('(\\s|^)' + className + '(\\s|$)');
    if (check.test(element.className)) {
      element.className = element.className.replace(check, ' ').trim();
    } else {
      element.className += ' ' + className;
      result = true;
    }
    if (!element.className.trim()) element.removeAttribute('class');
    return result;
  },
  /**
   * @description Checks if element can't be easily enabled
   * @param {Element} element Element to check for
   */
  isImportantDisabled: function isImportantDisabled(element) {
    return element.hasAttribute('data-important-disabled');
  },
  /**
   * @description In the predefined code view mode, the buttons except the executable button are changed to the 'disabled' state.
   * core.codeViewDisabledButtons (An array of buttons whose class name is not "se-code-view-enabled")
   * core.resizingDisabledButtons (An array of buttons whose class name is not "se-resizing-enabled")
   * @param {Boolean} disabled Disabled value
   * @param {Array|HTMLCollection|NodeList} buttonList Button array
   * @param {Boolean} important If priveleged mode should be used (Necessary to switch importantDisabled buttons)
   */
  setDisabledButtons: function setDisabledButtons(disabled, buttonList, important) {
    for (var i = 0, len = buttonList.length; i < len; i++) {
      var button = buttonList[i];
      if (important || !this.isImportantDisabled(button)) button.disabled = disabled;
      if (important) {
        if (disabled) {
          button.setAttribute('data-important-disabled', '');
        } else {
          button.removeAttribute('data-important-disabled');
        }
      }
    }
  },
  /**
   * @description Delete argumenu value element
   * @param {Node} item Node to be remove
   */
  removeItem: function removeItem(item) {
    if (!item) return;
    if (typeof item.remove === 'function') item.remove();else if (item.parentNode) item.parentNode.removeChild(item);
  },
  /**
   * @description Delete all parent nodes that match the condition.
   * Returns an {sc: previousSibling, ec: nextSibling}(the deleted node reference) or null.
   * @param {Node} item Node to be remove
   * @param {Function|null} validation Validation function. default(Deleted if it only have breakLine and blanks)
   * @param {Element|null} stopParent Stop when the parent node reaches stopParent
   * @returns {Object|null} {sc: previousSibling, ec: nextSibling}
   */
  removeItemAllParents: function removeItemAllParents(item, validation, stopParent) {
    if (!item) return null;
    var cc = null;
    if (!validation) {
      validation = function (current) {
        if (current === stopParent || this.isComponent(current)) return false;
        var text = current.textContent.trim();
        return text.length === 0 || /^(\n|\u200B)+$/.test(text);
      }.bind(this);
    }
    (function recursionFunc(element) {
      if (!util_util.isWysiwygDiv(element)) {
        var parent = element.parentNode;
        if (parent && validation(element)) {
          cc = {
            sc: element.previousElementSibling,
            ec: element.nextElementSibling
          };
          util_util.removeItem(element);
          recursionFunc(parent);
        }
      }
    })(item);
    return cc;
  },
  /**
   * @description Detach Nested all nested lists under the "baseNode".
   * Returns a list with nested removed.
   * @param {Node} baseNode Element on which to base.
   * @param {Boolean} all If true, it also detach all nested lists of a returned list.
   * @returns {Element}
   */
  detachNestedList: function detachNestedList(baseNode, all) {
    var rNode = this._deleteNestedList(baseNode);
    var rangeElement, cNodes;
    if (rNode) {
      rangeElement = rNode.cloneNode(false);
      cNodes = rNode.childNodes;
      var index = this.getPositionIndex(baseNode);
      while (cNodes[index]) {
        rangeElement.appendChild(cNodes[index]);
      }
    } else {
      rangeElement = baseNode;
    }
    var rChildren;
    if (!all) {
      var depth = this.getElementDepth(baseNode) + 2;
      rChildren = this.getListChildren(baseNode, function (current) {
        return this.isListCell(current) && !current.previousElementSibling && this.getElementDepth(current) === depth;
      }.bind(this));
    } else {
      rChildren = this.getListChildren(rangeElement, function (current) {
        return this.isListCell(current) && !current.previousElementSibling;
      }.bind(this));
    }
    for (var i = 0, len = rChildren.length; i < len; i++) {
      this._deleteNestedList(rChildren[i]);
    }
    if (rNode) {
      rNode.parentNode.insertBefore(rangeElement, rNode.nextSibling);
      if (cNodes && cNodes.length === 0) this.removeItem(rNode);
    }
    return rangeElement === baseNode ? rangeElement.parentNode : rangeElement;
  },
  /**
   * @description Sub function of util.detachNestedList method.
   * @private
   */
  _deleteNestedList: function _deleteNestedList(baseNode) {
    var baseParent = baseNode.parentNode;
    var sibling = baseParent;
    var parent = sibling.parentNode;
    var liSibling, liParent, child, index, c;
    while (this.isListCell(parent)) {
      index = this.getPositionIndex(baseNode);
      liSibling = parent.nextElementSibling;
      liParent = parent.parentNode;
      child = sibling;
      while (child) {
        sibling = sibling.nextSibling;
        if (this.isList(child)) {
          c = child.childNodes;
          while (c[index]) {
            liParent.insertBefore(c[index], liSibling);
          }
          if (c.length === 0) this.removeItem(child);
        } else {
          liParent.appendChild(child);
        }
        child = sibling;
      }
      sibling = liParent;
      parent = liParent.parentNode;
    }
    if (baseParent.children.length === 0) this.removeItem(baseParent);
    return liParent;
  },
  /**
   * @description Split all tags based on "baseNode"
   * Returns the last element of the splited tag.
   * @param {Node} baseNode Element or text node on which to base
   * @param {Number|Node|null} offset Text offset of "baseNode" (Only valid when "baseNode" is a text node)
   * @param {Number} depth The nesting depth of the element being split. (default: 0)
   * @returns {Element}
   */
  splitElement: function splitElement(baseNode, offset, depth) {
    if (this.isWysiwygDiv(baseNode)) return baseNode;
    if (!!offset && !this.isNumber(offset)) {
      var _children = baseNode.childNodes;
      var _index = this.getPositionIndex(offset);
      var prev = baseNode.cloneNode(false);
      var _next = baseNode.cloneNode(false);
      for (var i = 0, len = _children.length; i < len; i++) {
        if (i < _index) prev.appendChild(_children[i]);else if (i > _index) _next.appendChild(_children[i]);else continue;
        i--;
        len--;
        _index--;
      }
      if (prev.childNodes.length > 0) baseNode.parentNode.insertBefore(prev, baseNode);
      if (_next.childNodes.length > 0) baseNode.parentNode.insertBefore(_next, baseNode.nextElementSibling);
      return baseNode;
    }
    var bp = baseNode.parentNode;
    var index = 0,
      newEl,
      children,
      temp;
    var next = true;
    if (!depth || depth < 0) depth = 0;
    if (baseNode.nodeType === 3) {
      index = this.getPositionIndex(baseNode);
      if (offset >= 0) {
        baseNode.splitText(offset);
        var after = this.getNodeFromPath([index + 1], bp);
        if (this.onlyZeroWidthSpace(after)) after.data = this.zeroWidthSpace;
      }
    } else if (baseNode.nodeType === 1) {
      if (!baseNode.previousSibling) {
        if (this.getElementDepth(baseNode) === depth) next = false;
      } else {
        baseNode = baseNode.previousSibling;
      }
    }
    var depthEl = baseNode;
    while (this.getElementDepth(depthEl) > depth) {
      index = this.getPositionIndex(depthEl) + 1;
      depthEl = depthEl.parentNode;
      temp = newEl;
      newEl = depthEl.cloneNode(false);
      children = depthEl.childNodes;
      if (temp) {
        if (this.isListCell(newEl) && this.isList(temp) && temp.firstElementChild) {
          newEl.innerHTML = temp.firstElementChild.innerHTML;
          util_util.removeItem(temp.firstElementChild);
          if (temp.children.length > 0) newEl.appendChild(temp);
        } else {
          newEl.appendChild(temp);
        }
      }
      while (children[index]) {
        newEl.appendChild(children[index]);
      }
    }
    if (depthEl.childNodes.length <= 1 && (!depthEl.firstChild || depthEl.firstChild.textContent.length === 0)) depthEl.innerHTML = '<br>';
    var pElement = depthEl.parentNode;
    if (next) depthEl = depthEl.nextSibling;
    if (!newEl) return depthEl;
    this.mergeSameTags(newEl, null, false);
    this.mergeNestedTags(newEl, function (current) {
      return this.isList(current);
    }.bind(this));
    if (newEl.childNodes.length > 0) pElement.insertBefore(newEl, depthEl);else newEl = depthEl;
    if (bp.childNodes.length === 0) this.removeItem(bp);
    return newEl;
  },
  /**
   * @description Use with "npdePath (util.getNodePath)" to merge the same attributes and tags if they are present and modify the nodepath.
   * If "offset" has been changed, it will return as much "offset" as it has been modified.
   * An array containing change offsets is returned in the order of the "nodePathArray" array.
   * @param {Element} element Element
   * @param {Array|null} nodePathArray Array of NodePath object ([util.getNodePath(), ..])
   * @param {Boolean} onlyText If true, non-text nodes(!util._isIgnoreNodeChange) like 'span', 'strong'.. are ignored.
   * @returns {Array} [offset, ..]
   */
  mergeSameTags: function mergeSameTags(element, nodePathArray, onlyText) {
    var inst = this;
    var nodePathLen = nodePathArray ? nodePathArray.length : 0;
    var offsets = null;
    if (nodePathLen) {
      offsets = this._w.Array.apply(null, new this._w.Array(nodePathLen)).map(this._w.Number.prototype.valueOf, 0);
    }
    (function recursionFunc(current, depth, depthIndex) {
      var children = current.childNodes;
      for (var i = 0, len = children.length, child, next; i < len; i++) {
        child = children[i];
        next = children[i + 1];
        if (!child) break;
        if (onlyText && inst._isIgnoreNodeChange(child) || !onlyText && (inst.isTable(child) || inst.isListCell(child) || inst.isFormatElement(child) && !inst.isFreeFormatElement(child))) {
          if (inst.isTable(child) || inst.isListCell(child)) {
            recursionFunc(child, depth + 1, i);
          }
          continue;
        }
        if (len === 1 && current.nodeName === child.nodeName && current.parentNode) {
          // update nodePath
          if (nodePathLen) {
            var path = void 0,
              c = void 0,
              p = void 0,
              cDepth = void 0,
              spliceDepth = void 0;
            for (var n = 0; n < nodePathLen; n++) {
              path = nodePathArray[n];
              if (path && path[depth] === i) {
                c = child, p = current, cDepth = depth, spliceDepth = true;
                while (cDepth >= 0) {
                  if (inst.getArrayIndex(p.childNodes, c) !== path[cDepth]) {
                    spliceDepth = false;
                    break;
                  }
                  c = child.parentNode;
                  p = c.parentNode;
                  cDepth--;
                }
                if (spliceDepth) {
                  path.splice(depth, 1);
                  path[depth] = i;
                }
              }
            }
          }

          // merge tag
          inst.copyTagAttributes(child, current);
          current.parentNode.insertBefore(child, current);
          inst.removeItem(current);
        }
        if (!next) {
          if (child.nodeType === 1) recursionFunc(child, depth + 1, i);
          break;
        }
        if (child.nodeName === next.nodeName && inst.isSameAttributes(child, next) && child.href === next.href) {
          var childs = child.childNodes;
          var childLength = 0;
          for (var _n = 0, nLen = childs.length; _n < nLen; _n++) {
            if (childs[_n].textContent.length > 0) childLength++;
          }
          var l = child.lastChild;
          var r = next.firstChild;
          var addOffset = 0;
          if (l && r) {
            var textOffset = l.nodeType === 3 && r.nodeType === 3;
            addOffset = l.textContent.length;
            var tempL = l.previousSibling;
            while (tempL && tempL.nodeType === 3) {
              addOffset += tempL.textContent.length;
              tempL = tempL.previousSibling;
            }
            if (childLength > 0 && l.nodeType === 3 && r.nodeType === 3 && (l.textContent.length > 0 || r.textContent.length > 0)) childLength--;
            if (nodePathLen) {
              var _path = null;
              for (var _n2 = 0; _n2 < nodePathLen; _n2++) {
                _path = nodePathArray[_n2];
                if (_path && _path[depth] > i) {
                  if (depth > 0 && _path[depth - 1] !== depthIndex) continue;
                  _path[depth] -= 1;
                  if (_path[depth + 1] >= 0 && _path[depth] === i) {
                    _path[depth + 1] += childLength;
                    if (textOffset) {
                      if (l && l.nodeType === 3 && r && r.nodeType === 3) {
                        offsets[_n2] += addOffset;
                      }
                    }
                  }
                }
              }
            }
          }
          if (child.nodeType === 3) {
            addOffset = child.textContent.length;
            child.textContent += next.textContent;
            if (nodePathLen) {
              var _path2 = null;
              for (var _n3 = 0; _n3 < nodePathLen; _n3++) {
                _path2 = nodePathArray[_n3];
                if (_path2 && _path2[depth] > i) {
                  if (depth > 0 && _path2[depth - 1] !== depthIndex) continue;
                  _path2[depth] -= 1;
                  if (_path2[depth + 1] >= 0 && _path2[depth] === i) {
                    _path2[depth + 1] += childLength;
                    offsets[_n3] += addOffset;
                  }
                }
              }
            }
          } else {
            child.innerHTML += next.innerHTML;
          }
          inst.removeItem(next);
          i--;
        } else if (child.nodeType === 1) {
          recursionFunc(child, depth + 1, i);
        }
      }
    })(element, 0, 0);
    return offsets;
  },
  /**
   * @description Remove nested tags without other child nodes.
   * @param {Element} element Element object
   * @param {Function|String|null} validation Validation function / String("tag1|tag2..") / If null, all tags are applicable.
   */
  mergeNestedTags: function mergeNestedTags(element, validation) {
    if (typeof validation === 'string') {
      validation = function (current) {
        return this.test(current.tagName);
      }.bind(new this._w.RegExp('^(' + (validation ? validation : '.+') + ')$', 'i'));
    } else if (typeof validation !== 'function') {
      validation = function validation() {
        return true;
      };
    }
    (function recursionFunc(current) {
      var children = current.children;
      if (children.length === 1 && children[0].nodeName === current.nodeName && validation(current)) {
        var temp = children[0];
        children = temp.children;
        while (children[0]) {
          current.appendChild(children[0]);
        }
        current.removeChild(temp);
      }
      for (var i = 0, len = current.children.length; i < len; i++) {
        recursionFunc(current.children[i]);
      }
    })(element);
  },
  /**
   * @description Delete a empty child node of argument element
   * @param {Element} element Element node
   * @param {Node|null} notRemoveNode Do not remove node
   */
  removeEmptyNode: function removeEmptyNode(element, notRemoveNode) {
    var inst = this;
    if (notRemoveNode) {
      notRemoveNode = inst.getParentElement(notRemoveNode, function (current) {
        return element === current.parentElement;
      });
    }
    (function recursionFunc(current) {
      if (inst._notTextNode(current) || current === notRemoveNode || inst.isNonEditable(current)) return 0;
      if (current !== element && inst.onlyZeroWidthSpace(current.textContent) && (!current.firstChild || !inst.isBreak(current.firstChild)) && !current.querySelector(inst._allowedEmptyNodeList)) {
        if (current.parentNode) {
          current.parentNode.removeChild(current);
          return -1;
        }
      } else {
        var children = current.children;
        for (var i = 0, len = children.length, r = 0; i < len; i++) {
          if (!children[i + r] || inst.isComponent(children[i + r])) continue;
          r += recursionFunc(children[i + r]);
        }
      }
      return 0;
    })(element);
    if (element.childNodes.length === 0) element.innerHTML = '<br>';
  },
  /**
   * @description Remove whitespace between tags in HTML string.
   * @param {String} html HTML string
   * @returns {String}
   */
  htmlRemoveWhiteSpace: function htmlRemoveWhiteSpace(html) {
    if (!html) return '';
    return html.trim().replace(/<\/?(?!strong|span|font|b|var|i|em|u|ins|s|strike|del|sub|sup|mark|a|label|code|summary)[^>^<]+>\s+(?=<)/ig, function (m) {
      return m.replace(/\n/g, '').replace(/\s+/, ' ');
    });
  },
  /**
   * @description Sort a element array by depth of element.
   * @param {Array} array Array object
   * @param {Boolean} des true: descending order / false: ascending order
   */
  sortByDepth: function sortByDepth(array, des) {
    var t = !des ? -1 : 1;
    var f = t * -1;
    array.sort(function (a, b) {
      if (!this.isListCell(a) || !this.isListCell(b)) return 0;
      a = this.getElementDepth(a);
      b = this.getElementDepth(b);
      return a > b ? t : a < b ? f : 0;
    }.bind(this));
  },
  /**
   * @description Nodes that need to be added without modification when changing text nodes
   * @param {Node} element Element to check
   * @returns {Boolean}
   * @private
   */
  _isIgnoreNodeChange: function _isIgnoreNodeChange(element) {
    return element && element.nodeType !== 3 && (this.isNonEditable(element) || !this.isTextStyleElement(element));
  },
  /**
   * @description Nodes that must remain undetached when changing text nodes (A, Label, Code, Span:font-size)
   * @param {Node|String} element Element to check
   * @returns {Boolean}
   * @private
   */
  _isMaintainedNode: function _isMaintainedNode(element) {
    return element && element.nodeType !== 3 && /^(a|label|code|summary)$/i.test(typeof element === 'string' ? element : element.nodeName);
  },
  /**
   * @description Node with font-size style
   * @param {Node} element Element to check
   * @returns {Boolean}
   * @private
   */
  _isSizeNode: function _isSizeNode(element) {
    return element && element.nodeType !== 3 && this.isTextStyleElement(element) && !!element.style.fontSize;
  },
  /**
   * @description Nodes without text
   * @param {Node} element Element to check
   * @returns {Boolean}
   * @private
   */
  _notTextNode: function _notTextNode(element) {
    return element && element.nodeType !== 3 && (this.isComponent(element) || /^(br|input|select|canvas|img|iframe|audio|video)$/i.test(typeof element === 'string' ? element : element.nodeName));
  },
  /**
   * @description Check disallowed tags
   * @param {Node} element Element to check
   * @returns {Boolean}
   * @private
   */
  _disallowedTags: function _disallowedTags(element) {
    return /^(meta|script|link|style|[a-z]+\:[a-z]+)$/i.test(element.nodeName);
  },
  /**
   * @description Create whitelist RegExp object.
   * Return RegExp format: new RegExp("<\\/?\\b(?!" + list + ")\\b[^>^<]*+>", "gi")
   * @param {String} list Tags list ("br|p|div|pre...")
   * @returns {RegExp}
   */
  createTagsWhitelist: function createTagsWhitelist(list) {
    return new RegExp('<\\/?\\b(?!\\b' + (list || '').replace(/\|/g, '\\b|\\b') + '\\b)[^>]*>', 'gi');
  },
  /**
   * @description Create blacklist RegExp object.
   * Return RegExp format: new RegExp("<\\/?\\b(?:" + list + ")\\b[^>^<]*+>", "gi")
   * @param {String} list Tags list ("br|p|div|pre...")
   * @returns {RegExp}
   */
  createTagsBlacklist: function createTagsBlacklist(list) {
    return new RegExp('<\\/?\\b(?:\\b' + (list || '^').replace(/\|/g, '\\b|\\b') + '\\b)[^>]*>', 'gi');
  },
  /**
   * @description Fix tags that do not fit the editor format.
   * @param {Element} documentFragment Document fragment "DOCUMENT_FRAGMENT_NODE" (nodeType === 11)
   * @param {RegExp} htmlCheckWhitelistRegExp Editor tags whitelist (core._htmlCheckWhitelistRegExp)
   * @param {RegExp} htmlCheckBlacklistRegExp Editor tags blacklist (core._htmlCheckBlacklistRegExp)
   * @param {Boolean} lowLevelCheck Row level check
   * @private
   */
  _consistencyCheckOfHTML: function _consistencyCheckOfHTML(documentFragment, htmlCheckWhitelistRegExp, htmlCheckBlacklistRegExp, lowLevelCheck) {
    /**
     * It is can use ".children(util.getListChildren)" to exclude text nodes, but "documentFragment.children" is not supported in IE.
     * So check the node type and exclude the text no (current.nodeType !== 1)
     */
    var removeTags = [],
      emptyTags = [],
      wrongList = [],
      withoutFormatCells = [];

    // wrong position
    var wrongTags = this.getListChildNodes(documentFragment, function (current) {
      if (current.nodeType !== 1) {
        if (this.isList(current.parentElement)) removeTags.push(current);
        return false;
      }

      // white list
      if (htmlCheckBlacklistRegExp.test(current.nodeName) || !htmlCheckWhitelistRegExp.test(current.nodeName) && current.childNodes.length === 0 && this.isNotCheckingNode(current)) {
        removeTags.push(current);
        return false;
      }
      var nrtag = !this.getParentElement(current, this.isNotCheckingNode);
      // empty tags
      if (!this.isTable(current) && !this.isListCell(current) && !this.isAnchor(current) && (this.isFormatElement(current) || this.isRangeFormatElement(current) || this.isTextStyleElement(current)) && current.childNodes.length === 0 && nrtag) {
        emptyTags.push(current);
        return false;
      }

      // wrong list
      if (this.isList(current.parentNode) && !this.isList(current) && !this.isListCell(current)) {
        wrongList.push(current);
        return false;
      }

      // table cells
      if (this.isCell(current)) {
        var fel = current.firstElementChild;
        if (!this.isFormatElement(fel) && !this.isRangeFormatElement(fel) && !this.isComponent(fel)) {
          withoutFormatCells.push(current);
          return false;
        }
      }
      var result = current.parentNode !== documentFragment && nrtag && (this.isListCell(current) && !this.isList(current.parentNode) || lowLevelCheck && (this.isFormatElement(current) || this.isComponent(current)) && !this.isRangeFormatElement(current.parentNode) && !this.getParentElement(current, this.isComponent));
      return result;
    }.bind(this));
    for (var i = 0, len = removeTags.length; i < len; i++) {
      this.removeItem(removeTags[i]);
    }
    var checkTags = [];
    for (var _i4 = 0, _len2 = wrongTags.length, t, p; _i4 < _len2; _i4++) {
      t = wrongTags[_i4];
      p = t.parentNode;
      if (!p || !p.parentNode) continue;
      if (this.getParentElement(t, this.isListCell)) {
        var cellChildren = t.childNodes;
        for (var j = cellChildren.length - 1; _len2 >= 0; j--) {
          p.insertBefore(t, cellChildren[j]);
        }
        checkTags.push(t);
      } else {
        p.parentNode.insertBefore(t, p);
        checkTags.push(p);
      }
    }
    for (var _i5 = 0, _len3 = checkTags.length, _t; _i5 < _len3; _i5++) {
      _t = checkTags[_i5];
      if (this.onlyZeroWidthSpace(_t.textContent.trim())) {
        this.removeItem(_t);
      }
    }
    for (var _i6 = 0, _len4 = emptyTags.length; _i6 < _len4; _i6++) {
      this.removeItem(emptyTags[_i6]);
    }
    for (var _i7 = 0, _len5 = wrongList.length, _t2, tp, children, _p; _i7 < _len5; _i7++) {
      _t2 = wrongList[_i7];
      _p = _t2.parentNode;
      if (!_p) continue;
      tp = this.createElement('LI');
      if (this.isFormatElement(_t2)) {
        children = _t2.childNodes;
        while (children[0]) {
          tp.appendChild(children[0]);
        }
        _p.insertBefore(tp, _t2);
        this.removeItem(_t2);
      } else {
        _t2 = _t2.nextSibling;
        tp.appendChild(wrongList[_i7]);
        _p.insertBefore(tp, _t2);
      }
    }
    for (var _i8 = 0, _len6 = withoutFormatCells.length, _t3, f; _i8 < _len6; _i8++) {
      _t3 = withoutFormatCells[_i8];
      f = this.createElement('DIV');
      f.innerHTML = _t3.textContent.trim().length === 0 && _t3.children.length === 0 ? '<br>' : _t3.innerHTML;
      _t3.innerHTML = f.outerHTML;
    }
  },
  _setDefaultOptionStyle: function _setDefaultOptionStyle(options, defaultStyle) {
    var optionStyle = '';
    if (options.height) optionStyle += 'height:' + options.height + ';';
    if (options.minHeight) optionStyle += 'min-height:' + options.minHeight + ';';
    if (options.maxHeight) optionStyle += 'max-height:' + options.maxHeight + ';';
    if (options.position) optionStyle += 'position:' + options.position + ';';
    if (options.width) optionStyle += 'width:' + options.width + ';';
    if (options.minWidth) optionStyle += 'min-width:' + options.minWidth + ';';
    if (options.maxWidth) optionStyle += 'max-width:' + options.maxWidth + ';';
    var top = '',
      frame = '',
      editor = '';
    defaultStyle = optionStyle + defaultStyle;
    var styleArr = defaultStyle.split(';');
    for (var i = 0, len = styleArr.length, s; i < len; i++) {
      s = styleArr[i].trim();
      if (!s) continue;
      if (/^(min-|max-)?width\s*:/.test(s) || /^(z-index|position)\s*:/.test(s)) {
        top += s + ';';
        continue;
      }
      if (/^(min-|max-)?height\s*:/.test(s)) {
        if (/^height/.test(s) && s.split(':')[1].trim() === 'auto') {
          options.height = 'auto';
        }
        frame += s + ';';
        continue;
      }
      editor += s + ';';
    }
    return {
      top: top,
      frame: frame,
      editor: editor
    };
  },
  _setIframeDocument: function _setIframeDocument(frame, options) {
    frame.setAttribute('scrolling', 'auto');
    frame.contentDocument.head.innerHTML = '' + '<meta charset="utf-8" />' + '<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">' + this._setIframeCssTags(options);
    frame.contentDocument.body.className = options._editableClass;
    frame.contentDocument.body.setAttribute('contenteditable', true);
  },
  _setIframeCssTags: function _setIframeCssTags(options) {
    var linkNames = options.iframeCSSFileName;
    var wRegExp = this._w.RegExp;
    var tagString = '';
    for (var f = 0, len = linkNames.length, path; f < len; f++) {
      path = [];
      if (/(^https?:\/\/)|(^data:text\/css,)/.test(linkNames[f])) {
        path.push(linkNames[f]);
      } else {
        var CSSFileName = new wRegExp('(^|.*[\\/])' + linkNames[f] + '(\\..+)?\\.css(?:\\?.*|;.*)?$', 'i');
        for (var c = document.getElementsByTagName('link'), i = 0, _len7 = c.length, styleTag; i < _len7; i++) {
          styleTag = c[i].href.match(CSSFileName);
          if (styleTag) path.push(styleTag[0]);
        }
      }
      if (!path || path.length === 0) throw '[SUNEDITOR.constructor.iframe.fail] The suneditor CSS files installation path could not be automatically detected. Please set the option property "iframeCSSFileName" before creating editor instances.';
      for (var _i9 = 0, _len8 = path.length; _i9 < _len8; _i9++) {
        tagString += '<link href="' + path[_i9] + '" rel="stylesheet">';
      }
    }
    return tagString + (options.height === 'auto' ? '<style>\n/** Iframe height auto */\nbody{height: min-content; overflow: hidden;}\n</style>' : '');
  }
};
/* harmony default export */ var lib_util = (util_util);
// CONCATENATED MODULE: ./node_modules/suneditor/src/lib/constructor.js
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2017 JiHong Lee.
 * MIT license.
 */





/* harmony default export */ var lib_constructor = ({
  /**
   * @description document create
   * @param {Element} element Textarea
   * @param {Object} options Options
   * @returns {Object}
   */
  init: function init(element, options) {
    if (typeof options !== 'object') options = {};
    var doc = document;

    /** --- init options --- */
    this._initOptions(element, options);

    // suneditor div
    var top_div = doc.createElement('DIV');
    top_div.className = 'sun-editor' + (options.rtl ? ' se-rtl' : '');
    if (element.id) top_div.id = 'suneditor_' + element.id;

    // relative div
    var relative = doc.createElement('DIV');
    relative.className = 'se-container';

    // toolbar
    var tool_bar = this._createToolBar(doc, options.buttonList, options.plugins, options);
    var toolbarShadow = tool_bar.element.cloneNode(false);
    toolbarShadow.className += ' se-toolbar-shadow';
    tool_bar.element.style.visibility = 'hidden';
    if (tool_bar.pluginCallButtons.math) this._checkKatexMath(options.katex);
    var arrow = doc.createElement('DIV');
    arrow.className = 'se-arrow';

    // sticky toolbar dummy
    var sticky_dummy = doc.createElement('DIV');
    sticky_dummy.className = 'se-toolbar-sticky-dummy';

    // inner editor div
    var editor_div = doc.createElement('DIV');
    editor_div.className = 'se-wrapper';

    /** --- init elements and create bottom bar --- */
    var initElements = this._initElements(options, top_div, tool_bar.element, arrow);
    var bottomBar = initElements.bottomBar;
    var wysiwyg_div = initElements.wysiwygFrame;
    var placeholder_span = initElements.placeholder;
    var textarea = initElements.codeView;

    // resizing bar
    var resizing_bar = bottomBar.resizingBar;
    var navigation = bottomBar.navigation;
    var char_wrapper = bottomBar.charWrapper;
    var char_counter = bottomBar.charCounter;

    // loading box
    var loading_box = doc.createElement('DIV');
    loading_box.className = 'se-loading-box sun-editor-common';
    loading_box.innerHTML = '<div class="se-loading-effect"></div>';

    // enter line
    var line_breaker = doc.createElement('DIV');
    line_breaker.className = 'se-line-breaker';
    line_breaker.innerHTML = '<button class="se-btn">' + options.icons.line_break + '</button>';
    var line_breaker_t = doc.createElement('DIV');
    line_breaker_t.className += 'se-line-breaker-component';
    var line_breaker_b = line_breaker_t.cloneNode(true);
    line_breaker_t.innerHTML = line_breaker_b.innerHTML = options.icons.line_break;

    // resize operation background
    var resize_back = doc.createElement('DIV');
    resize_back.className = 'se-resizing-back';

    // toolbar container
    var toolbarContainer = options.toolbarContainer;
    if (toolbarContainer) {
      toolbarContainer.appendChild(tool_bar.element);
      toolbarContainer.appendChild(toolbarShadow);
    }

    // resizingbar
    var resizingBarContainer = options.resizingBarContainer;
    if (resizing_bar && resizingBarContainer) resizingBarContainer.appendChild(resizing_bar);

    /** append html */
    editor_div.appendChild(textarea);
    if (placeholder_span) editor_div.appendChild(placeholder_span);
    if (!toolbarContainer) {
      relative.appendChild(tool_bar.element);
      relative.appendChild(toolbarShadow);
    }
    relative.appendChild(sticky_dummy);
    relative.appendChild(editor_div);
    relative.appendChild(resize_back);
    relative.appendChild(loading_box);
    relative.appendChild(line_breaker);
    relative.appendChild(line_breaker_t);
    relative.appendChild(line_breaker_b);
    if (resizing_bar && !resizingBarContainer) relative.appendChild(resizing_bar);
    top_div.appendChild(relative);
    textarea = this._checkCodeMirror(options, textarea);
    return {
      constructed: {
        _top: top_div,
        _relative: relative,
        _toolBar: tool_bar.element,
        _toolbarShadow: toolbarShadow,
        _menuTray: tool_bar._menuTray,
        _editorArea: editor_div,
        _wysiwygArea: wysiwyg_div,
        _codeArea: textarea,
        _placeholder: placeholder_span,
        _resizingBar: resizing_bar,
        _navigation: navigation,
        _charWrapper: char_wrapper,
        _charCounter: char_counter,
        _loading: loading_box,
        _lineBreaker: line_breaker,
        _lineBreaker_t: line_breaker_t,
        _lineBreaker_b: line_breaker_b,
        _resizeBack: resize_back,
        _stickyDummy: sticky_dummy,
        _arrow: arrow
      },
      options: options,
      plugins: tool_bar.plugins,
      pluginCallButtons: tool_bar.pluginCallButtons,
      _responsiveButtons: tool_bar.responsiveButtons
    };
  },
  /**
   * @description Check the CodeMirror option to apply the CodeMirror and return the CodeMirror element.
   * @param {Object} options options
   * @param {Element} textarea textarea element
   * @private
   */
  _checkCodeMirror: function _checkCodeMirror(options, textarea) {
    if (options.codeMirror) {
      var cmOptions = [{
        mode: 'htmlmixed',
        htmlMode: true,
        lineNumbers: true,
        lineWrapping: true
      }, options.codeMirror.options || {}].reduce(function (init, option) {
        for (var key in option) {
          if (lib_util.hasOwn(option, key)) init[key] = option[key];
        }
        return init;
      }, {});
      if (options.height === 'auto') {
        cmOptions.viewportMargin = Infinity;
        cmOptions.height = 'auto';
      }
      var cm = options.codeMirror.src.fromTextArea(textarea, cmOptions);
      cm.display.wrapper.style.cssText = textarea.style.cssText;
      options.codeMirrorEditor = cm;
      textarea = cm.display.wrapper;
      textarea.className += ' se-wrapper-code-mirror';
    }
    return textarea;
  },
  /**
   * @description Check for a katex object.
   * @param {Object} katex katex object
   * @private
   */
  _checkKatexMath: function _checkKatexMath(katex) {
    if (!katex) throw Error('[SUNEDITOR.create.fail] To use the math button you need to add a "katex" object to the options.');
    var katexOptions = [{
      throwOnError: false
    }, katex.options || {}].reduce(function (init, option) {
      for (var key in option) {
        if (lib_util.hasOwn(option, key)) init[key] = option[key];
      }
      return init;
    }, {});
    katex.options = katexOptions;
  },
  /**
   * @description Add or reset options
   * @param {Object} mergeOptions New options property
   * @param {Object} context Context object of core
   * @param {Object} originOptions Origin options
   * @returns {Object} pluginCallButtons
   * @private
   */
  _setOptions: function _setOptions(mergeOptions, context, originOptions) {
    this._initOptions(context.element.originElement, mergeOptions);
    var el = context.element;
    var relative = el.relative;
    var editorArea = el.editorArea;
    var isNewToolbarContainer = mergeOptions.toolbarContainer && mergeOptions.toolbarContainer !== originOptions.toolbarContainer;
    var isNewToolbar = mergeOptions.lang !== originOptions.lang || mergeOptions.buttonList !== originOptions.buttonList || mergeOptions.mode !== originOptions.mode || isNewToolbarContainer;
    var tool_bar = this._createToolBar(document, isNewToolbar ? mergeOptions.buttonList : originOptions.buttonList, mergeOptions.plugins, mergeOptions);
    if (tool_bar.pluginCallButtons.math) this._checkKatexMath(mergeOptions.katex);
    var arrow = document.createElement('DIV');
    arrow.className = 'se-arrow';
    if (isNewToolbar) {
      tool_bar.element.style.visibility = 'hidden';
      // toolbar container
      if (isNewToolbarContainer) {
        mergeOptions.toolbarContainer.appendChild(tool_bar.element);
        el.toolbar.parentElement.removeChild(el.toolbar);
      } else {
        el.toolbar.parentElement.replaceChild(tool_bar.element, el.toolbar);
      }
      el.toolbar = tool_bar.element;
      el._menuTray = tool_bar._menuTray;
      el._arrow = arrow;
    }
    var initElements = this._initElements(mergeOptions, el.topArea, isNewToolbar ? tool_bar.element : el.toolbar, arrow);
    var bottomBar = initElements.bottomBar;
    var wysiwygFrame = initElements.wysiwygFrame;
    var placeholder_span = initElements.placeholder;
    var code = initElements.codeView;
    if (el.resizingBar) lib_util.removeItem(el.resizingBar);
    if (bottomBar.resizingBar) {
      if (mergeOptions.resizingBarContainer && mergeOptions.resizingBarContainer !== originOptions.resizingBarContainer) {
        mergeOptions.resizingBarContainer.appendChild(bottomBar.resizingBar);
      } else {
        relative.appendChild(bottomBar.resizingBar);
      }
    }
    editorArea.innerHTML = '';
    editorArea.appendChild(code);
    if (placeholder_span) editorArea.appendChild(placeholder_span);
    code = this._checkCodeMirror(mergeOptions, code);
    el.resizingBar = bottomBar.resizingBar;
    el.navigation = bottomBar.navigation;
    el.charWrapper = bottomBar.charWrapper;
    el.charCounter = bottomBar.charCounter;
    el.wysiwygFrame = wysiwygFrame;
    el.code = code;
    el.placeholder = placeholder_span;
    if (mergeOptions.rtl) lib_util.addClass(el.topArea, 'se-rtl');else lib_util.removeClass(el.topArea, 'se-rtl');
    return {
      callButtons: tool_bar.pluginCallButtons,
      plugins: tool_bar.plugins,
      toolbar: tool_bar
    };
  },
  /**
   * @description Initialize property of suneditor elements
   * @param {Object} options Options
   * @param {Element} topDiv Suneditor top div
   * @param {Element} toolBar Tool bar
   * @param {Element} toolBarArrow Tool bar arrow (balloon editor)
   * @returns {Object} Bottom bar elements (resizingBar, navigation, charWrapper, charCounter)
   * @private
   */
  _initElements: function _initElements(options, topDiv, toolBar, toolBarArrow) {
    /** top div */
    topDiv.style.cssText = options._editorStyles.top;

    /** toolbar */
    if (/inline/i.test(options.mode)) {
      toolBar.className += ' se-toolbar-inline';
      toolBar.style.width = options.toolbarWidth;
    } else if (/balloon/i.test(options.mode)) {
      toolBar.className += ' se-toolbar-balloon';
      toolBar.style.width = options.toolbarWidth;
      toolBar.appendChild(toolBarArrow);
    }

    /** editor */
    // wysiwyg div or iframe
    var wysiwygDiv = document.createElement(!options.iframe ? 'DIV' : 'IFRAME');
    wysiwygDiv.className = 'se-wrapper-inner se-wrapper-wysiwyg';
    if (!options.iframe) {
      wysiwygDiv.setAttribute('contenteditable', true);
      wysiwygDiv.setAttribute('scrolling', 'auto');
      for (var key in options.iframeAttributes) {
        wysiwygDiv.setAttribute(key, options.iframeAttributes[key]);
      }
      wysiwygDiv.className += ' ' + options._editableClass;
      wysiwygDiv.style.cssText = options._editorStyles.frame + options._editorStyles.editor;
      wysiwygDiv.className += options.className;
    } else {
      wysiwygDiv.allowFullscreen = true;
      wysiwygDiv.frameBorder = 0;
      wysiwygDiv.style.cssText = options._editorStyles.frame;
      wysiwygDiv.className += options.className;
    }

    // textarea for code view
    var textarea = document.createElement('TEXTAREA');
    textarea.className = 'se-wrapper-inner se-wrapper-code' + options.className;
    textarea.style.cssText = options._editorStyles.frame;
    textarea.style.display = 'none';
    if (options.height === 'auto') textarea.style.overflow = 'hidden';

    /** resize bar */
    var resizingBar = null;
    var navigation = null;
    var charWrapper = null;
    var charCounter = null;
    if (options.resizingBar) {
      resizingBar = document.createElement('DIV');
      resizingBar.className = 'se-resizing-bar sun-editor-common';

      /** navigation */
      navigation = document.createElement('DIV');
      navigation.className = 'se-navigation sun-editor-common';
      resizingBar.appendChild(navigation);

      /** char counter */
      if (options.charCounter) {
        charWrapper = document.createElement('DIV');
        charWrapper.className = 'se-char-counter-wrapper';
        if (options.charCounterLabel) {
          var charLabel = document.createElement('SPAN');
          charLabel.className = 'se-char-label';
          charLabel.textContent = options.charCounterLabel;
          charWrapper.appendChild(charLabel);
        }
        charCounter = document.createElement('SPAN');
        charCounter.className = 'se-char-counter';
        charCounter.textContent = '0';
        charWrapper.appendChild(charCounter);
        if (options.maxCharCount > 0) {
          var char_max = document.createElement('SPAN');
          char_max.textContent = ' / ' + options.maxCharCount;
          charWrapper.appendChild(char_max);
        }
        resizingBar.appendChild(charWrapper);
      }
    }
    var placeholder = null;
    if (options.placeholder) {
      placeholder = document.createElement('SPAN');
      placeholder.className = 'se-placeholder';
      placeholder.innerText = options.placeholder;
    }
    return {
      bottomBar: {
        resizingBar: resizingBar,
        navigation: navigation,
        charWrapper: charWrapper,
        charCounter: charCounter
      },
      wysiwygFrame: wysiwygDiv,
      codeView: textarea,
      placeholder: placeholder
    };
  },
  /**
   * @description Initialize options
   * @param {Element} element Options object
   * @param {Object} options Options object
   * @private
   */
  _initOptions: function _initOptions(element, options) {
    var plugins = {};
    if (options.plugins) {
      var _plugins = options.plugins;
      var pluginsValues = _plugins.length ? _plugins : Object.keys(_plugins).map(function (name) {
        return _plugins[name];
      });
      for (var i = 0, len = pluginsValues.length, p; i < len; i++) {
        p = pluginsValues[i].default || pluginsValues[i];
        plugins[p.name] = p;
      }
    }
    options.plugins = plugins;
    /** Values */
    options.lang = options.lang || en_default.a;
    options.value = typeof options.value === 'string' ? options.value : null;
    options.historyStackDelayTime = typeof options.historyStackDelayTime === 'number' ? options.historyStackDelayTime : 400;
    options.frameAttrbutes = options.frameAttrbutes || {};
    // tag style
    options.defaultTag = typeof options.defaultTag === 'string' && options.defaultTag.length > 0 ? options.defaultTag : 'p';
    var textTags = options.textTags = [{
      bold: 'STRONG',
      underline: 'U',
      italic: 'EM',
      strike: 'DEL',
      sub: 'SUB',
      sup: 'SUP'
    }, options.textTags || {}].reduce(function (_default, _new) {
      for (var key in _new) {
        _default[key] = _new[key];
      }
      return _default;
    }, {});
    options._textTagsMap = {
      'strong': textTags.bold.toLowerCase(),
      'b': textTags.bold.toLowerCase(),
      'u': textTags.underline.toLowerCase(),
      'ins': textTags.underline.toLowerCase(),
      'em': textTags.italic.toLowerCase(),
      'i': textTags.italic.toLowerCase(),
      'del': textTags.strike.toLowerCase(),
      'strike': textTags.strike.toLowerCase(),
      's': textTags.strike.toLowerCase(),
      'sub': textTags.sub.toLowerCase(),
      'sup': textTags.sup.toLowerCase()
    };
    options._defaultCommand = {
      bold: options.textTags.bold,
      underline: options.textTags.underline,
      italic: options.textTags.italic,
      strike: options.textTags.strike,
      subscript: options.textTags.sub,
      superscript: options.textTags.sup
    };
    /** Whitelist, Blacklist */
    var whitelist = 'br|p|div|pre|blockquote|h1|h2|h3|h4|h5|h6|ol|ul|li|hr|figure|figcaption|img|iframe|audio|video|source|table|thead|tbody|tr|th|td|a|b|strong|var|i|em|u|ins|s|span|strike|del|sub|sup|code|svg|path|details|summary';
    // tags
    options.tagsBlacklist = options.tagsBlacklist || '';
    options._defaultTagsWhitelist = typeof options._defaultTagsWhitelist === 'string' ? options._defaultTagsWhitelist : whitelist;
    options._editorTagsWhitelist = options.addTagsWhitelist === '*' ? '*' : this._setWhitelist(options._defaultTagsWhitelist + (typeof options.addTagsWhitelist === 'string' && options.addTagsWhitelist.length > 0 ? '|' + options.addTagsWhitelist : ''), options.tagsBlacklist);
    // paste tags
    options.pasteTagsBlacklist = options.tagsBlacklist + (options.tagsBlacklist && options.pasteTagsBlacklist ? '|' + options.pasteTagsBlacklist : options.pasteTagsBlacklist || '');
    options.pasteTagsWhitelist = options.pasteTagsWhitelist === '*' ? '*' : this._setWhitelist(typeof options.pasteTagsWhitelist === 'string' ? options.pasteTagsWhitelist : options._editorTagsWhitelist, options.pasteTagsBlacklist);
    // tag attributes
    options.attributesWhitelist = !options.attributesWhitelist || typeof options.attributesWhitelist !== 'object' ? null : options.attributesWhitelist;
    options.attributesBlacklist = !options.attributesBlacklist || typeof options.attributesBlacklist !== 'object' ? null : options.attributesBlacklist;
    /** Layout */
    options.mode = options.mode || 'classic'; // classic, inline, balloon, balloon-always
    options.rtl = !!options.rtl;
    options.lineAttrReset = typeof options.lineAttrReset === 'string' && options.lineAttrReset ? options.lineAttrReset === '*' ? '*' : new RegExp('^(' + options.lineAttrReset + ')$', 'i') : null;
    options._editableClass = 'sun-editor-editable' + (options.rtl ? ' se-rtl' : '');
    options._printClass = typeof options._printClass === 'string' ? options._printClass : null;
    options.toolbarWidth = options.toolbarWidth ? lib_util.isNumber(options.toolbarWidth) ? options.toolbarWidth + 'px' : options.toolbarWidth : 'auto';
    options.toolbarContainer = typeof options.toolbarContainer === 'string' ? document.querySelector(options.toolbarContainer) : options.toolbarContainer;
    options.stickyToolbar = /balloon/i.test(options.mode) || !!options.toolbarContainer ? -1 : options.stickyToolbar === undefined ? 0 : /^\d+/.test(options.stickyToolbar) ? lib_util.getNumber(options.stickyToolbar, 0) : -1;
    options.hideToolbar = !!options.hideToolbar;
    options.fullScreenOffset = options.fullScreenOffset === undefined ? 0 : /^\d+/.test(options.fullScreenOffset) ? lib_util.getNumber(options.fullScreenOffset, 0) : 0;
    options.fullPage = !!options.fullPage;
    options.iframe = options.fullPage || !!options.iframe;
    options.iframeAttributes = options.iframeAttributes || {};
    options.iframeCSSFileName = options.iframe ? typeof options.iframeCSSFileName === 'string' ? [options.iframeCSSFileName] : options.iframeCSSFileName || ['suneditor'] : null;
    options.previewTemplate = typeof options.previewTemplate === 'string' ? options.previewTemplate : null;
    options.printTemplate = typeof options.printTemplate === 'string' ? options.printTemplate : null;
    /** CodeMirror object */
    options.codeMirror = options.codeMirror ? options.codeMirror.src ? options.codeMirror : {
      src: options.codeMirror
    } : null;
    /** katex object (Math plugin) */
    options.katex = options.katex ? options.katex.src ? options.katex : {
      src: options.katex
    } : null;
    options.mathFontSize = !!options.mathFontSize ? options.mathFontSize : [{
      text: '1',
      value: '1em'
    }, {
      text: '1.5',
      value: '1.5em'
    }, {
      text: '2',
      value: '2em'
    }, {
      text: '2.5',
      value: '2.5em'
    }];
    /** Display */
    options.position = typeof options.position === 'string' ? options.position : null;
    options.display = options.display || (element.style.display === 'none' || !element.style.display ? 'block' : element.style.display);
    options.popupDisplay = options.popupDisplay || 'full';
    /** Bottom resizing bar */
    options.resizingBar = options.resizingBar === undefined ? /inline|balloon/i.test(options.mode) ? false : true : options.resizingBar;
    options.showPathLabel = !options.resizingBar ? false : typeof options.showPathLabel === 'boolean' ? options.showPathLabel : true;
    options.resizeEnable = options.resizeEnable === undefined ? true : !!options.resizeEnable;
    options.resizingBarContainer = typeof options.resizingBarContainer === 'string' ? document.querySelector(options.resizingBarContainer) : options.resizingBarContainer;
    /** Character count */
    options.charCounter = options.maxCharCount > 0 ? true : typeof options.charCounter === 'boolean' ? options.charCounter : false;
    options.charCounterType = typeof options.charCounterType === 'string' ? options.charCounterType : 'char';
    options.charCounterLabel = typeof options.charCounterLabel === 'string' ? options.charCounterLabel.trim() : null;
    options.maxCharCount = lib_util.isNumber(options.maxCharCount) && options.maxCharCount > -1 ? options.maxCharCount * 1 : null;
    /** Width size */
    options.width = options.width ? lib_util.isNumber(options.width) ? options.width + 'px' : options.width : element.clientWidth ? element.clientWidth + 'px' : '100%';
    options.minWidth = (lib_util.isNumber(options.minWidth) ? options.minWidth + 'px' : options.minWidth) || '';
    options.maxWidth = (lib_util.isNumber(options.maxWidth) ? options.maxWidth + 'px' : options.maxWidth) || '';
    /** Height size */
    options.height = options.height ? lib_util.isNumber(options.height) ? options.height + 'px' : options.height : element.clientHeight ? element.clientHeight + 'px' : 'auto';
    options.minHeight = (lib_util.isNumber(options.minHeight) ? options.minHeight + 'px' : options.minHeight) || '';
    options.maxHeight = (lib_util.isNumber(options.maxHeight) ? options.maxHeight + 'px' : options.maxHeight) || '';
    /** Editing area */
    options.className = typeof options.className === 'string' && options.className.length > 0 ? ' ' + options.className : '';
    options.defaultStyle = typeof options.defaultStyle === 'string' ? options.defaultStyle : '';
    /** Defining menu items */
    options.font = !options.font ? ['Arial', 'Comic Sans MS', 'Courier New', 'Impact', 'Georgia', 'tahoma', 'Trebuchet MS', 'Verdana'] : options.font;
    options.fontSize = !options.fontSize ? null : options.fontSize;
    options.formats = !options.formats ? null : options.formats;
    options.colorList = !options.colorList ? null : options.colorList;
    options.lineHeights = !options.lineHeights ? null : options.lineHeights;
    options.paragraphStyles = !options.paragraphStyles ? null : options.paragraphStyles;
    options.textStyles = !options.textStyles ? null : options.textStyles;
    options.fontSizeUnit = typeof options.fontSizeUnit === 'string' ? options.fontSizeUnit.trim().toLowerCase() || 'px' : 'px';
    options.alignItems = typeof options.alignItems === 'object' ? options.alignItems : options.rtl ? ['right', 'center', 'left', 'justify'] : ['left', 'center', 'right', 'justify'];
    /** Image */
    options.imageResizing = options.imageResizing === undefined ? true : options.imageResizing;
    options.imageHeightShow = options.imageHeightShow === undefined ? true : !!options.imageHeightShow;
    options.imageAlignShow = options.imageAlignShow === undefined ? true : !!options.imageAlignShow;
    options.imageWidth = !options.imageWidth ? 'auto' : lib_util.isNumber(options.imageWidth) ? options.imageWidth + 'px' : options.imageWidth;
    options.imageHeight = !options.imageHeight ? 'auto' : lib_util.isNumber(options.imageHeight) ? options.imageHeight + 'px' : options.imageHeight;
    options.imageSizeOnlyPercentage = !!options.imageSizeOnlyPercentage;
    options._imageSizeUnit = options.imageSizeOnlyPercentage ? '%' : 'px';
    options.imageRotation = options.imageRotation !== undefined ? options.imageRotation : !(options.imageSizeOnlyPercentage || !options.imageHeightShow);
    options.imageFileInput = options.imageFileInput === undefined ? true : options.imageFileInput;
    options.imageUrlInput = options.imageUrlInput === undefined || !options.imageFileInput ? true : options.imageUrlInput;
    options.imageUploadHeader = options.imageUploadHeader || null;
    options.imageUploadUrl = typeof options.imageUploadUrl === 'string' ? options.imageUploadUrl : null;
    options.imageUploadSizeLimit = /\d+/.test(options.imageUploadSizeLimit) ? lib_util.getNumber(options.imageUploadSizeLimit, 0) : null;
    options.imageMultipleFile = !!options.imageMultipleFile;
    options.imageAccept = typeof options.imageAccept !== 'string' || options.imageAccept.trim() === "*" ? 'image/*' : options.imageAccept.trim() || 'image/*';
    /** Image - image gallery */
    options.imageGalleryUrl = typeof options.imageGalleryUrl === 'string' ? options.imageGalleryUrl : null;
    options.imageGalleryHeader = options.imageGalleryHeader || null;
    /** Video */
    options.videoResizing = options.videoResizing === undefined ? true : options.videoResizing;
    options.videoHeightShow = options.videoHeightShow === undefined ? true : !!options.videoHeightShow;
    options.videoAlignShow = options.videoAlignShow === undefined ? true : !!options.videoAlignShow;
    options.videoRatioShow = options.videoRatioShow === undefined ? true : !!options.videoRatioShow;
    options.videoWidth = !options.videoWidth || !lib_util.getNumber(options.videoWidth, 0) ? '' : lib_util.isNumber(options.videoWidth) ? options.videoWidth + 'px' : options.videoWidth;
    options.videoHeight = !options.videoHeight || !lib_util.getNumber(options.videoHeight, 0) ? '' : lib_util.isNumber(options.videoHeight) ? options.videoHeight + 'px' : options.videoHeight;
    options.videoSizeOnlyPercentage = !!options.videoSizeOnlyPercentage;
    options._videoSizeUnit = options.videoSizeOnlyPercentage ? '%' : 'px';
    options.videoRotation = options.videoRotation !== undefined ? options.videoRotation : !(options.videoSizeOnlyPercentage || !options.videoHeightShow);
    options.videoRatio = lib_util.getNumber(options.videoRatio, 4) || 0.5625;
    options.videoRatioList = !options.videoRatioList ? null : options.videoRatioList;
    options.youtubeQuery = (options.youtubeQuery || '').replace('?', '');
    options.videoFileInput = !!options.videoFileInput;
    options.videoUrlInput = options.videoUrlInput === undefined || !options.videoFileInput ? true : options.videoUrlInput;
    options.videoUploadHeader = options.videoUploadHeader || null;
    options.videoUploadUrl = typeof options.videoUploadUrl === 'string' ? options.videoUploadUrl : null;
    options.videoUploadSizeLimit = /\d+/.test(options.videoUploadSizeLimit) ? lib_util.getNumber(options.videoUploadSizeLimit, 0) : null;
    options.videoMultipleFile = !!options.videoMultipleFile;
    options.videoTagAttrs = options.videoTagAttrs || null;
    options.videoIframeAttrs = options.videoIframeAttrs || null;
    options.videoAccept = typeof options.videoAccept !== 'string' || options.videoAccept.trim() === "*" ? 'video/*' : options.videoAccept.trim() || 'video/*';
    /** Audio */
    options.audioWidth = !options.audioWidth ? '' : lib_util.isNumber(options.audioWidth) ? options.audioWidth + 'px' : options.audioWidth;
    options.audioHeight = !options.audioHeight ? '' : lib_util.isNumber(options.audioHeight) ? options.audioHeight + 'px' : options.audioHeight;
    options.audioFileInput = !!options.audioFileInput;
    options.audioUrlInput = options.audioUrlInput === undefined || !options.audioFileInput ? true : options.audioUrlInput;
    options.audioUploadHeader = options.audioUploadHeader || null;
    options.audioUploadUrl = typeof options.audioUploadUrl === 'string' ? options.audioUploadUrl : null;
    options.audioUploadSizeLimit = /\d+/.test(options.audioUploadSizeLimit) ? lib_util.getNumber(options.audioUploadSizeLimit, 0) : null;
    options.audioMultipleFile = !!options.audioMultipleFile;
    options.audioTagAttrs = options.audioTagAttrs || null;
    options.audioAccept = typeof options.audioAccept !== 'string' || options.audioAccept.trim() === "*" ? 'audio/*' : options.audioAccept.trim() || 'audio/*';
    /** Table */
    options.tableCellControllerPosition = typeof options.tableCellControllerPosition === 'string' ? options.tableCellControllerPosition.toLowerCase() : 'cell';
    /** Link */
    options.linkTargetNewWindow = !!options.linkTargetNewWindow;
    options.linkProtocol = typeof options.linkProtocol === 'string' ? options.linkProtocol : null;
    options.linkRel = Array.isArray(options.linkRel) ? options.linkRel : [];
    options.linkRelDefault = options.linkRelDefault || {};
    /** HR */
    // options.hrItems = options.hrItems;
    /** Key actions */
    options.tabDisable = !!options.tabDisable;
    options.shortcutsDisable = Array.isArray(options.shortcutsDisable) ? options.shortcutsDisable : [];
    options.shortcutsHint = options.shortcutsHint === undefined ? true : !!options.shortcutsHint;
    /** Defining save button */
    options.callBackSave = !options.callBackSave ? null : options.callBackSave;
    /** Templates Array */
    options.templates = !options.templates ? null : options.templates;
    /** ETC */
    options.placeholder = typeof options.placeholder === 'string' ? options.placeholder : null;
    options.mediaAutoSelect = options.mediaAutoSelect === undefined ? true : !!options.mediaAutoSelect;
    /** Buttons */
    options.buttonList = !!options.buttonList ? options.buttonList : [['undo', 'redo'], ['bold', 'underline', 'italic', 'strike', 'subscript', 'superscript'], ['removeFormat'], ['outdent', 'indent'], ['fullScreen', 'showBlocks', 'codeView'], ['preview', 'print']];

    /** RTL - buttons */
    if (options.rtl) {
      options.buttonList = options.buttonList.reverse();
    }

    /** --- Define icons --- */
    // custom icons
    options.icons = !options.icons || typeof options.icons !== 'object' ? defaultIcons : [defaultIcons, options.icons].reduce(function (_default, _new) {
      for (var key in _new) {
        if (lib_util.hasOwn(_new, key)) _default[key] = _new[key];
      }
      return _default;
    }, {});
    // rtl icons
    options.icons = !options.rtl ? options.icons : [options.icons, options.icons.rtl].reduce(function (_default, _new) {
      for (var key in _new) {
        if (lib_util.hasOwn(_new, key)) _default[key] = _new[key];
      }
      return _default;
    }, {});

    /** Private options */
    // options.__defaultFontSize;
    options.__listCommonStyle = options.__listCommonStyle || ['fontSize', 'color', 'fontFamily', 'fontWeight', 'fontStyle'];

    /** _init options */
    options._editorStyles = lib_util._setDefaultOptionStyle(options, options.defaultStyle);
  },
  _setWhitelist: function _setWhitelist(whitelist, blacklist) {
    if (typeof blacklist !== 'string') return whitelist;
    blacklist = blacklist.split('|');
    whitelist = whitelist.split('|');
    for (var i = 0, len = blacklist.length, index; i < len; i++) {
      index = whitelist.indexOf(blacklist[i]);
      if (index > -1) whitelist.splice(index, 1);
    }
    return whitelist.join('|');
  },
  /**
   * @description Suneditor's Default button list
   * @param {Object} options options
   * @private
   */
  _defaultButtons: function _defaultButtons(options) {
    var icons = options.icons;
    var lang = options.lang;
    var cmd = lib_util.isOSX_IOS ? '⌘' : 'CTRL';
    var addShift = lib_util.isOSX_IOS ? '⇧' : '+SHIFT';
    var shortcutsDisable = !options.shortcutsHint ? ['bold', 'strike', 'underline', 'italic', 'undo', 'indent', 'save'] : options.shortcutsDisable;
    var indentKey = options.rtl ? ['[', ']'] : [']', '['];
    var indentIcon = options.rtl ? [icons.outdent, icons.indent] : [icons.indent, icons.outdent];
    return {
      /** default command */
      bold: ['', lang.toolbar.bold + '<span class="se-shortcut">' + (shortcutsDisable.indexOf('bold') > -1 ? '' : cmd + '+<span class="se-shortcut-key">B</span>') + '</span>', 'bold', '', icons.bold],
      underline: ['', lang.toolbar.underline + '<span class="se-shortcut">' + (shortcutsDisable.indexOf('underline') > -1 ? '' : cmd + '+<span class="se-shortcut-key">U</span>') + '</span>', 'underline', '', icons.underline],
      italic: ['', lang.toolbar.italic + '<span class="se-shortcut">' + (shortcutsDisable.indexOf('italic') > -1 ? '' : cmd + '+<span class="se-shortcut-key">I</span>') + '</span>', 'italic', '', icons.italic],
      strike: ['', lang.toolbar.strike + '<span class="se-shortcut">' + (shortcutsDisable.indexOf('strike') > -1 ? '' : cmd + addShift + '+<span class="se-shortcut-key">S</span>') + '</span>', 'strike', '', icons.strike],
      subscript: ['', lang.toolbar.subscript, 'SUB', '', icons.subscript],
      superscript: ['', lang.toolbar.superscript, 'SUP', '', icons.superscript],
      removeFormat: ['', lang.toolbar.removeFormat, 'removeFormat', '', icons.erase],
      indent: ['', lang.toolbar.indent + '<span class="se-shortcut">' + (shortcutsDisable.indexOf('indent') > -1 ? '' : cmd + '+<span class="se-shortcut-key">' + indentKey[0] + '</span>') + '</span>', 'indent', '', indentIcon[0]],
      outdent: ['', lang.toolbar.outdent + '<span class="se-shortcut">' + (shortcutsDisable.indexOf('indent') > -1 ? '' : cmd + '+<span class="se-shortcut-key">' + indentKey[1] + '</span>') + '</span>', 'outdent', '', indentIcon[1]],
      fullScreen: ['se-code-view-enabled se-resizing-enabled', lang.toolbar.fullScreen, 'fullScreen', '', icons.expansion],
      showBlocks: ['', lang.toolbar.showBlocks, 'showBlocks', '', icons.show_blocks],
      codeView: ['se-code-view-enabled se-resizing-enabled', lang.toolbar.codeView, 'codeView', '', icons.code_view],
      undo: ['', lang.toolbar.undo + '<span class="se-shortcut">' + (shortcutsDisable.indexOf('undo') > -1 ? '' : cmd + '+<span class="se-shortcut-key">Z</span>') + '</span>', 'undo', '', icons.undo],
      redo: ['', lang.toolbar.redo + '<span class="se-shortcut">' + (shortcutsDisable.indexOf('undo') > -1 ? '' : cmd + '+<span class="se-shortcut-key">Y</span> / ' + cmd + addShift + '+<span class="se-shortcut-key">Z</span>') + '</span>', 'redo', '', icons.redo],
      preview: ['se-resizing-enabled', lang.toolbar.preview, 'preview', '', icons.preview],
      print: ['se-resizing-enabled', lang.toolbar.print, 'print', '', icons.print],
      dir: ['', lang.toolbar[options.rtl ? 'dir_ltr' : 'dir_rtl'], 'dir', '', icons[options.rtl ? 'dir_ltr' : 'dir_rtl']],
      dir_ltr: ['', lang.toolbar.dir_ltr, 'dir_ltr', '', icons.dir_ltr],
      dir_rtl: ['', lang.toolbar.dir_rtl, 'dir_rtl', '', icons.dir_rtl],
      save: ['se-resizing-enabled', lang.toolbar.save + '<span class="se-shortcut">' + (shortcutsDisable.indexOf('save') > -1 ? '' : cmd + '+<span class="se-shortcut-key">S</span>') + '</span>', 'save', '', icons.save],
      /** plugins - command */
      blockquote: ['', lang.toolbar.tag_blockquote, 'blockquote', 'command', icons.blockquote],
      /** plugins - submenu */
      font: ['se-btn-select se-btn-tool-font', lang.toolbar.font, 'font', 'submenu', '<span class="txt">' + lang.toolbar.font + '</span>' + icons.arrow_down],
      formatBlock: ['se-btn-select se-btn-tool-format', lang.toolbar.formats, 'formatBlock', 'submenu', '<span class="txt">' + lang.toolbar.formats + '</span>' + icons.arrow_down],
      fontSize: ['se-btn-select se-btn-tool-size', lang.toolbar.fontSize, 'fontSize', 'submenu', '<span class="txt">' + lang.toolbar.fontSize + '</span>' + icons.arrow_down],
      fontColor: ['', lang.toolbar.fontColor, 'fontColor', 'submenu', icons.font_color],
      hiliteColor: ['', lang.toolbar.hiliteColor, 'hiliteColor', 'submenu', icons.highlight_color],
      align: ['se-btn-align', lang.toolbar.align, 'align', 'submenu', options.rtl ? icons.align_right : icons.align_left],
      list: ['', lang.toolbar.list, 'list', 'submenu', icons.list_number],
      horizontalRule: ['btn_line', lang.toolbar.horizontalRule, 'horizontalRule', 'submenu', icons.horizontal_rule],
      table: ['', lang.toolbar.table, 'table', 'submenu', icons.table],
      lineHeight: ['', lang.toolbar.lineHeight, 'lineHeight', 'submenu', icons.line_height],
      template: ['', lang.toolbar.template, 'template', 'submenu', icons.template],
      paragraphStyle: ['', lang.toolbar.paragraphStyle, 'paragraphStyle', 'submenu', icons.paragraph_style],
      textStyle: ['', lang.toolbar.textStyle, 'textStyle', 'submenu', icons.text_style],
      /** plugins - dialog */
      link: ['', lang.toolbar.link, 'link', 'dialog', icons.link],
      image: ['', lang.toolbar.image, 'image', 'dialog', icons.image],
      video: ['', lang.toolbar.video, 'video', 'dialog', icons.video],
      audio: ['', lang.toolbar.audio, 'audio', 'dialog', icons.audio],
      math: ['', lang.toolbar.math, 'math', 'dialog', icons.math],
      /** plugins - fileBrowser */
      imageGallery: ['', lang.toolbar.imageGallery, 'imageGallery', 'fileBrowser', icons.image_gallery]
    };
  },
  /**
   * @description Create a group div containing each module
   * @returns {Object}
   * @private
   */
  _createModuleGroup: function _createModuleGroup() {
    var oDiv = lib_util.createElement('DIV');
    oDiv.className = 'se-btn-module se-btn-module-border';
    var oUl = lib_util.createElement('UL');
    oUl.className = 'se-menu-list';
    oDiv.appendChild(oUl);
    return {
      'div': oDiv,
      'ul': oUl
    };
  },
  /**
   * @description Create a button element
   * @param {string} buttonClass className in button
   * @param {string} title Title in button
   * @param {string} dataCommand The data-command property of the button
   * @param {string} dataDisplay The data-display property of the button ('dialog', 'submenu', 'command')
   * @param {string} innerHTML Html in button
   * @param {string} _disabled Button disabled
   * @param {Object} _icons Icons
   * @returns {Object}
   * @private
   */
  _createButton: function _createButton(buttonClass, title, dataCommand, dataDisplay, innerHTML, _disabled, _icons) {
    var oLi = lib_util.createElement('LI');
    var oButton = lib_util.createElement('BUTTON');
    var label = title || dataCommand;
    oButton.setAttribute('type', 'button');
    oButton.setAttribute('class', 'se-btn' + (buttonClass ? ' ' + buttonClass : '') + ' se-tooltip');
    oButton.setAttribute('data-command', dataCommand);
    oButton.setAttribute('data-display', dataDisplay);
    oButton.setAttribute('aria-label', label.replace(/<span .+<\/span>/, ''));
    oButton.setAttribute('tabindex', '-1');
    if (!innerHTML) innerHTML = '<span class="se-icon-text">!</span>';
    if (/^default\./i.test(innerHTML)) {
      innerHTML = _icons[innerHTML.replace(/^default\./i, '')];
    }
    if (/^text\./i.test(innerHTML)) {
      innerHTML = innerHTML.replace(/^text\./i, '');
      oButton.className += ' se-btn-more-text';
    }
    innerHTML += '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + label + '</span></span>';
    if (_disabled) oButton.setAttribute('disabled', true);
    oButton.innerHTML = innerHTML;
    oLi.appendChild(oButton);
    return {
      'li': oLi,
      'button': oButton
    };
  },
  /**
   * @description Create editor HTML
   * @param {Array} doc document object
   * @param {Array} buttonList option.buttonList
   * @param {Object|null} plugins Plugins
   * @param {Array} options options
   * @returns {Object} { element: (Element) Toolbar element, plugins: (Array|null) Plugins Array, pluginCallButtons: (Object), responsiveButtons: (Array) }
   * @private
   */
  _createToolBar: function _createToolBar(doc, buttonList, plugins, options) {
    var separator_vertical = doc.createElement('DIV');
    separator_vertical.className = 'se-toolbar-separator-vertical';
    var tool_bar = doc.createElement('DIV');
    tool_bar.className = 'se-toolbar sun-editor-common';
    var _buttonTray = doc.createElement('DIV');
    _buttonTray.className = 'se-btn-tray';
    tool_bar.appendChild(_buttonTray);

    /** create button list */
    buttonList = JSON.parse(JSON.stringify(buttonList));
    var icons = options.icons;
    var defaultButtonList = this._defaultButtons(options);
    var pluginCallButtons = {};
    var responsiveButtons = [];
    var module = null;
    var button = null;
    var moduleElement = null;
    var buttonElement = null;
    var pluginName = '';
    var vertical = false;
    var moreLayer = lib_util.createElement('DIV');
    moreLayer.className = 'se-toolbar-more-layer';
    buttonGroupLoop: for (var i = 0, more, moreContainer, moreCommand, buttonGroup, align; i < buttonList.length; i++) {
      more = false;
      align = '';
      buttonGroup = buttonList[i];
      moduleElement = this._createModuleGroup();

      // button object
      if (typeof buttonGroup === 'object') {
        // buttons loop
        for (var j = 0, moreButton; j < buttonGroup.length; j++) {
          button = buttonGroup[j];
          moreButton = false;
          if (/^\%\d+/.test(button) && j === 0) {
            buttonGroup[0] = button.replace(/[^\d]/g, '');
            responsiveButtons.push(buttonGroup);
            buttonList.splice(i--, 1);
            continue buttonGroupLoop;
          }
          if (typeof button === 'object') {
            if (typeof button.add === 'function') {
              pluginName = button.name;
              module = defaultButtonList[pluginName];
              plugins[pluginName] = button;
            } else {
              pluginName = button.name;
              module = [button.buttonClass, button.title, button.name, button.dataDisplay, button.innerHTML, button._disabled];
            }
          } else {
            // align
            if (/^\-/.test(button)) {
              align = button.substr(1);
              moduleElement.div.className += ' module-float-' + align;
              continue;
            }

            // rtl fix
            if (/^\#/.test(button)) {
              var option = button.substr(1);
              if (option === 'fix') moduleElement.ul.className += ' se-menu-dir-fix';
              continue;
            }

            // more button
            if (/^\:/.test(button)) {
              moreButton = true;
              var matched = button.match(/^\:([^\-]+)\-([^\-]+)\-([^\-]+)/);
              moreCommand = '__se__' + matched[1].trim();
              var title = matched[2].trim();
              var innerHTML = matched[3].trim();
              module = ['se-btn-more', title, moreCommand, 'MORE', innerHTML];
            }
            // buttons
            else {
              module = defaultButtonList[button];
            }
            pluginName = button;
            if (!module) {
              var custom = plugins[pluginName];
              if (!custom) throw Error('[SUNEDITOR.create.toolbar.fail] The button name of a plugin that does not exist. [' + pluginName + ']');
              module = [custom.buttonClass, custom.title, custom.name, custom.display, custom.innerHTML, custom._disabled];
            }
          }
          buttonElement = this._createButton(module[0], module[1], module[2], module[3], module[4], module[5], icons);
          (more ? moreContainer : moduleElement.ul).appendChild(buttonElement.li);
          if (plugins[pluginName]) {
            pluginCallButtons[pluginName] = buttonElement.button;
          }

          // more button
          if (moreButton) {
            more = true;
            moreContainer = lib_util.createElement('DIV');
            moreContainer.className = 'se-more-layer ' + moreCommand;
            moreContainer.innerHTML = '<div class="se-more-form"><ul class="se-menu-list"' + (align ? ' style="float: ' + align + ';"' : '') + '></ul></div>';
            moreLayer.appendChild(moreContainer);
            moreContainer = moreContainer.firstElementChild.firstElementChild;
          }
        }
        if (vertical) {
          var sv = separator_vertical.cloneNode(false);
          _buttonTray.appendChild(sv);
        }
        _buttonTray.appendChild(moduleElement.div);
        vertical = true;
      }
      /** line break  */else if (/^\/$/.test(buttonGroup)) {
        var enterDiv = doc.createElement('DIV');
        enterDiv.className = 'se-btn-module-enter';
        _buttonTray.appendChild(enterDiv);
        vertical = false;
      }
    }
    switch (_buttonTray.children.length) {
      case 0:
        _buttonTray.style.display = 'none';
        break;
      case 1:
        lib_util.removeClass(_buttonTray.firstElementChild, 'se-btn-module-border');
        break;
      default:
        if (options.rtl) {
          var _sv = separator_vertical.cloneNode(false);
          _sv.style.float = _buttonTray.lastElementChild.style.float;
          _buttonTray.appendChild(_sv);
        }
    }
    if (responsiveButtons.length > 0) responsiveButtons.unshift(buttonList);
    if (moreLayer.children.length > 0) _buttonTray.appendChild(moreLayer);

    // menu tray
    var _menuTray = doc.createElement('DIV');
    _menuTray.className = 'se-menu-tray';
    tool_bar.appendChild(_menuTray);

    // cover
    var tool_cover = doc.createElement('DIV');
    tool_cover.className = 'se-toolbar-cover';
    tool_bar.appendChild(tool_cover);
    if (options.hideToolbar) tool_bar.style.display = 'none';
    return {
      'element': tool_bar,
      'plugins': plugins,
      'pluginCallButtons': pluginCallButtons,
      'responsiveButtons': responsiveButtons,
      '_menuTray': _menuTray,
      '_buttonTray': _buttonTray
    };
  }
});
// CONCATENATED MODULE: ./node_modules/suneditor/src/lib/context.js
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2017 JiHong Lee.
 * MIT license.
 */


/**
 * @description Elements and variables you should have
 * @param {Element} element textarea element
 * @param {object} cons Toolbar element you created
 * @param {JSON|Object} options Inserted options
 * @returns {Object} {Elements, variables of the editor, option}
 * @private
 */
var _Context = function _Context(element, cons, options) {
  return {
    element: {
      originElement: element,
      topArea: cons._top,
      relative: cons._relative,
      toolbar: cons._toolBar,
      _toolbarShadow: cons._toolbarShadow,
      _buttonTray: cons._toolBar.querySelector('.se-btn-tray'),
      _menuTray: cons._menuTray,
      resizingBar: cons._resizingBar,
      navigation: cons._navigation,
      charWrapper: cons._charWrapper,
      charCounter: cons._charCounter,
      editorArea: cons._editorArea,
      wysiwygFrame: cons._wysiwygArea,
      wysiwyg: cons._wysiwygArea,
      // if (options.iframe) cons._wysiwygArea.contentDocument.body
      code: cons._codeArea,
      placeholder: cons._placeholder,
      loading: cons._loading,
      lineBreaker: cons._lineBreaker,
      lineBreaker_t: cons._lineBreaker_t,
      lineBreaker_b: cons._lineBreaker_b,
      resizeBackground: cons._resizeBack,
      _stickyDummy: cons._stickyDummy,
      _arrow: cons._arrow
    },
    tool: {
      cover: cons._toolBar.querySelector('.se-toolbar-cover'),
      bold: cons._toolBar.querySelector('[data-command="bold"]'),
      underline: cons._toolBar.querySelector('[data-command="underline"]'),
      italic: cons._toolBar.querySelector('[data-command="italic"]'),
      strike: cons._toolBar.querySelector('[data-command="strike"]'),
      sub: cons._toolBar.querySelector('[data-command="SUB"]'),
      sup: cons._toolBar.querySelector('[data-command="SUP"]'),
      undo: cons._toolBar.querySelector('[data-command="undo"]'),
      redo: cons._toolBar.querySelector('[data-command="redo"]'),
      save: cons._toolBar.querySelector('[data-command="save"]'),
      outdent: cons._toolBar.querySelector('[data-command="outdent"]'),
      indent: cons._toolBar.querySelector('[data-command="indent"]'),
      fullScreen: cons._toolBar.querySelector('[data-command="fullScreen"]'),
      showBlocks: cons._toolBar.querySelector('[data-command="showBlocks"]'),
      codeView: cons._toolBar.querySelector('[data-command="codeView"]'),
      dir: cons._toolBar.querySelector('[data-command="dir"]'),
      dir_ltr: cons._toolBar.querySelector('[data-command="dir_ltr"]'),
      dir_rtl: cons._toolBar.querySelector('[data-command="dir_rtl"]')
    },
    options: options,
    option: options
  };
};
/* harmony default export */ var lib_context = (_Context);
// CONCATENATED MODULE: ./node_modules/suneditor/src/lib/history.js
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2019 JiHong Lee.
 * MIT license.
 */


/* harmony default export */ var lib_history = (function (core, change) {
  var _w = core._w;
  var util = core.util;
  var delayTime = core.options.historyStackDelayTime;
  var editor = core.context.element;
  var undo = core.context.tool.undo;
  var redo = core.context.tool.redo;
  var pushDelay = null;
  var stackIndex = 0;
  var stack = [];
  function setContentsFromStack() {
    var item = stack[stackIndex];
    editor.wysiwyg.innerHTML = item.contents;
    core.setRange(util.getNodeFromPath(item.s.path, editor.wysiwyg), item.s.offset, util.getNodeFromPath(item.e.path, editor.wysiwyg), item.e.offset);
    core.focus();
    if (stack.length <= 1) {
      if (undo) undo.setAttribute('disabled', true);
      if (redo) redo.setAttribute('disabled', true);
    } else {
      if (stackIndex === 0) {
        if (undo) undo.setAttribute('disabled', true);
        if (redo) redo.removeAttribute('disabled');
      } else if (stackIndex === stack.length - 1) {
        if (undo) undo.removeAttribute('disabled');
        if (redo) redo.setAttribute('disabled', true);
      } else {
        if (undo) undo.removeAttribute('disabled');
        if (redo) redo.removeAttribute('disabled');
      }
    }
    core.controllersOff();
    core._checkComponents();
    core._setCharCount();
    core._resourcesStateChange();

    // onChange
    change();
  }
  function pushStack() {
    core._checkComponents();
    var current = core.getContents(true);
    if (!current || !!stack[stackIndex] && current === stack[stackIndex].contents) return;
    stackIndex++;
    var range = core._variable._range;
    if (stack.length > stackIndex) {
      stack = stack.slice(0, stackIndex);
      if (redo) redo.setAttribute('disabled', true);
    }
    if (!range) {
      stack[stackIndex] = {
        contents: current,
        s: {
          path: [0, 0],
          offset: [0, 0]
        },
        e: {
          path: 0,
          offset: 0
        }
      };
    } else {
      stack[stackIndex] = {
        contents: current,
        s: {
          path: util.getNodePath(range.startContainer, null, null),
          offset: range.startOffset
        },
        e: {
          path: util.getNodePath(range.endContainer, null, null),
          offset: range.endOffset
        }
      };
    }
    if (stackIndex === 1 && undo) undo.removeAttribute('disabled');
    core._setCharCount();
    // onChange
    change();
  }
  return {
    /**
     * @description History stack
     */
    stack: stack,
    /**
     * @description Saving the current status to the history object stack
     * If "delay" is true, it will be saved after (options.historyStackDelayTime || 400) miliseconds
     * If the function is called again with the "delay" argument true before it is saved, the delay time is renewal
     * You can specify the delay time by sending a number.
     * @param {Boolean|Number} delay If true, Add stack without delay time.
     */
    push: function push(delay) {
      _w.setTimeout(core._resourcesStateChange.bind(core));
      var time = typeof delay === 'number' ? delay > 0 ? delay : 0 : !delay ? 0 : delayTime;
      if (!time || pushDelay) {
        _w.clearTimeout(pushDelay);
        if (!time) {
          pushStack();
          return;
        }
      }
      pushDelay = _w.setTimeout(function () {
        _w.clearTimeout(pushDelay);
        pushDelay = null;
        pushStack();
      }, time);
    },
    /**
     * @description Undo function
     */
    undo: function undo() {
      if (stackIndex > 0) {
        stackIndex--;
        setContentsFromStack();
      }
    },
    /**
     * @description Redo function
     */
    redo: function redo() {
      if (stack.length - 1 > stackIndex) {
        stackIndex++;
        setContentsFromStack();
      }
    },
    /**
     * @description Go to the history stack for that index.
     * If "index" is -1, go to the last stack
     */
    go: function go(index) {
      stackIndex = index < 0 ? stack.length - 1 : index;
      setContentsFromStack();
    },
    /**
     * @description Get the current history stack index.
     * @returns {Number} Current Stack index
     */
    getCurrentIndex: function getCurrentIndex() {
      return stackIndex;
    },
    /**
     * @description Reset the history object
     */
    reset: function reset(ignoreChangeEvent) {
      if (undo) undo.setAttribute('disabled', true);
      if (redo) redo.setAttribute('disabled', true);
      core._variable.isChanged = false;
      if (core.context.tool.save) core.context.tool.save.setAttribute('disabled', true);
      stack.splice(0);
      stackIndex = 0;

      // pushStack
      stack[stackIndex] = {
        contents: core.getContents(true),
        s: {
          path: [0, 0],
          offset: 0
        },
        e: {
          path: [0, 0],
          offset: 0
        }
      };
      if (!ignoreChangeEvent) change();
    },
    /**
     * @description Reset the disabled state of the buttons to fit the current stack.
     * @private
     */
    _resetCachingButton: function _resetCachingButton() {
      editor = core.context.element;
      undo = core.context.tool.undo;
      redo = core.context.tool.redo;
      if (stackIndex === 0) {
        if (undo) undo.setAttribute('disabled', true);
        if (redo && stackIndex === stack.length - 1) redo.setAttribute('disabled', true);
        core._variable.isChanged = false;
        if (core.context.tool.save) core.context.tool.save.setAttribute('disabled', true);
      } else if (stackIndex === stack.length - 1) {
        if (redo) redo.setAttribute('disabled', true);
      }
    },
    /**
     * @description Remove all stacks and remove the timeout function.
     * @private
     */
    _destroy: function _destroy() {
      if (pushDelay) _w.clearTimeout(pushDelay);
      stack = null;
    }
  };
});
// CONCATENATED MODULE: ./node_modules/suneditor/src/plugins/modules/_notice.js
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2017 JiHong Lee.
 * MIT license.
 */


/* harmony default export */ var _notice = ({
  name: 'notice',
  /**
   * @description Constructor
   * @param {Object} core Core object 
   */
  add: function add(core) {
    var context = core.context;
    context.notice = {};

    /** dialog */
    var notice_div = core.util.createElement('DIV');
    var notice_span = core.util.createElement('SPAN');
    var notice_button = core.util.createElement('BUTTON');
    notice_div.className = 'se-notice';
    notice_button.className = 'close';
    notice_button.setAttribute('aria-label', 'Close');
    notice_button.setAttribute('title', core.lang.dialogBox.close);
    notice_button.innerHTML = core.icons.cancel;
    notice_div.appendChild(notice_span);
    notice_div.appendChild(notice_button);
    context.notice.modal = notice_div;
    context.notice.message = notice_span;

    /** add event listeners */
    notice_button.addEventListener('click', this.onClick_cancel.bind(core));

    /** append html */
    context.element.editorArea.appendChild(notice_div);

    /** empty memory */
    notice_div = null;
  },
  /**
   * @description Event when clicking the cancel button
   * @param {MouseEvent} e Event object
   */
  onClick_cancel: function onClick_cancel(e) {
    e.preventDefault();
    e.stopPropagation();
    this.plugins.notice.close.call(this);
  },
  /**
   * @description  Open the notice panel
   * @param {String} text Notice message
   */
  open: function open(text) {
    this.context.notice.message.textContent = text;
    this.context.notice.modal.style.display = 'block';
  },
  /**
   * @description  Open the notice panel
   */
  close: function close() {
    this.context.notice.modal.style.display = 'none';
  }
});
// CONCATENATED MODULE: ./node_modules/suneditor/src/lib/core.js
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2017 JiHong Lee.
 * MIT license.
 */








/**
 * @description SunEditor constuctor function.
 * create core object and event registration.
 * core, event, functions
 * @param {Object} context
 * @param {Object} pluginCallButtons
 * @param {Object} plugins 
 * @param {Object} lang
 * @param {Object} options
 * @param {Object} _responsiveButtons
 * @returns {Object} functions Object
 */
/* harmony default export */ var lib_core = (function (context, pluginCallButtons, plugins, lang, options, _responsiveButtons) {
  var _d = context.element.originElement.ownerDocument || document;
  var _w = _d.defaultView || window;
  var util = lib_util;
  var icons = options.icons;

  /**
   * @description editor core object
   * should always bind this object when registering an event in the plug-in.
   */
  var core = {
    _d: _d,
    _w: _w,
    _parser: new _w.DOMParser(),
    _prevRtl: options.rtl,
    _editorHeight: 0,
    _editorHeightPadding: 0,
    _listCamel: options.__listCommonStyle,
    _listKebab: util.camelToKebabCase(options.__listCommonStyle),
    /**
     * @description Document object of the iframe if created as an iframe || _d
     * @private
     */
    _wd: null,
    /**
     * @description Window object of the iframe if created as an iframe || _w
     * @private
     */
    _ww: null,
    /**
     * @description Closest ShadowRoot to editor if found
     * @private
     */
    _shadowRoot: null,
    /**
     * @description Block controller mousedown events in "shadowRoot" environment
     * @private
     */
    _shadowRootControllerEventTarget: null,
    /**
     * @description Util object
     */
    util: util,
    /**
     * @description Functions object
     */
    functions: null,
    /**
     * @description Editor options
     */
    options: null,
    /**
     * @description Computed style of the wysiwyg area (window.getComputedStyle(context.element.wysiwyg))
     */
    wwComputedStyle: null,
    /**
     * @description Notice object
     */
    notice: _notice,
    /**
     * @description Default icons object
     */
    icons: icons,
    /**
     * @description History object for undo, redo
     */
    history: null,
    /**
     * @description Elements and user options parameters of the suneditor
     */
    context: context,
    /**
     * @description Plugin buttons
     */
    pluginCallButtons: pluginCallButtons,
    /**
     * @description Loaded plugins
     */
    plugins: plugins || {},
    /**
     * @description Whether the plugin is initialized
     */
    initPlugins: {},
    /**
     * @description Object for managing submenu elements
     * @private
     */
    _targetPlugins: {},
    /**
     * @description Save rendered submenus and containers
     * @private
     */
    _menuTray: {},
    /**
     * @description loaded language
     */
    lang: lang,
    /**
     * @description The selection node (core.getSelectionNode()) to which the effect was last applied
     */
    effectNode: null,
    /**
     * @description submenu element
     */
    submenu: null,
    /**
     * @description container element
     */
    container: null,
    /**
     * @description current subment name
     * @private
     */
    _submenuName: '',
    /**
     * @description binded submenuOff method
     * @private
     */
    _bindedSubmenuOff: null,
    /**
     * @description binded containerOff method
     * @private
     */
    _bindedContainerOff: null,
    /**
     * @description active button element in submenu
     */
    submenuActiveButton: null,
    /**
     * @description active button element in container
     */
    containerActiveButton: null,
    /**
     * @description The elements array to be processed unvisible when the controllersOff function is executed (resizing, link modified button, table controller)
     */
    controllerArray: [],
    /**
     * @description The name of the plugin that called the currently active controller
     */
    currentControllerName: '',
    /**
     * @description The target element of current controller
     */
    currentControllerTarget: null,
    /**
     * @description The file component object of current selected file tag (getFileComponent)
     */
    currentFileComponentInfo: null,
    /**
     * @description An array of buttons whose class name is not "se-code-view-enabled"
     */
    codeViewDisabledButtons: [],
    /**
     * @description An array of buttons whose class name is not "se-resizing-enabled"
     */
    resizingDisabledButtons: [],
    /**
     * @description active more layer element in submenu
     * @private
     */
    _moreLayerActiveButton: null,
    /**
     * @description Tag whitelist RegExp object used in "_consistencyCheckOfHTML" method
     * ^(options._editorTagsWhitelist)$
     * @private
     */
    _htmlCheckWhitelistRegExp: null,
    /**
     * @description Tag blacklist RegExp object used in "_consistencyCheckOfHTML" method
     * @private
     */
    _htmlCheckBlacklistRegExp: null,
    /**
     * @description RegExp when using check disallowd tags. (b, i, ins, strike, s)
     * @private
     */
    _disallowedTextTagsRegExp: null,
    /**
     * @description Editor tags whitelist (RegExp object)
     * util.createTagsWhitelist(options._editorTagsWhitelist)
     */
    editorTagsWhitelistRegExp: null,
    /**
     * @description Editor tags blacklist (RegExp object)
     * util.createTagsBlacklist(options.tagsBlacklist)
     */
    editorTagsBlacklistRegExp: null,
    /**
     * @description Tag whitelist when pasting (RegExp object)
     * util.createTagsWhitelist(options.pasteTagsWhitelist)
     */
    pasteTagsWhitelistRegExp: null,
    /**
     * @description Tag blacklist when pasting (RegExp object)
     * util.createTagsBlacklist(options.pasteTagsBlacklist)
     */
    pasteTagsBlacklistRegExp: null,
    /**
     * @description Boolean value of whether the editor has focus
     */
    hasFocus: false,
    /**
     * @description Boolean value of whether the editor is disabled
     */
    isDisabled: false,
    /**
     * @description Boolean value of whether the editor is readOnly
     */
    isReadOnly: false,
    /**
     * @description Attributes whitelist used by the cleanHTML method
     * @private
     */
    _attributesWhitelistRegExp: null,
    _attributesWhitelistRegExp_all_data: null,
    /**
     * @description Attributes blacklist used by the cleanHTML method
     * @private
     */
    _attributesBlacklistRegExp: null,
    /**
     * @description Attributes of tags whitelist used by the cleanHTML method
     * @private
     */
    _attributesTagsWhitelist: null,
    /**
     * @description Attributes of tags blacklist used by the cleanHTML method
     * @private
     */
    _attributesTagsBlacklist: null,
    /**
     * @description binded controllersOff method
     * @private
     */
    _bindControllersOff: null,
    /**
     * @description Is inline mode?
     * @private
     */
    _isInline: null,
    /**
     * @description Is balloon|balloon-always mode?
     * @private
     */
    _isBalloon: null,
    /**
     * @description Is balloon-always mode?
     * @private
     */
    _isBalloonAlways: null,
    /**
     * @description Required value when using inline mode to sticky toolbar
     * @private
     */
    _inlineToolbarAttr: {
      top: '',
      width: '',
      isShow: false
    },
    /**
     * @description Variable that controls the "blur" event in the editor of inline or balloon mode when the focus is moved to submenu
     * @private
     */
    _notHideToolbar: false,
    /**
     * @description Variable value that sticky toolbar mode
     * @private
     */
    _sticky: false,
    /**
     * @description Variables for controlling focus and blur events
     * @private
     */
    _antiBlur: false,
    /**
     * @description Component line breaker element
     * @private
     */
    _lineBreaker: null,
    _lineBreakerButton: null,
    /**
     * @description If true, (initialize, reset) all indexes of image, video information
     * @private
     */
    _componentsInfoInit: true,
    _componentsInfoReset: false,
    /**
     * @description Plugins array with "active" method.
     * "activePlugins" runs the "add" method when creating the editor.
     */
    activePlugins: null,
    /**
     * @description Information of tags that should maintain HTML structure, style, class name, etc. (In use by "math" plugin)
     * When inserting "html" such as paste, it is executed on the "html" to be inserted. (core.cleanHTML)
     * Basic Editor Actions:
     * 1. All classes not starting with "__se__" or "se-" in the editor are removed.
     * 2. The style of all tags except the "span" tag is removed from the editor.
     * "managedTagsInfo" structure ex:
     * managedTagsInfo: {
     *   query: '.__se__xxx, se-xxx'
     *   map: {
     *     '__se__xxx': method.bind(core),
     *     'se-xxx': method.bind(core),
     *   }
     * }
     * @example
     * Define in the following return format in the "managedTagInfo" function of the plugin.
     * managedTagInfo() => {
     *  return {
     *    className: 'string', // Class name to identify the tag. ("__se__xxx", "se-xxx")
     *    // Change the html of the "element". ("element" is the element found with "className".)
     *    // "method" is executed by binding "core".
     *    method: function (element) {
     *      // this === core
     *      element.innerHTML = // (rendered html);
     *    }
     *  }
     * }
     */
    managedTagsInfo: null,
    /**
     * @description cashing: options.charCounterType === 'byte-html'
     * @private
     */
    _charTypeHTML: false,
    /**
     * @description Array of "checkFileInfo" functions with the core bound
     * (Plugins with "checkFileInfo" and "resetFileInfo" methods)
     * "fileInfoPlugins" runs the "add" method when creating the editor.
     * "checkFileInfo" method is always call just before the "change" event.
     * @private
     */
    _fileInfoPluginsCheck: null,
    /**
     * @description Array of "resetFileInfo" functions with the core bound
     * (Plugins with "checkFileInfo" and "resetFileInfo" methods)
     * "checkFileInfo" method is always call just before the "functions.setOptions" method.
     * @private
     */
    _fileInfoPluginsReset: null,
    /**
     * @description Variables for file component management
     * @private
     */
    _fileManager: {
      tags: null,
      regExp: null,
      queryString: null,
      pluginRegExp: null,
      pluginMap: null
    },
    /**
     * @description Elements that need to change text or className for each selection change
     * After creating the editor, "activePlugins" are added.
     * @property {Element} STRONG bold button
     * @property {Element} U underline button
     * @property {Element} EM italic button
     * @property {Element} DEL strike button
     * @property {Element} SUB subscript button
     * @property {Element} SUP superscript button
     * @property {Element} OUTDENT outdent button
     * @property {Element} INDENT indent button
     */
    commandMap: null,
    /**
     * @description CSS properties related to style tags 
     * @private
     */
    _commandMapStyles: {
      STRONG: ['font-weight'],
      U: ['text-decoration'],
      EM: ['font-style'],
      DEL: ['text-decoration']
    },
    /**
     * @description Style button related to edit area
     * @property {Element} fullScreen fullScreen button element
     * @property {Element} showBlocks showBlocks button element
     * @property {Element} codeView codeView button element
     * @private
     */
    _styleCommandMap: null,
    /**
     * @private
     */
    _cleanStyleRegExp: {
      span: new _w.RegExp('\\s*[^-a-zA-Z](font-family|font-size|color|background-color)\\s*:[^;]+(?!;)*', 'ig'),
      format: new _w.RegExp('\\s*[^-a-zA-Z](text-align|margin-left|margin-right)\\s*:[^;]+(?!;)*', 'ig'),
      fontSizeUnit: new _w.RegExp('\\d+' + options.fontSizeUnit + '$', 'i')
    },
    /**
     * @description Variables used internally in editor operation
     * @property {Boolean} isCodeView State of code view
     * @property {Boolean} isFullScreen State of full screen
     * @property {Number} innerHeight_fullScreen InnerHeight in editor when in full screen
     * @property {Number} resizeClientY Remember the vertical size of the editor before resizing the editor (Used when calculating during resize operation)
     * @property {Number} tabSize Indent size of tab (4)
     * @property {Number} codeIndent Indent size of Code view mode (2)
     * @property {Number} minResizingSize Minimum size of editing area when resized {Number} (.se-wrapper-inner {min-height: 65px;} || 65)
     * @property {Array} currentNodes  An array of the current cursor's node structure
     * @private
     */
    _variable: {
      isChanged: false,
      isCodeView: false,
      isFullScreen: false,
      innerHeight_fullScreen: 0,
      resizeClientY: 0,
      tabSize: 4,
      codeIndent: 2,
      minResizingSize: util.getNumber(context.element.wysiwygFrame.style.minHeight || '65', 0),
      currentNodes: [],
      currentNodesMap: [],
      _range: null,
      _selectionNode: null,
      _originCssText: context.element.topArea.style.cssText,
      _bodyOverflow: '',
      _editorAreaOriginCssText: '',
      _wysiwygOriginCssText: '',
      _codeOriginCssText: '',
      _fullScreenAttrs: {
        sticky: false,
        balloon: false,
        inline: false
      },
      _lineBreakComp: null,
      _lineBreakDir: ''
    },
    /**
     * @description Save the current buttons states to "allCommandButtons" object
     * @private
     */
    _saveButtonStates: function _saveButtonStates() {
      if (!this.allCommandButtons) this.allCommandButtons = {};
      var currentButtons = this.context.element._buttonTray.querySelectorAll('.se-menu-list button[data-display]');
      for (var i = 0, element, command; i < currentButtons.length; i++) {
        element = currentButtons[i];
        command = element.getAttribute('data-command');
        this.allCommandButtons[command] = element;
      }
    },
    /**
     * @description Recover the current buttons states from "allCommandButtons" object
     * @private
     */
    _recoverButtonStates: function _recoverButtonStates() {
      if (this.allCommandButtons) {
        var currentButtons = this.context.element._buttonTray.querySelectorAll('.se-menu-list button[data-display]');
        for (var i = 0, button, command, oldButton; i < currentButtons.length; i++) {
          button = currentButtons[i];
          command = button.getAttribute('data-command');
          oldButton = this.allCommandButtons[command];
          if (oldButton) {
            button.parentElement.replaceChild(oldButton, button);
            if (this.context.tool[command]) this.context.tool[command] = oldButton;
          }
        }
      }
    },
    /**
     * @description If the plugin is not added, add the plugin and call the 'add' function.
     * If the plugin is added call callBack function.
     * @param {String} pluginName The name of the plugin to call
     * @param {function} callBackFunction Function to be executed immediately after module call
     * @param {Element|null} _target Plugin target button (This is not necessary if you have a button list when creating the editor)
     */
    callPlugin: function callPlugin(pluginName, callBackFunction, _target) {
      _target = _target || pluginCallButtons[pluginName];
      if (!this.plugins[pluginName]) {
        throw Error('[SUNEDITOR.core.callPlugin.fail] The called plugin does not exist or is in an invalid format. (pluginName:"' + pluginName + '")');
      } else if (!this.initPlugins[pluginName]) {
        this.plugins[pluginName].add(this, _target);
        this.initPlugins[pluginName] = true;
      } else if (typeof this._targetPlugins[pluginName] === 'object' && !!_target) {
        this.initMenuTarget(pluginName, _target, this._targetPlugins[pluginName]);
      }
      if (this.plugins[pluginName].active && !this.commandMap[pluginName] && !!_target) {
        this.commandMap[pluginName] = _target;
        this.activePlugins.push(pluginName);
      }
      if (typeof callBackFunction === 'function') callBackFunction();
    },
    /**
     * @description If the module is not added, add the module and call the 'add' function
     * @param {Array} moduleArray module object's Array [dialog, resizing]
     */
    addModule: function addModule(moduleArray) {
      for (var i = 0, len = moduleArray.length, moduleName; i < len; i++) {
        moduleName = moduleArray[i].name;
        if (!this.plugins[moduleName]) {
          this.plugins[moduleName] = moduleArray[i];
        }
        if (!this.initPlugins[moduleName]) {
          this.initPlugins[moduleName] = true;
          if (typeof this.plugins[moduleName].add === 'function') this.plugins[moduleName].add(this);
        }
      }
    },
    /**
     * @description Gets the current editor-relative scroll offset.
     * @returns {Object} {top, left}
     */
    getGlobalScrollOffset: function getGlobalScrollOffset() {
      var t = 0,
        l = 0;
      var el = context.element.topArea;
      while (el) {
        t += el.scrollTop;
        l += el.scrollLeft;
        el = el.parentElement;
      }
      el = this._shadowRoot ? this._shadowRoot.host : null;
      while (el) {
        t += el.scrollTop;
        l += el.scrollLeft;
        el = el.parentElement;
      }
      return {
        top: t,
        left: l
      };
    },
    /**
     * @description Method for managing submenu element.
     * You must add the "submenu" element using the this method at custom plugin.
     * @param {String} pluginName Plugin name
     * @param {Element|null} target Target button
     * @param {Element} menu Submenu element
     */
    initMenuTarget: function initMenuTarget(pluginName, target, menu) {
      if (!target) {
        this._targetPlugins[pluginName] = menu;
      } else {
        context.element._menuTray.appendChild(menu);
        this._targetPlugins[pluginName] = true;
        this._menuTray[target.getAttribute('data-command')] = menu;
      }
    },
    /**
     * @description Enable submenu
     * @param {Element} element Submenu's button element to call
     */
    submenuOn: function submenuOn(element) {
      if (this._bindedSubmenuOff) this._bindedSubmenuOff();
      if (this._bindControllersOff) this.controllersOff();
      var submenuName = this._submenuName = element.getAttribute('data-command');
      var menu = this.submenu = this._menuTray[submenuName];
      this.submenuActiveButton = element;
      this._setMenuPosition(element, menu);
      this._bindedSubmenuOff = this.submenuOff.bind(this);
      this.addDocEvent('mousedown', this._bindedSubmenuOff, false);
      if (this.plugins[submenuName].on) this.plugins[submenuName].on.call(this);
      this._antiBlur = true;
    },
    /**
     * @description Disable submenu
     */
    submenuOff: function submenuOff() {
      this.removeDocEvent('mousedown', this._bindedSubmenuOff);
      this._bindedSubmenuOff = null;
      if (this.submenu) {
        this._submenuName = '';
        this.submenu.style.display = 'none';
        this.submenu = null;
        util.removeClass(this.submenuActiveButton, 'on');
        this.submenuActiveButton = null;
        this._notHideToolbar = false;
      }
      this._antiBlur = false;
    },
    /**
     * @description Disable more layer
     */
    moreLayerOff: function moreLayerOff() {
      if (this._moreLayerActiveButton) {
        var layer = context.element.toolbar.querySelector('.' + this._moreLayerActiveButton.getAttribute('data-command'));
        layer.style.display = 'none';
        util.removeClass(this._moreLayerActiveButton, 'on');
        this._moreLayerActiveButton = null;
      }
    },
    /**
     * @description Enable container
     * @param {Element} element Container's button element to call
     */
    containerOn: function containerOn(element) {
      if (this._bindedContainerOff) this._bindedContainerOff();
      var containerName = this._containerName = element.getAttribute('data-command');
      var menu = this.container = this._menuTray[containerName];
      this.containerActiveButton = element;
      this._setMenuPosition(element, menu);
      this._bindedContainerOff = this.containerOff.bind(this);
      this.addDocEvent('mousedown', this._bindedContainerOff, false);
      if (this.plugins[containerName].on) this.plugins[containerName].on.call(this);
      this._antiBlur = true;
    },
    /**
     * @description Disable container
     */
    containerOff: function containerOff() {
      this.removeDocEvent('mousedown', this._bindedContainerOff);
      this._bindedContainerOff = null;
      if (this.container) {
        this._containerName = '';
        this.container.style.display = 'none';
        this.container = null;
        util.removeClass(this.containerActiveButton, 'on');
        this.containerActiveButton = null;
        this._notHideToolbar = false;
      }
      this._antiBlur = false;
    },
    /**
     * @description Set the menu position. (submenu, container)
     * @param {*} element Button element
     * @param {*} menu Menu element
     * @private
     */
    _setMenuPosition: function _setMenuPosition(element, menu) {
      menu.style.visibility = 'hidden';
      menu.style.display = 'block';
      menu.style.height = '';
      util.addClass(element, 'on');
      var toolbar = this.context.element.toolbar;
      var toolbarW = toolbar.offsetWidth;
      var toolbarOffset = event._getEditorOffsets(context.element.toolbar);
      var menuW = menu.offsetWidth;
      var l = element.parentElement.offsetLeft + 3;

      // rtl
      if (options.rtl) {
        var elementW = element.offsetWidth;
        var rtlW = menuW > elementW ? menuW - elementW : 0;
        var rtlL = rtlW > 0 ? 0 : elementW - menuW;
        menu.style.left = l - rtlW + rtlL + 'px';
        if (toolbarOffset.left > event._getEditorOffsets(menu).left) {
          menu.style.left = '0px';
        }
      } else {
        var overLeft = toolbarW <= menuW ? 0 : toolbarW - (l + menuW);
        if (overLeft < 0) menu.style.left = l + overLeft + 'px';else menu.style.left = l + 'px';
      }

      // get element top
      var t = 0;
      var offsetEl = element;
      while (offsetEl && offsetEl !== toolbar) {
        t += offsetEl.offsetTop;
        offsetEl = offsetEl.offsetParent;
      }
      var bt = t;
      if (this._isBalloon) {
        t += toolbar.offsetTop + element.offsetHeight;
      } else {
        t -= element.offsetHeight;
      }

      // set menu position
      var toolbarTop = toolbarOffset.top;
      var menuHeight = menu.offsetHeight;
      var scrollTop = this.getGlobalScrollOffset().top;
      var menuHeight_bottom = _w.innerHeight - (toolbarTop - scrollTop + bt + element.parentElement.offsetHeight);
      if (menuHeight_bottom < menuHeight) {
        var menuTop = -1 * (menuHeight - bt + 3);
        var insTop = toolbarTop - scrollTop + menuTop;
        var menuHeight_top = menuHeight + (insTop < 0 ? insTop : 0);
        if (menuHeight_top > menuHeight_bottom) {
          menu.style.height = menuHeight_top + 'px';
          menuTop = -1 * (menuHeight_top - bt + 3);
        } else {
          menu.style.height = menuHeight_bottom + 'px';
          menuTop = bt + element.parentElement.offsetHeight;
        }
        menu.style.top = menuTop + 'px';
      } else {
        menu.style.top = bt + element.parentElement.offsetHeight + 'px';
      }
      menu.style.visibility = '';
    },
    /**
     * @description Show controller at editor area (controller elements, function, "controller target element(@Required)", "controller name(@Required)", etc..)
     * @param {*} arguments controller elements, functions..
     */
    controllersOn: function controllersOn() {
      if (this._bindControllersOff) this._bindControllersOff();
      this.controllerArray = [];
      for (var i = 0, arg; i < arguments.length; i++) {
        arg = arguments[i];
        if (!arg) continue;
        if (typeof arg === 'string') {
          this.currentControllerName = arg;
          continue;
        }
        if (typeof arg === 'function') {
          this.controllerArray.push(arg);
          continue;
        }
        if (!util.hasClass(arg, 'se-controller')) {
          this.currentControllerTarget = arg;
          this.currentFileComponentInfo = this.getFileComponent(arg);
          continue;
        }
        if (arg.style) {
          arg.style.display = 'block';
          if (this._shadowRoot && this._shadowRootControllerEventTarget.indexOf(arg) === -1) {
            arg.addEventListener('mousedown', function (e) {
              e.preventDefault();
              e.stopPropagation();
            });
            this._shadowRootControllerEventTarget.push(arg);
          }
        }
        this.controllerArray.push(arg);
      }
      this._bindControllersOff = this.controllersOff.bind(this);
      this.addDocEvent('mousedown', this._bindControllersOff, false);
      this.addDocEvent('keydown', this._bindControllersOff, false);
      this._antiBlur = true;
      if (typeof functions.showController === 'function') functions.showController(this.currentControllerName, this.controllerArray, this);
    },
    /**
     * @description Hide controller at editor area (link button, image resize button..)
     * @param {KeyboardEvent|MouseEvent|null} e Event object when called from mousedown and keydown events registered in "core.controllersOn"
     */
    controllersOff: function controllersOff(e) {
      this._lineBreaker.style.display = 'none';
      var len = this.controllerArray.length;
      if (e && e.target && len > 0) {
        for (var i = 0; i < len; i++) {
          if (typeof this.controllerArray[i].contains === 'function' && this.controllerArray[i].contains(e.target)) return;
        }
      }
      if (this._fileManager.pluginRegExp.test(this.currentControllerName) && e && e.type === 'keydown' && e.keyCode !== 27) return;
      context.element.lineBreaker_t.style.display = context.element.lineBreaker_b.style.display = 'none';
      this._variable._lineBreakComp = null;
      this.currentControllerName = '';
      this.currentControllerTarget = null;
      this.currentFileComponentInfo = null;
      this.effectNode = null;
      if (!this._bindControllersOff) return;
      this.removeDocEvent('mousedown', this._bindControllersOff);
      this.removeDocEvent('keydown', this._bindControllersOff);
      this._bindControllersOff = null;
      if (len > 0) {
        for (var _i = 0; _i < len; _i++) {
          if (typeof this.controllerArray[_i] === 'function') this.controllerArray[_i]();else this.controllerArray[_i].style.display = 'none';
        }
        this.controllerArray = [];
      }
      this._antiBlur = false;
    },
    /**
     * @description Specify the position of the controller.
     * @param {Element} controller Controller element.
     * @param {Element} referEl Element that is the basis of the controller's position.
     * @param {String} position Type of position ("top" | "bottom")
     * When using the "top" position, there should not be an arrow on the controller.
     * When using the "bottom" position there should be an arrow on the controller.
     * @param {Object} addOffset These are the left and top values that need to be added specially. 
     * This argument is required. - {left: 0, top: 0}
     * Please enter the value based on ltr mode.
     * Calculated automatically in rtl mode.
     */
    setControllerPosition: function setControllerPosition(controller, referEl, position, addOffset) {
      if (options.rtl) addOffset.left *= -1;
      var offset = util.getOffset(referEl, context.element.wysiwygFrame);
      controller.style.visibility = 'hidden';
      controller.style.display = 'block';

      // Height value of the arrow element is 11px
      var topMargin = position === 'top' ? -(controller.offsetHeight + 2) : referEl.offsetHeight + 12;
      controller.style.top = offset.top + topMargin + addOffset.top + 'px';
      var l = offset.left - context.element.wysiwygFrame.scrollLeft + addOffset.left;
      var controllerW = controller.offsetWidth;
      var referElW = referEl.offsetWidth;
      var allow = util.hasClass(controller.firstElementChild, 'se-arrow') ? controller.firstElementChild : null;

      // rtl (Width value of the arrow element is 22px)
      if (options.rtl) {
        var rtlW = controllerW > referElW ? controllerW - referElW : 0;
        var rtlL = rtlW > 0 ? 0 : referElW - controllerW;
        controller.style.left = l - rtlW + rtlL + 'px';
        if (rtlW > 0) {
          if (allow) allow.style.left = (controllerW - 14 < 10 + rtlW ? controllerW - 14 : 10 + rtlW) + 'px';
        }
        var overSize = context.element.wysiwygFrame.offsetLeft - controller.offsetLeft;
        if (overSize > 0) {
          controller.style.left = '0px';
          if (allow) allow.style.left = overSize + 'px';
        }
      } else {
        controller.style.left = l + 'px';
        var _overSize = context.element.wysiwygFrame.offsetWidth - (controller.offsetLeft + controllerW);
        if (_overSize < 0) {
          controller.style.left = controller.offsetLeft + _overSize + 'px';
          if (allow) allow.style.left = 20 - _overSize + 'px';
        } else {
          if (allow) allow.style.left = '20px';
        }
      }
      controller.style.visibility = '';
    },
    /**
     * @description javascript execCommand
     * @param {String} command javascript execCommand function property
     * @param {Boolean|undefined} showDefaultUI javascript execCommand function property
     * @param {String|undefined} value javascript execCommand function property
     */
    execCommand: function execCommand(command, showDefaultUI, value) {
      this._wd.execCommand(command, showDefaultUI, command === 'formatBlock' ? '<' + value + '>' : value);
      // history stack
      this.history.push(true);
    },
    /**
     * @description Focus to wysiwyg area using "native focus function"
     */
    nativeFocus: function nativeFocus() {
      this.__focus();
      this._editorRange();
    },
    /**
     * @description Focus method
     * @private
     */
    __focus: function __focus() {
      var caption = util.getParentElement(this.getSelectionNode(), 'figcaption');
      if (caption) {
        caption.focus();
      } else {
        context.element.wysiwyg.focus();
      }
    },
    /**
     * @description Focus to wysiwyg area
     */
    focus: function focus() {
      if (context.element.wysiwygFrame.style.display === 'none') return;
      if (options.iframe) {
        this.nativeFocus();
      } else {
        try {
          var range = this.getRange();
          if (range.startContainer === range.endContainer && util.isWysiwygDiv(range.startContainer)) {
            var currentNode = range.commonAncestorContainer.children[range.startOffset];
            if (!util.isFormatElement(currentNode) && !util.isComponent(currentNode)) {
              var format = util.createElement(options.defaultTag);
              var br = util.createElement('BR');
              format.appendChild(br);
              context.element.wysiwyg.insertBefore(format, currentNode);
              this.setRange(br, 0, br, 0);
              return;
            }
          }
          this.setRange(range.startContainer, range.startOffset, range.endContainer, range.endOffset);
        } catch (e) {
          this.nativeFocus();
        }
      }
      event._applyTagEffects();
      if (this._isBalloon) event._toggleToolbarBalloon();
    },
    /**
     * @description If "focusEl" is a component, then that component is selected; if it is a format element, the last text is selected
     * If "focusEdge" is null, then selected last element
     * @param {Element|null} focusEl Focus element
     */
    focusEdge: function focusEdge(focusEl) {
      if (!focusEl) focusEl = context.element.wysiwyg.lastElementChild;
      var fileComponentInfo = this.getFileComponent(focusEl);
      if (fileComponentInfo) {
        this.selectComponent(fileComponentInfo.target, fileComponentInfo.pluginName);
      } else if (focusEl) {
        focusEl = util.getChildElement(focusEl, function (current) {
          return current.childNodes.length === 0 || current.nodeType === 3;
        }, true);
        if (!focusEl) this.nativeFocus();else this.setRange(focusEl, focusEl.textContent.length, focusEl, focusEl.textContent.length);
      } else {
        this.focus();
      }
    },
    /**
     * @description Focusout to wysiwyg area (.blur())
     */
    blur: function blur() {
      if (options.iframe) {
        context.element.wysiwygFrame.blur();
      } else {
        context.element.wysiwyg.blur();
      }
    },
    /**
     * @description Set current editor's range object and return.
     * @param {Node} startCon The startContainer property of the selection object.
     * @param {Number} startOff The startOffset property of the selection object.
     * @param {Node} endCon The endContainer property of the selection object.
     * @param {Number} endOff The endOffset property of the selection object.
     * @returns {Object} Range object.
     */
    setRange: function setRange(startCon, startOff, endCon, endOff) {
      if (!startCon || !endCon) return;
      if (startOff > startCon.textContent.length) startOff = startCon.textContent.length;
      if (endOff > endCon.textContent.length) endOff = endCon.textContent.length;
      if (util.isFormatElement(startCon)) {
        startCon = startCon.childNodes[startOff] || startCon.childNodes[startOff - 1] || startCon;
        startOff = startOff > 0 ? startCon.nodeType === 1 ? 1 : startCon.textContent ? startCon.textContent.length : 0 : 0;
      }
      if (util.isFormatElement(endCon)) {
        endCon = endCon.childNodes[endOff] || endCon.childNodes[endOff - 1] || endCon;
        endOff = endOff > 0 ? endCon.nodeType === 1 ? 1 : endCon.textContent ? endCon.textContent.length : 0 : 0;
      }
      var range = this._wd.createRange();
      try {
        range.setStart(startCon, startOff);
        range.setEnd(endCon, endOff);
      } catch (error) {
        console.warn('[SUNEDITOR.core.focus.error] ' + error);
        this.nativeFocus();
        return;
      }
      var selection = this.getSelection();
      if (selection.removeAllRanges) {
        selection.removeAllRanges();
      }
      selection.addRange(range);
      this._rangeInfo(range, this.getSelection());
      if (options.iframe) this.__focus();
      return range;
    },
    /**
     * @description Remove range object and button effect
     */
    removeRange: function removeRange() {
      this._variable._range = null;
      this._variable._selectionNode = null;
      if (this.hasFocus) this.getSelection().removeAllRanges();
      this._setKeyEffect([]);
    },
    /**
     * @description Get current editor's range object
     * @returns {Object}
     */
    getRange: function getRange() {
      var range = this._variable._range || this._createDefaultRange();
      var selection = this.getSelection();
      if (range.collapsed === selection.isCollapsed || !context.element.wysiwyg.contains(selection.focusNode)) return range;
      if (selection.rangeCount > 0) {
        this._variable._range = selection.getRangeAt(0);
        return this._variable._range;
      } else {
        var sc = selection.anchorNode,
          ec = selection.focusNode,
          so = selection.anchorOffset,
          eo = selection.focusOffset;
        var compareValue = util.compareElements(sc, ec);
        var rightDir = compareValue.ancestor && (compareValue.result === 0 ? so <= eo : compareValue.result > 1 ? true : false);
        return this.setRange(rightDir ? sc : ec, rightDir ? so : eo, rightDir ? ec : sc, rightDir ? eo : so);
      }
    },
    /**
     * @description If the "range" object is a non-editable area, add a line at the top of the editor and update the "range" object.
     * Returns a new "range" or argument "range".
     * @param {Object} range core.getRange()
     * @param {Element|null} container If there is "container" argument, it creates a line in front of the container.
     * @returns {Object} range
     */
    getRange_addLine: function getRange_addLine(range, container) {
      if (this._selectionVoid(range)) {
        var wysiwyg = context.element.wysiwyg;
        var op = util.createElement(options.defaultTag);
        op.innerHTML = '<br>';
        wysiwyg.insertBefore(op, container && container !== wysiwyg ? container.nextElementSibling : wysiwyg.firstElementChild);
        this.setRange(op.firstElementChild, 0, op.firstElementChild, 1);
        range = this._variable._range;
      }
      return range;
    },
    /**
     * @description Get window selection obejct
     * @returns {Object}
     */
    getSelection: function getSelection() {
      return this._shadowRoot && this._shadowRoot.getSelection ? this._shadowRoot.getSelection() : this._ww.getSelection();
    },
    /**
     * @description Get current select node
     * @returns {Node}
     */
    getSelectionNode: function getSelectionNode() {
      if (!context.element.wysiwyg.contains(this._variable._selectionNode)) this._editorRange();
      if (!this._variable._selectionNode) {
        var selectionNode = util.getChildElement(context.element.wysiwyg.firstChild, function (current) {
          return current.childNodes.length === 0 || current.nodeType === 3;
        }, false);
        if (!selectionNode) {
          this._editorRange();
        } else {
          this._variable._selectionNode = selectionNode;
          return selectionNode;
        }
      }
      return this._variable._selectionNode;
    },
    /**
     * @description Saving the range object and the currently selected node of editor
     * @private
     */
    _editorRange: function _editorRange() {
      var selection = this.getSelection();
      if (!selection) return null;
      var range = null;
      if (selection.rangeCount > 0) {
        range = selection.getRangeAt(0);
      } else {
        range = this._createDefaultRange();
      }
      if (util.isFormatElement(range.endContainer) && range.endOffset === 0) {
        range = this.setRange(range.startContainer, range.startOffset, range.startContainer, range.startContainer.length);
      }
      this._rangeInfo(range, selection);
    },
    /**
     * @description Set "range" and "selection" info.
     * @param {Object} range range object.
     * @param {Object} selection selection object.
     */
    _rangeInfo: function _rangeInfo(range, selection) {
      var selectionNode = null;
      this._variable._range = range;
      if (range.collapsed) {
        if (util.isWysiwygDiv(range.commonAncestorContainer)) selectionNode = range.commonAncestorContainer.children[range.startOffset] || range.commonAncestorContainer;else selectionNode = range.commonAncestorContainer;
      } else {
        selectionNode = selection.extentNode || selection.anchorNode;
      }
      this._variable._selectionNode = selectionNode;
    },
    /**
     * @description Return the range object of editor's first child node
     * @returns {Object}
     * @private
     */
    _createDefaultRange: function _createDefaultRange() {
      var wysiwyg = context.element.wysiwyg;
      wysiwyg.focus();
      var range = this._wd.createRange();
      var focusEl = wysiwyg.firstElementChild;
      if (!focusEl) {
        focusEl = util.createElement(options.defaultTag);
        focusEl.innerHTML = '<br>';
        wysiwyg.appendChild(focusEl);
      }
      range.setStart(focusEl, 0);
      range.setEnd(focusEl, 0);
      return range;
    },
    /**
     * @description Returns true if there is no valid "selection".
     * @param {Object} range core.getRange()
     * @returns {Object} range
     * @private
     */
    _selectionVoid: function _selectionVoid(range) {
      var comm = range.commonAncestorContainer;
      return util.isWysiwygDiv(range.startContainer) && util.isWysiwygDiv(range.endContainer) || /FIGURE/i.test(comm.nodeName) || this._fileManager.regExp.test(comm.nodeName) || util.isMediaComponent(comm);
    },
    /**
     * @description Reset range object to text node selected status.
     * @returns {Boolean} Returns false if there is no valid selection.
     * @private
     */
    _resetRangeToTextNode: function _resetRangeToTextNode() {
      var range = this.getRange();
      if (this._selectionVoid(range)) return false;
      var startCon = range.startContainer;
      var startOff = range.startOffset;
      var endCon = range.endContainer;
      var endOff = range.endOffset;
      var tempCon, tempOffset, tempChild;
      if (util.isFormatElement(startCon)) {
        if (!startCon.childNodes[startOff]) {
          startCon = startCon.lastChild || startCon;
          startOff = startCon.textContent.length;
        } else {
          startCon = startCon.childNodes[startOff] || startCon;
          startOff = 0;
        }
        while (startCon && startCon.nodeType === 1 && startCon.firstChild) {
          startCon = startCon.firstChild || startCon;
          startOff = 0;
        }
      }
      if (util.isFormatElement(endCon)) {
        endCon = endCon.childNodes[endOff] || endCon.lastChild || endCon;
        while (endCon && endCon.nodeType === 1 && endCon.lastChild) {
          endCon = endCon.lastChild;
        }
        endOff = endCon.textContent.length;
      }

      // startContainer
      tempCon = util.isWysiwygDiv(startCon) ? context.element.wysiwyg.firstChild : startCon;
      tempOffset = startOff;
      if (util.isBreak(tempCon) || tempCon.nodeType === 1 && tempCon.childNodes.length > 0) {
        var onlyBreak = util.isBreak(tempCon);
        if (!onlyBreak) {
          while (tempCon && !util.isBreak(tempCon) && tempCon.nodeType === 1) {
            tempCon = tempCon.childNodes[tempOffset] || tempCon.nextElementSibling || tempCon.nextSibling;
            tempOffset = 0;
          }
          var format = util.getFormatElement(tempCon, null);
          if (format === util.getRangeFormatElement(format, null)) {
            format = util.createElement(util.getParentElement(tempCon, util.isCell) ? 'DIV' : options.defaultTag);
            tempCon.parentNode.insertBefore(format, tempCon);
            format.appendChild(tempCon);
          }
        }
        if (util.isBreak(tempCon)) {
          var emptyText = util.createTextNode(util.zeroWidthSpace);
          tempCon.parentNode.insertBefore(emptyText, tempCon);
          tempCon = emptyText;
          if (onlyBreak) {
            if (startCon === endCon) {
              endCon = tempCon;
              endOff = 1;
            }
          }
        }
      }

      // set startContainer
      startCon = tempCon;
      startOff = tempOffset;

      // endContainer
      tempCon = util.isWysiwygDiv(endCon) ? context.element.wysiwyg.lastChild : endCon;
      tempOffset = endOff;
      if (util.isBreak(tempCon) || tempCon.nodeType === 1 && tempCon.childNodes.length > 0) {
        var _onlyBreak = util.isBreak(tempCon);
        if (!_onlyBreak) {
          while (tempCon && !util.isBreak(tempCon) && tempCon.nodeType === 1) {
            tempChild = tempCon.childNodes;
            if (tempChild.length === 0) break;
            tempCon = tempChild[tempOffset > 0 ? tempOffset - 1 : tempOffset] || !/FIGURE/i.test(tempChild[0].nodeName) ? tempChild[0] : tempCon.previousElementSibling || tempCon.previousSibling || startCon;
            tempOffset = tempOffset > 0 ? tempCon.textContent.length : tempOffset;
          }
          var _format = util.getFormatElement(tempCon, null);
          if (_format === util.getRangeFormatElement(_format, null)) {
            _format = util.createElement(util.isCell(_format) ? 'DIV' : options.defaultTag);
            tempCon.parentNode.insertBefore(_format, tempCon);
            _format.appendChild(tempCon);
          }
        }
        if (util.isBreak(tempCon)) {
          var _emptyText = util.createTextNode(util.zeroWidthSpace);
          tempCon.parentNode.insertBefore(_emptyText, tempCon);
          tempCon = _emptyText;
          tempOffset = 1;
          if (_onlyBreak && !tempCon.previousSibling) {
            util.removeItem(endCon);
          }
        }
      }

      // set endContainer
      endCon = tempCon;
      endOff = tempOffset;

      // set Range
      this.setRange(startCon, startOff, endCon, endOff);
      return true;
    },
    /**
     * @description Returns a "formatElement"(util.isFormatElement) array from the currently selected range.
     * @param {Function|null} validation The validation function. (Replaces the default validation function-util.isFormatElement(current))
     * @returns {Array}
     */
    getSelectedElements: function getSelectedElements(validation) {
      if (!this._resetRangeToTextNode()) return [];
      var range = this.getRange();
      if (util.isWysiwygDiv(range.startContainer)) {
        var children = context.element.wysiwyg.children;
        if (children.length === 0) return [];
        this.setRange(children[0], 0, children[children.length - 1], children[children.length - 1].textContent.trim().length);
        range = this.getRange();
      }
      var startCon = range.startContainer;
      var endCon = range.endContainer;
      var commonCon = range.commonAncestorContainer;

      // get line nodes
      var lineNodes = util.getListChildren(commonCon, function (current) {
        return validation ? validation(current) : util.isFormatElement(current);
      });
      if (!util.isWysiwygDiv(commonCon) && !util.isRangeFormatElement(commonCon)) lineNodes.unshift(util.getFormatElement(commonCon, null));
      if (startCon === endCon || lineNodes.length === 1) return lineNodes;
      var startLine = util.getFormatElement(startCon, null);
      var endLine = util.getFormatElement(endCon, null);
      var startIdx = null;
      var endIdx = null;
      var onlyTable = function onlyTable(current) {
        return util.isTable(current) ? /^TABLE$/i.test(current.nodeName) : true;
      };
      var startRangeEl = util.getRangeFormatElement(startLine, onlyTable);
      var endRangeEl = util.getRangeFormatElement(endLine, onlyTable);
      if (util.isTable(startRangeEl) && util.isListCell(startRangeEl.parentNode)) startRangeEl = startRangeEl.parentNode;
      if (util.isTable(endRangeEl) && util.isListCell(endRangeEl.parentNode)) endRangeEl = endRangeEl.parentNode;
      var sameRange = startRangeEl === endRangeEl;
      for (var i = 0, len = lineNodes.length, line; i < len; i++) {
        line = lineNodes[i];
        if (startLine === line || !sameRange && line === startRangeEl) {
          startIdx = i;
          continue;
        }
        if (endLine === line || !sameRange && line === endRangeEl) {
          endIdx = i;
          break;
        }
      }
      if (startIdx === null) startIdx = 0;
      if (endIdx === null) endIdx = lineNodes.length - 1;
      return lineNodes.slice(startIdx, endIdx + 1);
    },
    /**
     * @description Get format elements and components from the selected area. (P, DIV, H[1-6], OL, UL, TABLE..)
     * If some of the component are included in the selection, get the entire that component.
     * @param {Boolean} removeDuplicate If true, if there is a parent and child tag among the selected elements, the child tag is excluded.
     * @returns {Array}
     */
    getSelectedElementsAndComponents: function getSelectedElementsAndComponents(removeDuplicate) {
      var commonCon = this.getRange().commonAncestorContainer;
      var myComponent = util.getParentElement(commonCon, util.isComponent);
      var selectedLines = util.isTable(commonCon) ? this.getSelectedElements(null) : this.getSelectedElements(function (current) {
        var component = this.getParentElement(current, this.isComponent);
        return this.isFormatElement(current) && (!component || component === myComponent) || this.isComponent(current) && !this.getFormatElement(current);
      }.bind(util));
      if (removeDuplicate) {
        for (var i = 0, len = selectedLines.length; i < len; i++) {
          for (var j = i - 1; j >= 0; j--) {
            if (selectedLines[j].contains(selectedLines[i])) {
              selectedLines.splice(i, 1);
              i--;
              len--;
              break;
            }
          }
        }
      }
      return selectedLines;
    },
    /**
     * @description Determine if this offset is the edge offset of container
     * @param {Node} container The node of the selection object. (range.startContainer..)
     * @param {Number} offset The offset of the selection object. (core.getRange().startOffset...)
     * @param {String|undefined} dir Select check point - Both edge, Front edge or End edge. ("front": Front edge, "end": End edge, undefined: Both edge)
     * @returns {Boolean}
     */
    isEdgePoint: function isEdgePoint(container, offset, dir) {
      return dir !== 'end' && offset === 0 || (!dir || dir !== 'front') && !container.nodeValue && offset === 1 || (!dir || dir === 'end') && !!container.nodeValue && offset === container.nodeValue.length;
    },
    /**
     * @description Check if the container and offset values are the edges of the format tag
     * @param {Node} container The node of the selection object. (range.startContainer..)
     * @param {Number} offset The offset of the selection object. (core.getRange().startOffset...)
     * @param {String} dir Select check point - "front": Front edge, "end": End edge, undefined: Both edge.
     * @returns {Array|null}
     * @private
     */
    _isEdgeFormat: function _isEdgeFormat(node, offset, dir) {
      if (!this.isEdgePoint(node, offset, dir)) return false;
      var result = [];
      dir = dir === 'front' ? 'previousSibling' : 'nextSibling';
      while (node && !util.isFormatElement(node) && !util.isWysiwygDiv(node)) {
        if (!node[dir] || util.isBreak(node[dir]) && !node[dir][dir]) {
          if (node.nodeType === 1) result.push(node.cloneNode(false));
          node = node.parentNode;
        } else {
          return null;
        }
      }
      return result;
    },
    /**
     * @description Show loading box
     */
    showLoading: function showLoading() {
      context.element.loading.style.display = 'block';
    },
    /**
     * @description Close loading box
     */
    closeLoading: function closeLoading() {
      context.element.loading.style.display = 'none';
    },
    /**
     * @description Append format element to sibling node of argument element.
     * If the "formatNodeName" argument value is present, the tag of that argument value is inserted,
     * If not, the currently selected format tag is inserted.
     * @param {Element} element Insert as siblings of that element
     * @param {String|Element|null} formatNode Node name or node obejct to be inserted
     * @returns {Element}
     */
    appendFormatTag: function appendFormatTag(element, formatNode) {
      if (!element || !element.parentNode) return null;
      var currentFormatEl = util.getFormatElement(this.getSelectionNode(), null);
      var oFormat = null;
      if (!util.isFormatElement(element) && util.isFreeFormatElement(currentFormatEl || element.parentNode)) {
        oFormat = util.createElement('BR');
      } else {
        var oFormatName = formatNode ? typeof formatNode === 'string' ? formatNode : formatNode.nodeName : util.isFormatElement(currentFormatEl) && !util.isRangeFormatElement(currentFormatEl) && !util.isFreeFormatElement(currentFormatEl) ? currentFormatEl.nodeName : options.defaultTag;
        oFormat = util.createElement(oFormatName);
        oFormat.innerHTML = '<br>';
        if (formatNode && typeof formatNode !== 'string' || !formatNode && util.isFormatElement(currentFormatEl)) {
          util.copyTagAttributes(oFormat, formatNode || currentFormatEl);
        }
      }
      if (util.isCell(element)) element.insertBefore(oFormat, element.nextElementSibling);else element.parentNode.insertBefore(oFormat, element.nextElementSibling);
      return oFormat;
    },
    /**
     * @description The method to insert a element and return. (used elements : table, hr, image, video)
     * If "element" is "HR", insert and return the new line.
     * @param {Element} element Element to be inserted
     * @param {Boolean} notHistoryPush When true, it does not update the history stack and the selection object and return EdgeNodes (util.getEdgeChildNodes)
     * @param {Boolean} checkCharCount If true, if "options.maxCharCount" is exceeded when "element" is added, null is returned without addition.
     * @param {Boolean} notSelect If true, Do not automatically select the inserted component.
     * @returns {Element}
     */
    insertComponent: function insertComponent(element, notHistoryPush, checkCharCount, notSelect) {
      if (this.isReadOnly || checkCharCount && !this.checkCharCount(element, null)) {
        return null;
      }
      var r = this.removeNode();
      this.getRange_addLine(this.getRange(), r.container);
      var oNode = null;
      var selectionNode = this.getSelectionNode();
      var formatEl = util.getFormatElement(selectionNode, null);
      if (util.isListCell(formatEl)) {
        this.insertNode(element, selectionNode === formatEl ? null : r.container.nextSibling, false);
        if (!element.nextSibling) element.parentNode.appendChild(util.createElement('BR'));
      } else {
        if (this.getRange().collapsed && (r.container.nodeType === 3 || util.isBreak(r.container))) {
          var depthFormat = util.getParentElement(r.container, function (current) {
            return this.isRangeFormatElement(current);
          }.bind(util));
          oNode = util.splitElement(r.container, r.offset, !depthFormat ? 0 : util.getElementDepth(depthFormat) + 1);
          if (oNode) formatEl = oNode.previousSibling;
        }
        this.insertNode(element, util.isRangeFormatElement(formatEl) ? null : formatEl, false);
        if (formatEl && util.onlyZeroWidthSpace(formatEl)) util.removeItem(formatEl);
      }
      if (!notSelect) {
        this.setRange(element, 0, element, 0);
        var fileComponentInfo = this.getFileComponent(element);
        if (fileComponentInfo) {
          this.selectComponent(fileComponentInfo.target, fileComponentInfo.pluginName);
        } else if (oNode) {
          oNode = util.getEdgeChildNodes(oNode, null).sc || oNode;
          this.setRange(oNode, 0, oNode, 0);
        }
      }

      // history stack
      if (!notHistoryPush) this.history.push(1);
      return oNode || element;
    },
    /**
     * @description Gets the file component and that plugin name
     * return: {target, component, pluginName} | null
     * @param {Element} element Target element (figure tag, component div, file tag)
     * @returns {Object|null}
     */
    getFileComponent: function getFileComponent(element) {
      if (!this._fileManager.queryString || !element) return null;
      var target, pluginName;
      if (/^FIGURE$/i.test(element.nodeName) || /se-component/.test(element.className)) {
        target = element.querySelector(this._fileManager.queryString);
      }
      if (!target && element.nodeName && this._fileManager.regExp.test(element.nodeName)) {
        target = element;
      }
      if (target) {
        pluginName = this._fileManager.pluginMap[target.nodeName.toLowerCase()];
        if (pluginName) {
          return {
            target: target,
            component: util.getParentElement(target, util.isComponent),
            pluginName: pluginName
          };
        }
      }
      return null;
    },
    /**
     * @description The component(image, video) is selected and the resizing module is called.
     * @param {Element} element Element tag (img, iframe, video)
     * @param {String} pluginName Plugin name (image, video)
     */
    selectComponent: function selectComponent(element, pluginName) {
      if (util.isUneditableComponent(util.getParentElement(element, util.isComponent)) || util.isUneditableComponent(element)) return false;
      if (!this.hasFocus) this.focus();
      var plugin = this.plugins[pluginName];
      if (!plugin) return;
      _w.setTimeout(function () {
        if (typeof plugin.select === 'function') this.callPlugin(pluginName, plugin.select.bind(this, element), null);
        this._setComponentLineBreaker(element);
      }.bind(this));
    },
    /**
     * @description Set line breaker of component
     * @param {Element} element Element tag (img, iframe, video)
     * @private
     */
    _setComponentLineBreaker: function _setComponentLineBreaker(element) {
      // line breaker
      this._lineBreaker.style.display = 'none';
      var container = util.getParentElement(element, util.isComponent);
      var t_style = context.element.lineBreaker_t.style;
      var b_style = context.element.lineBreaker_b.style;
      var target = this.context.resizing.resizeContainer.style.display === 'block' ? this.context.resizing.resizeContainer : element;
      var isList = util.isListCell(container.parentNode);
      var componentTop, wScroll, w;
      // top
      if (isList ? !container.previousSibling : !util.isFormatElement(container.previousElementSibling)) {
        this._variable._lineBreakComp = container;
        wScroll = context.element.wysiwyg.scrollTop;
        componentTop = util.getOffset(element, context.element.wysiwygFrame).top + wScroll;
        w = target.offsetWidth / 2 / 2;
        t_style.top = componentTop - wScroll - 12 + 'px';
        t_style.left = util.getOffset(target).left + w + 'px';
        t_style.display = 'block';
      } else {
        t_style.display = 'none';
      }
      // bottom
      if (isList ? !container.nextSibling : !util.isFormatElement(container.nextElementSibling)) {
        if (!componentTop) {
          this._variable._lineBreakComp = container;
          wScroll = context.element.wysiwyg.scrollTop;
          componentTop = util.getOffset(element, context.element.wysiwygFrame).top + wScroll;
          w = target.offsetWidth / 2 / 2;
        }
        b_style.top = componentTop + target.offsetHeight - wScroll - 12 + 'px';
        b_style.left = util.getOffset(target).left + target.offsetWidth - w - 24 + 'px';
        b_style.display = 'block';
      } else {
        b_style.display = 'none';
      }
    },
    _checkDuplicateNode: function _checkDuplicateNode(oNode, parentNode) {
      (function recursionFunc(current) {
        core._dupleCheck(current, parentNode);
        var childNodes = current.childNodes;
        for (var i = 0, len = childNodes.length; i < len; i++) {
          recursionFunc(childNodes[i]);
        }
      })(oNode);
    },
    _dupleCheck: function _dupleCheck(oNode, parentNode) {
      if (!util.isTextStyleElement(oNode)) return;
      var oStyles = (oNode.style.cssText.match(/[^;]+;/g) || []).map(function (v) {
        return v.trim();
      });
      var nodeName = oNode.nodeName;
      if (/^span$/i.test(nodeName) && oStyles.length === 0) return oNode;
      var duple = false;
      (function recursionFunc(ancestor) {
        if (util.isWysiwygDiv(ancestor) || !util.isTextStyleElement(ancestor)) return;
        if (ancestor.nodeName === nodeName) {
          duple = true;
          var styles = ancestor.style.cssText.match(/[^;]+;/g) || [];
          for (var i = 0, len = styles.length, j; i < len; i++) {
            if ((j = oStyles.indexOf(styles[i].trim())) > -1) {
              oStyles.splice(j, 1);
            }
          }
          for (var _i2 = 0, _len = ancestor.classList.length; _i2 < _len; _i2++) {
            oNode.classList.remove(ancestor.classList[_i2]);
          }
        }
        recursionFunc(ancestor.parentElement);
      })(parentNode);
      if (duple) {
        if (!(oNode.style.cssText = oStyles.join(' '))) {
          oNode.setAttribute('style', '');
          oNode.removeAttribute('style');
        }
        if (!oNode.attributes.length) {
          oNode.setAttribute('data-se-duple', 'true');
        }
      }
      return oNode;
    },
    /**
     * @description Delete selected node and insert argument value node and return.
     * If the "afterNode" exists, it is inserted after the "afterNode"
     * Inserting a text node merges with both text nodes on both sides and returns a new "{ container, startOffset, endOffset }".
     * @param {Node} oNode Element to be inserted
     * @param {Node|null} afterNode If the node exists, it is inserted after the node
     * @param {Boolean} checkCharCount If true, if "options.maxCharCount" is exceeded when "element" is added, null is returned without addition.
     * @returns {Object|Node|null}
     */
    insertNode: function insertNode(oNode, afterNode, checkCharCount) {
      if (this.isReadOnly || checkCharCount && !this.checkCharCount(oNode, null)) {
        return null;
      }
      var range = this.getRange();
      var line = util.isListCell(range.commonAncestorContainer) ? range.commonAncestorContainer : util.getFormatElement(this.getSelectionNode(), null);
      var insertListCell = util.isListCell(line) && (util.isListCell(oNode) || util.isList(oNode));
      var parentNode,
        originAfter,
        tempAfterNode,
        tempParentNode = null;
      var freeFormat = util.isFreeFormatElement(line);
      var isFormats = !freeFormat && (util.isFormatElement(oNode) || util.isRangeFormatElement(oNode)) || util.isComponent(oNode);
      if (insertListCell) {
        tempAfterNode = afterNode || util.isList(oNode) ? line.lastChild : line.nextElementSibling;
        tempParentNode = util.isList(oNode) ? line : (tempAfterNode || line).parentNode;
      }
      if (!afterNode && (isFormats || util.isComponent(oNode) || util.isMedia(oNode))) {
        var isEdge = this.isEdgePoint(range.endContainer, range.endOffset, 'end');
        var r = this.removeNode();
        var container = r.container;
        var prevContainer = container === r.prevContainer && range.collapsed ? null : r.prevContainer;
        if (insertListCell && prevContainer) {
          tempParentNode = prevContainer.nodeType === 3 ? prevContainer.parentNode : prevContainer;
          if (tempParentNode.contains(container)) {
            var sameParent = true;
            tempAfterNode = container;
            while (tempAfterNode.parentNode && tempAfterNode.parentNode !== tempParentNode) {
              tempAfterNode = tempAfterNode.parentNode;
              sameParent = false;
            }
            if (sameParent && container === prevContainer) tempAfterNode = tempAfterNode.nextSibling;
          } else {
            tempAfterNode = null;
          }
        } else if (insertListCell && util.isListCell(container) && !line.parentElement) {
          line = util.createElement('LI');
          tempParentNode.appendChild(line);
          container.appendChild(tempParentNode);
          tempAfterNode = null;
        } else if (container.nodeType === 3 || util.isBreak(container) || insertListCell) {
          var depthFormat = util.getParentElement(container, function (current) {
            return this.isRangeFormatElement(current) || this.isListCell(current);
          }.bind(util));
          afterNode = util.splitElement(container, r.offset, !depthFormat ? 0 : util.getElementDepth(depthFormat) + 1);
          if (afterNode) {
            if (insertListCell) {
              if (line.contains(container)) {
                var subList = util.isList(line.lastElementChild);
                var newCell = null;
                if (!isEdge) {
                  newCell = line.cloneNode(false);
                  newCell.appendChild(afterNode.textContent.trim() ? afterNode : util.createTextNode(util.zeroWidthSpace));
                }
                if (subList) {
                  if (!newCell) {
                    newCell = line.cloneNode(false);
                    newCell.appendChild(util.createTextNode(util.zeroWidthSpace));
                  }
                  newCell.appendChild(line.lastElementChild);
                }
                if (newCell) {
                  line.parentNode.insertBefore(newCell, line.nextElementSibling);
                  tempAfterNode = afterNode = newCell;
                }
              }
            } else {
              afterNode = afterNode.previousSibling;
            }
          }
        }
      }
      range = !afterNode && !isFormats ? this.getRange_addLine(this.getRange(), null) : this.getRange();
      var commonCon = range.commonAncestorContainer;
      var startOff = range.startOffset;
      var endOff = range.endOffset;
      var formatRange = range.startContainer === commonCon && util.isFormatElement(commonCon);
      var startCon = formatRange ? commonCon.childNodes[startOff] || commonCon.childNodes[0] || range.startContainer : range.startContainer;
      var endCon = formatRange ? commonCon.childNodes[endOff] || commonCon.childNodes[commonCon.childNodes.length - 1] || range.endContainer : range.endContainer;
      if (!insertListCell) {
        if (!afterNode) {
          parentNode = startCon;
          if (startCon.nodeType === 3) {
            parentNode = startCon.parentNode;
          }

          /** No Select range node */
          if (range.collapsed) {
            if (commonCon.nodeType === 3) {
              if (commonCon.textContent.length > endOff) afterNode = commonCon.splitText(endOff);else afterNode = commonCon.nextSibling;
            } else {
              if (!util.isBreak(parentNode)) {
                var c = parentNode.childNodes[startOff];
                var focusNode = c && c.nodeType === 3 && util.onlyZeroWidthSpace(c) && util.isBreak(c.nextSibling) ? c.nextSibling : c;
                if (focusNode) {
                  if (!focusNode.nextSibling && util.isBreak(focusNode)) {
                    parentNode.removeChild(focusNode);
                    afterNode = null;
                  } else {
                    afterNode = util.isBreak(focusNode) && !util.isBreak(oNode) ? focusNode : focusNode.nextSibling;
                  }
                } else {
                  afterNode = null;
                }
              } else {
                afterNode = parentNode;
                parentNode = parentNode.parentNode;
              }
            }
          } else {
            /** Select range nodes */
            var isSameContainer = startCon === endCon;
            if (isSameContainer) {
              if (this.isEdgePoint(endCon, endOff)) afterNode = endCon.nextSibling;else afterNode = endCon.splitText(endOff);
              var removeNode = startCon;
              if (!this.isEdgePoint(startCon, startOff)) removeNode = startCon.splitText(startOff);
              parentNode.removeChild(removeNode);
              if (parentNode.childNodes.length === 0 && isFormats) {
                parentNode.innerHTML = '<br>';
              }
            } else {
              var removedTag = this.removeNode();
              var _container = removedTag.container;
              var _prevContainer = removedTag.prevContainer;
              if (_container && _container.childNodes.length === 0 && isFormats) {
                if (util.isFormatElement(_container)) {
                  _container.innerHTML = '<br>';
                } else if (util.isRangeFormatElement(_container)) {
                  _container.innerHTML = '<' + options.defaultTag + '><br></' + options.defaultTag + '>';
                }
              }
              if (util.isListCell(_container) && oNode.nodeType === 3) {
                parentNode = _container;
                afterNode = null;
              } else if (!isFormats && _prevContainer) {
                parentNode = _prevContainer.nodeType === 3 ? _prevContainer.parentNode : _prevContainer;
                if (parentNode.contains(_container)) {
                  var _sameParent = true;
                  afterNode = _container;
                  while (afterNode.parentNode && afterNode.parentNode !== parentNode) {
                    afterNode = afterNode.parentNode;
                    _sameParent = false;
                  }
                  if (_sameParent && _container === _prevContainer) afterNode = afterNode.nextSibling;
                } else {
                  afterNode = null;
                }
              } else {
                afterNode = isFormats ? endCon : _container === _prevContainer ? _container.nextSibling : _container;
                parentNode = !afterNode || !afterNode.parentNode ? commonCon : afterNode.parentNode;
              }
              while (afterNode && !util.isFormatElement(afterNode) && afterNode.parentNode !== commonCon) {
                afterNode = afterNode.parentNode;
              }
            }
          }
        } else {
          // has afterNode
          parentNode = afterNode.parentNode;
          afterNode = afterNode.nextSibling;
          originAfter = true;
        }
      }
      try {
        // set node
        if (!insertListCell) {
          if (util.isWysiwygDiv(afterNode) || parentNode === context.element.wysiwyg.parentNode) {
            parentNode = context.element.wysiwyg;
            afterNode = null;
          }
          if (util.isFormatElement(oNode) || util.isRangeFormatElement(oNode) || !util.isListCell(parentNode) && util.isComponent(oNode)) {
            var oldParent = parentNode;
            if (util.isList(afterNode)) {
              parentNode = afterNode;
              afterNode = null;
            } else if (util.isListCell(afterNode)) {
              parentNode = afterNode.previousElementSibling || afterNode;
            } else if (!originAfter && !afterNode) {
              var _r = this.removeNode();
              var _container2 = _r.container.nodeType === 3 ? util.isListCell(util.getFormatElement(_r.container, null)) ? _r.container : util.getFormatElement(_r.container, null) || _r.container.parentNode : _r.container;
              var rangeCon = util.isWysiwygDiv(_container2) || util.isRangeFormatElement(_container2);
              parentNode = rangeCon ? _container2 : _container2.parentNode;
              afterNode = rangeCon ? null : _container2.nextSibling;
            }
            if (oldParent.childNodes.length === 0 && parentNode !== oldParent) util.removeItem(oldParent);
          }
          if (isFormats && !freeFormat && !util.isRangeFormatElement(parentNode) && !util.isListCell(parentNode) && !util.isWysiwygDiv(parentNode)) {
            afterNode = parentNode.nextElementSibling;
            parentNode = parentNode.parentNode;
          }
          if (util.isWysiwygDiv(parentNode) && (oNode.nodeType === 3 || util.isBreak(oNode))) {
            var fNode = util.createElement(options.defaultTag);
            fNode.appendChild(oNode);
            oNode = fNode;
          }
        }

        // insert--
        if (insertListCell) {
          if (!tempParentNode.parentNode) {
            parentNode = context.element.wysiwyg;
            afterNode = null;
          } else {
            parentNode = tempParentNode;
            afterNode = tempAfterNode;
          }
        } else {
          afterNode = parentNode === afterNode ? parentNode.lastChild : afterNode;
        }
        if (util.isListCell(oNode) && !util.isList(parentNode)) {
          if (util.isListCell(parentNode)) {
            afterNode = parentNode.nextElementSibling;
            parentNode = parentNode.parentNode;
          } else {
            var ul = util.createElement('ol');
            parentNode.insertBefore(ul, afterNode);
            parentNode = ul;
            afterNode = null;
          }
          insertListCell = true;
        }
        this._checkDuplicateNode(oNode, parentNode);
        parentNode.insertBefore(oNode, afterNode);
        if (insertListCell) {
          if (util.onlyZeroWidthSpace(line.textContent.trim())) {
            util.removeItem(line);
            oNode = oNode.lastChild;
          } else {
            var chList = util.getArrayItem(line.children, util.isList);
            if (chList) {
              if (oNode !== chList) {
                oNode.appendChild(chList);
                oNode = chList.previousSibling;
              } else {
                parentNode.appendChild(oNode);
                oNode = parentNode;
              }
              if (util.onlyZeroWidthSpace(line.textContent.trim())) {
                util.removeItem(line);
              }
            }
          }
        }
      } catch (error) {
        parentNode.appendChild(oNode);
        console.warn('[SUNEDITOR.insertNode.warn] ' + error);
      } finally {
        var dupleNodes = parentNode.querySelectorAll('[data-se-duple]');
        if (dupleNodes.length > 0) {
          for (var i = 0, len = dupleNodes.length, d, _c, ch, parent; i < len; i++) {
            d = dupleNodes[i];
            ch = d.childNodes;
            parent = d.parentNode;
            while (ch[0]) {
              _c = ch[0];
              parent.insertBefore(_c, d);
            }
            if (d === oNode) oNode = _c;
            util.removeItem(d);
          }
        }
        if ((util.isFormatElement(oNode) || util.isComponent(oNode)) && startCon === endCon) {
          var cItem = util.getFormatElement(commonCon, null);
          if (cItem && cItem.nodeType === 1 && util.isEmptyLine(cItem)) {
            util.removeItem(cItem);
          }
        }
        if (freeFormat && (util.isFormatElement(oNode) || util.isRangeFormatElement(oNode))) {
          oNode = this._setIntoFreeFormat(oNode);
        }
        if (!util.isComponent(oNode)) {
          var offset = 1;
          if (oNode.nodeType === 3) {
            var previous = oNode.previousSibling;
            var next = oNode.nextSibling;
            var previousText = !previous || previous.nodeType === 1 || util.onlyZeroWidthSpace(previous) ? '' : previous.textContent;
            var nextText = !next || next.nodeType === 1 || util.onlyZeroWidthSpace(next) ? '' : next.textContent;
            if (previous && previousText.length > 0) {
              oNode.textContent = previousText + oNode.textContent;
              util.removeItem(previous);
            }
            if (next && next.length > 0) {
              oNode.textContent += nextText;
              util.removeItem(next);
            }
            var newRange = {
              container: oNode,
              startOffset: previousText.length,
              endOffset: oNode.textContent.length - nextText.length
            };
            this.setRange(oNode, newRange.startOffset, oNode, newRange.endOffset);
            return newRange;
          } else if (!util.isBreak(oNode) && !util.isListCell(oNode) && util.isFormatElement(parentNode)) {
            var zeroWidth = null;
            if (!oNode.previousSibling || util.isBreak(oNode.previousSibling)) {
              zeroWidth = util.createTextNode(util.zeroWidthSpace);
              oNode.parentNode.insertBefore(zeroWidth, oNode);
            }
            if (!oNode.nextSibling || util.isBreak(oNode.nextSibling)) {
              zeroWidth = util.createTextNode(util.zeroWidthSpace);
              oNode.parentNode.insertBefore(zeroWidth, oNode.nextSibling);
            }
            if (util._isIgnoreNodeChange(oNode)) {
              oNode = oNode.nextSibling;
              offset = 0;
            }
          }
          this.setRange(oNode, offset, oNode, offset);
        }

        // history stack
        this.history.push(true);
        return oNode;
      }
    },
    _setIntoFreeFormat: function _setIntoFreeFormat(oNode) {
      var parentNode = oNode.parentNode;
      var oNodeChildren, lastONode;
      while (util.isFormatElement(oNode) || util.isRangeFormatElement(oNode)) {
        oNodeChildren = oNode.childNodes;
        lastONode = null;
        while (oNodeChildren[0]) {
          lastONode = oNodeChildren[0];
          if (util.isFormatElement(lastONode) || util.isRangeFormatElement(lastONode)) {
            this._setIntoFreeFormat(lastONode);
            if (!oNode.parentNode) break;
            oNodeChildren = oNode.childNodes;
            continue;
          }
          parentNode.insertBefore(lastONode, oNode);
        }
        if (oNode.childNodes.length === 0) util.removeItem(oNode);
        oNode = util.createElement('BR');
        parentNode.insertBefore(oNode, lastONode.nextSibling);
      }
      return oNode;
    },
    /**
     * @description Delete the currently selected nodes and reset selection range
     * Returns {container: "the last element after deletion", offset: "offset", prevContainer: "previousElementSibling Of the deleted area"}
     * @returns {Object}
     */
    removeNode: function removeNode() {
      this._resetRangeToTextNode();
      var range = this.getRange();
      var container,
        offset = 0;
      var startCon = range.startContainer;
      var endCon = range.endContainer;
      var startOff = range.startOffset;
      var endOff = range.endOffset;
      var commonCon = range.commonAncestorContainer.nodeType === 3 && range.commonAncestorContainer.parentNode === startCon.parentNode ? startCon.parentNode : range.commonAncestorContainer;
      if (commonCon === startCon && commonCon === endCon) {
        startCon = commonCon.children[startOff];
        endCon = commonCon.children[endOff];
        startOff = endOff = 0;
      }
      if (startCon === endCon && range.collapsed) {
        if (startCon.textContent && util.onlyZeroWidthSpace(startCon.textContent.substr(startOff))) {
          return {
            container: startCon,
            offset: offset,
            prevContainer: startCon && startCon.parentNode ? startCon : null
          };
        }
      }
      var beforeNode = null;
      var afterNode = null;
      var childNodes = util.getListChildNodes(commonCon, null);
      var startIndex = util.getArrayIndex(childNodes, startCon);
      var endIndex = util.getArrayIndex(childNodes, endCon);
      if (childNodes.length > 0 && startIndex > -1 && endIndex > -1) {
        for (var i = startIndex + 1, startNode = startCon; i >= 0; i--) {
          if (childNodes[i] === startNode.parentNode && childNodes[i].firstChild === startNode && startOff === 0) {
            startIndex = i;
            startNode = startNode.parentNode;
          }
        }
        for (var _i3 = endIndex - 1, endNode = endCon; _i3 > startIndex; _i3--) {
          if (childNodes[_i3] === endNode.parentNode && childNodes[_i3].nodeType === 1) {
            childNodes.splice(_i3, 1);
            endNode = endNode.parentNode;
            --endIndex;
          }
        }
      } else {
        if (childNodes.length === 0) {
          if (util.isFormatElement(commonCon) || util.isRangeFormatElement(commonCon) || util.isWysiwygDiv(commonCon) || util.isBreak(commonCon) || util.isMedia(commonCon)) {
            return {
              container: commonCon,
              offset: 0
            };
          } else if (commonCon.nodeType === 3) {
            return {
              container: commonCon,
              offset: endOff
            };
          }
          childNodes.push(commonCon);
          startCon = endCon = commonCon;
        } else {
          startCon = endCon = childNodes[0];
          if (util.isBreak(startCon) || util.onlyZeroWidthSpace(startCon)) {
            return {
              container: util.isMedia(commonCon) ? commonCon : startCon,
              offset: 0
            };
          }
        }
        startIndex = endIndex = 0;
      }
      for (var _i4 = startIndex; _i4 <= endIndex; _i4++) {
        var item = childNodes[_i4];
        if (item.length === 0 || item.nodeType === 3 && item.data === undefined) {
          this._nodeRemoveListItem(item);
          continue;
        }
        if (item === startCon) {
          if (startCon.nodeType === 1) {
            if (util.isComponent(startCon)) continue;else beforeNode = util.createTextNode(startCon.textContent);
          } else {
            if (item === endCon) {
              beforeNode = util.createTextNode(startCon.substringData(0, startOff) + endCon.substringData(endOff, endCon.length - endOff));
              offset = startOff;
            } else {
              beforeNode = util.createTextNode(startCon.substringData(0, startOff));
            }
          }
          if (beforeNode.length > 0) {
            startCon.data = beforeNode.data;
          } else {
            this._nodeRemoveListItem(startCon);
          }
          if (item === endCon) break;
          continue;
        }
        if (item === endCon) {
          if (endCon.nodeType === 1) {
            if (util.isComponent(endCon)) continue;else afterNode = util.createTextNode(endCon.textContent);
          } else {
            afterNode = util.createTextNode(endCon.substringData(endOff, endCon.length - endOff));
          }
          if (afterNode.length > 0) {
            endCon.data = afterNode.data;
          } else {
            this._nodeRemoveListItem(endCon);
          }
          continue;
        }
        this._nodeRemoveListItem(item);
      }
      var endUl = util.getParentElement(endCon, 'ul');
      var startLi = util.getParentElement(startCon, 'li');
      if (endUl && startLi && startLi.contains(endUl)) {
        container = endUl.previousSibling;
        offset = container.textContent.length;
      } else {
        container = endCon && endCon.parentNode ? endCon : startCon && startCon.parentNode ? startCon : range.endContainer || range.startContainer;
      }
      if (!util.isWysiwygDiv(container) && container.childNodes.length === 0) {
        var rc = util.removeItemAllParents(container, null, null);
        if (rc) container = rc.sc || rc.ec || context.element.wysiwyg;
      }

      // set range
      this.setRange(container, offset, container, offset);
      // history stack
      this.history.push(true);
      return {
        container: container,
        offset: offset,
        prevContainer: startCon && startCon.parentNode ? startCon : null
      };
    },
    _nodeRemoveListItem: function _nodeRemoveListItem(item) {
      var format = util.getFormatElement(item, null);
      util.removeItem(item);
      if (!util.isListCell(format)) return;
      util.removeItemAllParents(format, null, null);
      if (format && util.isList(format.firstChild)) {
        format.insertBefore(util.createTextNode(util.zeroWidthSpace), format.firstChild);
      }
    },
    /**
     * @description Appended all selected format Element to the argument element and insert
     * @param {Element} rangeElement Element of wrap the arguments (BLOCKQUOTE...)
     */
    applyRangeFormatElement: function applyRangeFormatElement(rangeElement) {
      this.getRange_addLine(this.getRange(), null);
      var rangeLines = this.getSelectedElementsAndComponents(false);
      if (!rangeLines || rangeLines.length === 0) return;
      linesLoop: for (var i = 0, len = rangeLines.length, line, nested, fEl, lEl, f, l; i < len; i++) {
        line = rangeLines[i];
        if (!util.isListCell(line)) continue;
        nested = line.lastElementChild;
        if (nested && util.isListCell(line.nextElementSibling) && rangeLines.indexOf(line.nextElementSibling) > -1) {
          lEl = nested.lastElementChild;
          if (rangeLines.indexOf(lEl) > -1) {
            var list = null;
            while (list = lEl.lastElementChild) {
              if (util.isList(list)) {
                if (rangeLines.indexOf(list.lastElementChild) > -1) {
                  lEl = list.lastElementChild;
                } else {
                  continue linesLoop;
                }
              }
            }
            fEl = nested.firstElementChild;
            f = rangeLines.indexOf(fEl);
            l = rangeLines.indexOf(lEl);
            rangeLines.splice(f, l - f + 1);
            len = rangeLines.length;
            continue;
          }
        }
      }
      var last = rangeLines[rangeLines.length - 1];
      var standTag, beforeTag, pElement;
      if (util.isRangeFormatElement(last) || util.isFormatElement(last)) {
        standTag = last;
      } else {
        standTag = util.getRangeFormatElement(last, null) || util.getFormatElement(last, null);
      }
      if (util.isCell(standTag)) {
        beforeTag = null;
        pElement = standTag;
      } else {
        beforeTag = standTag.nextSibling;
        pElement = standTag.parentNode;
      }
      var parentDepth = util.getElementDepth(standTag);
      var listParent = null;
      var lineArr = [];
      var removeItems = function removeItems(parent, origin, before) {
        var cc = null;
        if (parent !== origin && !util.isTable(origin)) {
          if (origin && util.getElementDepth(parent) === util.getElementDepth(origin)) return before;
          cc = util.removeItemAllParents(origin, null, parent);
        }
        return cc ? cc.ec : before;
      };
      for (var _i5 = 0, _len2 = rangeLines.length, _line, originParent, depth, before, nextLine, nextList, _nested; _i5 < _len2; _i5++) {
        _line = rangeLines[_i5];
        originParent = _line.parentNode;
        if (!originParent || rangeElement.contains(originParent)) continue;
        depth = util.getElementDepth(_line);
        if (util.isList(originParent)) {
          if (listParent === null) {
            if (nextList) {
              listParent = nextList;
              _nested = true;
              nextList = null;
            } else {
              listParent = originParent.cloneNode(false);
            }
          }
          lineArr.push(_line);
          nextLine = rangeLines[_i5 + 1];
          if (_i5 === _len2 - 1 || nextLine && nextLine.parentNode !== originParent) {
            // nested list
            if (nextLine && _line.contains(nextLine.parentNode)) {
              nextList = nextLine.parentNode.cloneNode(false);
            }
            var _list = originParent.parentNode,
              p = void 0;
            while (util.isList(_list)) {
              p = util.createElement(_list.nodeName);
              p.appendChild(listParent);
              listParent = p;
              _list = _list.parentNode;
            }
            var _edge = this.detachRangeFormatElement(originParent, lineArr, null, true, true);
            if (parentDepth >= depth) {
              parentDepth = depth;
              pElement = _edge.cc;
              beforeTag = removeItems(pElement, originParent, _edge.ec);
              if (beforeTag) pElement = beforeTag.parentNode;
            } else if (pElement === _edge.cc) {
              beforeTag = _edge.ec;
            }
            if (pElement !== _edge.cc) {
              before = removeItems(pElement, _edge.cc, before);
              if (before !== undefined) beforeTag = before;else beforeTag = _edge.cc;
            }
            for (var c = 0, cLen = _edge.removeArray.length; c < cLen; c++) {
              listParent.appendChild(_edge.removeArray[c]);
            }
            if (!_nested) rangeElement.appendChild(listParent);
            if (nextList) _edge.removeArray[_edge.removeArray.length - 1].appendChild(nextList);
            listParent = null;
            _nested = false;
          }
        } else {
          if (parentDepth >= depth) {
            parentDepth = depth;
            pElement = originParent;
            beforeTag = _line.nextSibling;
          }
          rangeElement.appendChild(_line);
          if (pElement !== originParent) {
            before = removeItems(pElement, originParent);
            if (before !== undefined) beforeTag = before;
          }
        }
      }
      this.effectNode = null;
      util.mergeSameTags(rangeElement, null, false);
      util.mergeNestedTags(rangeElement, function (current) {
        return this.isList(current);
      }.bind(util));

      // Nested list
      if (beforeTag && util.getElementDepth(beforeTag) > 0 && (util.isList(beforeTag.parentNode) || util.isList(beforeTag.parentNode.parentNode))) {
        var depthFormat = util.getParentElement(beforeTag, function (current) {
          return this.isRangeFormatElement(current) && !this.isList(current);
        }.bind(util));
        var splitRange = util.splitElement(beforeTag, null, !depthFormat ? 0 : util.getElementDepth(depthFormat) + 1);
        splitRange.parentNode.insertBefore(rangeElement, splitRange);
      } else {
        // basic
        pElement.insertBefore(rangeElement, beforeTag);
        removeItems(rangeElement, beforeTag);
      }
      var edge = util.getEdgeChildNodes(rangeElement.firstElementChild, rangeElement.lastElementChild);
      if (rangeLines.length > 1) {
        this.setRange(edge.sc, 0, edge.ec, edge.ec.textContent.length);
      } else {
        this.setRange(edge.ec, edge.ec.textContent.length, edge.ec, edge.ec.textContent.length);
      }

      // history stack
      this.history.push(false);
    },
    /**
     * @description The elements of the "selectedFormats" array are detached from the "rangeElement" element. ("LI" tags are converted to "P" tags)
     * When "selectedFormats" is null, all elements are detached and return {cc: parentNode, sc: nextSibling, ec: previousSibling, removeArray: [Array of removed elements]}.
     * @param {Element} rangeElement Range format element (PRE, BLOCKQUOTE, OL, UL...)
     * @param {Array|null} selectedFormats Array of format elements (P, DIV, LI...) to remove.
     * If null, Applies to all elements and return {cc: parentNode, sc: nextSibling, ec: previousSibling}
     * @param {Element|null} newRangeElement The node(rangeElement) to replace the currently wrapped node.
     * @param {Boolean} remove If true, deleted without detached.
     * @param {Boolean} notHistoryPush When true, it does not update the history stack and the selection object and return EdgeNodes (util.getEdgeChildNodes)
     * @returns {Object}
     */
    detachRangeFormatElement: function detachRangeFormatElement(rangeElement, selectedFormats, newRangeElement, remove, notHistoryPush) {
      var range = this.getRange();
      var so = range.startOffset;
      var eo = range.endOffset;
      var children = util.getListChildNodes(rangeElement, function (current) {
        return current.parentNode === rangeElement;
      });
      var parent = rangeElement.parentNode;
      var firstNode = null;
      var lastNode = null;
      var rangeEl = rangeElement.cloneNode(false);
      var removeArray = [];
      var newList = util.isList(newRangeElement);
      var insertedNew = false;
      var reset = false;
      var moveComplete = false;
      function appendNode(parent, insNode, sibling, originNode) {
        if (util.onlyZeroWidthSpace(insNode)) insNode.innerHTML = util.zeroWidthSpace;
        if (insNode.nodeType === 3) {
          parent.insertBefore(insNode, sibling);
          return insNode;
        }
        var insChildren = (moveComplete ? insNode : originNode).childNodes;
        var format = insNode.cloneNode(false);
        var first = null;
        var c = null;
        while (insChildren[0]) {
          c = insChildren[0];
          if (util._notTextNode(c) && !util.isBreak(c) && !util.isListCell(format)) {
            if (format.childNodes.length > 0) {
              if (!first) first = format;
              parent.insertBefore(format, sibling);
              format = insNode.cloneNode(false);
            }
            parent.insertBefore(c, sibling);
            if (!first) first = c;
          } else {
            format.appendChild(c);
          }
        }
        if (format.childNodes.length > 0) {
          if (util.isListCell(parent) && util.isListCell(format) && util.isList(sibling)) {
            if (newList) {
              first = sibling;
              while (sibling) {
                format.appendChild(sibling);
                sibling = sibling.nextSibling;
              }
              parent.parentNode.insertBefore(format, parent.nextElementSibling);
            } else {
              var originNext = originNode.nextElementSibling;
              var detachRange = util.detachNestedList(originNode, false);
              if (rangeElement !== detachRange || originNext !== originNode.nextElementSibling) {
                var fChildren = format.childNodes;
                while (fChildren[0]) {
                  originNode.appendChild(fChildren[0]);
                }
                rangeElement = detachRange;
                reset = true;
              }
            }
          } else {
            parent.insertBefore(format, sibling);
          }
          if (!first) first = format;
        }
        return first;
      }

      // detach loop
      for (var i = 0, len = children.length, insNode, lineIndex, next; i < len; i++) {
        insNode = children[i];
        if (insNode.nodeType === 3 && util.isList(rangeEl)) continue;
        moveComplete = false;
        if (remove && i === 0) {
          if (!selectedFormats || selectedFormats.length === len || selectedFormats[0] === insNode) {
            firstNode = rangeElement.previousSibling;
          } else {
            firstNode = rangeEl;
          }
        }
        if (selectedFormats) lineIndex = selectedFormats.indexOf(insNode);
        if (selectedFormats && lineIndex === -1) {
          if (!rangeEl) rangeEl = rangeElement.cloneNode(false);
          rangeEl.appendChild(insNode);
        } else {
          if (selectedFormats) next = selectedFormats[lineIndex + 1];
          if (rangeEl && rangeEl.children.length > 0) {
            parent.insertBefore(rangeEl, rangeElement);
            rangeEl = null;
          }
          if (!newList && util.isListCell(insNode)) {
            if (next && util.getElementDepth(insNode) !== util.getElementDepth(next) && (util.isListCell(parent) || util.getArrayItem(insNode.children, util.isList, false))) {
              var insNext = insNode.nextElementSibling;
              var detachRange = util.detachNestedList(insNode, false);
              if (rangeElement !== detachRange || insNext !== insNode.nextElementSibling) {
                rangeElement = detachRange;
                reset = true;
              }
            } else {
              var inner = insNode;
              insNode = util.createElement(remove ? inner.nodeName : util.isList(rangeElement.parentNode) || util.isListCell(rangeElement.parentNode) ? 'LI' : util.isCell(rangeElement.parentNode) ? 'DIV' : options.defaultTag);
              var isCell = util.isListCell(insNode);
              var innerChildren = inner.childNodes;
              while (innerChildren[0]) {
                if (util.isList(innerChildren[0]) && !isCell) break;
                insNode.appendChild(innerChildren[0]);
              }
              util.copyFormatAttributes(insNode, inner);
              moveComplete = true;
            }
          } else {
            insNode = insNode.cloneNode(false);
          }
          if (!reset) {
            if (!remove) {
              if (newRangeElement) {
                if (!insertedNew) {
                  parent.insertBefore(newRangeElement, rangeElement);
                  insertedNew = true;
                }
                insNode = appendNode(newRangeElement, insNode, null, children[i]);
              } else {
                insNode = appendNode(parent, insNode, rangeElement, children[i]);
              }
              if (!reset) {
                if (selectedFormats) {
                  lastNode = insNode;
                  if (!firstNode) {
                    firstNode = insNode;
                  }
                } else if (!firstNode) {
                  firstNode = lastNode = insNode;
                }
              }
            } else {
              removeArray.push(insNode);
              util.removeItem(children[i]);
            }
            if (reset) {
              reset = moveComplete = false;
              children = util.getListChildNodes(rangeElement, function (current) {
                return current.parentNode === rangeElement;
              });
              rangeEl = rangeElement.cloneNode(false);
              parent = rangeElement.parentNode;
              i = -1;
              len = children.length;
              continue;
            }
          }
        }
      }
      var rangeParent = rangeElement.parentNode;
      var rangeRight = rangeElement.nextSibling;
      if (rangeEl && rangeEl.children.length > 0) {
        rangeParent.insertBefore(rangeEl, rangeRight);
      }
      if (newRangeElement) firstNode = newRangeElement.previousSibling;else if (!firstNode) firstNode = rangeElement.previousSibling;
      rangeRight = rangeElement.nextSibling !== rangeEl ? rangeElement.nextSibling : rangeEl ? rangeEl.nextSibling : null;
      if (rangeElement.children.length === 0 || rangeElement.textContent.length === 0) {
        util.removeItem(rangeElement);
      } else {
        util.removeEmptyNode(rangeElement, null);
      }
      var edge = null;
      if (remove) {
        edge = {
          cc: rangeParent,
          sc: firstNode,
          ec: rangeRight,
          removeArray: removeArray
        };
      } else {
        if (!firstNode) firstNode = lastNode;
        if (!lastNode) lastNode = firstNode;
        var childEdge = util.getEdgeChildNodes(firstNode, lastNode.parentNode ? firstNode : lastNode);
        edge = {
          cc: (childEdge.sc || childEdge.ec).parentNode,
          sc: childEdge.sc,
          ec: childEdge.ec
        };
      }
      this.effectNode = null;
      if (notHistoryPush) return edge;
      if (!remove && edge) {
        if (!selectedFormats) {
          this.setRange(edge.sc, 0, edge.sc, 0);
        } else {
          this.setRange(edge.sc, so, edge.ec, eo);
        }
      }

      // history stack
      this.history.push(false);
    },
    /**
     * @description "selectedFormats" array are detached from the list element.
     * The return value is applied when the first and last lines of "selectedFormats" are "LI" respectively.
     * @param {Array} selectedFormats Array of format elements (LI, P...) to remove.
     * @param {Boolean} remove If true, deleted without detached.
     * @returns {Object} {sc: <LI>, ec: <LI>}.
     */
    detachList: function detachList(selectedFormats, remove) {
      var rangeArr = {};
      var listFirst = false;
      var listLast = false;
      var first = null;
      var last = null;
      var passComponent = function (current) {
        return !this.isComponent(current);
      }.bind(util);
      for (var i = 0, len = selectedFormats.length, r, o, lastIndex, isList; i < len; i++) {
        lastIndex = i === len - 1;
        o = util.getRangeFormatElement(selectedFormats[i], passComponent);
        isList = util.isList(o);
        if (!r && isList) {
          r = o;
          rangeArr = {
            r: r,
            f: [util.getParentElement(selectedFormats[i], 'LI')]
          };
          if (i === 0) listFirst = true;
        } else if (r && isList) {
          if (r !== o) {
            var edge = this.detachRangeFormatElement(rangeArr.f[0].parentNode, rangeArr.f, null, remove, true);
            o = selectedFormats[i].parentNode;
            if (listFirst) {
              first = edge.sc;
              listFirst = false;
            }
            if (lastIndex) last = edge.ec;
            if (isList) {
              r = o;
              rangeArr = {
                r: r,
                f: [util.getParentElement(selectedFormats[i], 'LI')]
              };
              if (lastIndex) listLast = true;
            } else {
              r = null;
            }
          } else {
            rangeArr.f.push(util.getParentElement(selectedFormats[i], 'LI'));
            if (lastIndex) listLast = true;
          }
        }
        if (lastIndex && util.isList(r)) {
          var _edge2 = this.detachRangeFormatElement(rangeArr.f[0].parentNode, rangeArr.f, null, remove, true);
          if (listLast || len === 1) last = _edge2.ec;
          if (listFirst) first = _edge2.sc || last;
        }
      }
      return {
        sc: first,
        ec: last
      };
    },
    /**
     * @description Add, update, and delete nodes from selected text.
     * 1. If there is a node in the "appendNode" argument, a node with the same tags and attributes as "appendNode" is added to the selection text.
     * 2. If it is in the same tag, only the tag's attributes are changed without adding a tag.
     * 3. If the "appendNode" argument is null, the node of the selection is update or remove without adding a new node.
     * 4. The same style as the style attribute of the "styleArray" argument is deleted.
     *    (Styles should be put with attribute names from css. ["background-color"])
     * 5. The same class name as the class attribute of the "styleArray" argument is deleted.
     *    (The class name is preceded by "." [".className"])
     * 6. Use a list of styles and classes of "appendNode" in "styleArray" to avoid duplicate property values.
     * 7. If a node with all styles and classes removed has the same tag name as "appendNode" or "removeNodeArray", or "appendNode" is null, that node is deleted.
     * 8. Regardless of the style and class of the node, the tag with the same name as the "removeNodeArray" argument value is deleted.
     * 9. If the "strictRemove" argument is true, only nodes with all styles and classes removed from the nodes of "removeNodeArray" are removed.
     *10. It won't work if the parent node has the same class and same value style.
     *    However, if there is a value in "removeNodeArray", it works and the text node is separated even if there is no node to replace.
     * @param {Element|null} appendNode The element to be added to the selection. If it is null, only delete the node.
     * @param {Array|null} styleArray The style or className attribute name Array to check (['font-size'], ['.className'], ['font-family', 'color', '.className']...])
     * @param {Array|null} removeNodeArray An array of node names to remove types from, remove all formats when "appendNode" is null and there is an empty array or null value. (['span'], ['strong', 'em'] ...])
     * @param {Boolean|null} strictRemove If true, only nodes with all styles and classes removed from the nodes of "removeNodeArray" are removed.
     */
    nodeChange: function nodeChange(appendNode, styleArray, removeNodeArray, strictRemove) {
      this._resetRangeToTextNode();
      var range = this.getRange_addLine(this.getRange(), null);
      styleArray = styleArray && styleArray.length > 0 ? styleArray : false;
      removeNodeArray = removeNodeArray && removeNodeArray.length > 0 ? removeNodeArray : false;
      var isRemoveNode = !appendNode;
      var isRemoveFormat = isRemoveNode && !removeNodeArray && !styleArray;
      var startCon = range.startContainer;
      var startOff = range.startOffset;
      var endCon = range.endContainer;
      var endOff = range.endOffset;
      if (isRemoveFormat && range.collapsed && util.isFormatElement(startCon.parentNode) || startCon === endCon && startCon.nodeType === 1 && util.isNonEditable(startCon)) {
        var format = startCon.parentNode;
        if (!util.isListCell(format) || !util.getValues(format.style).some(function (k) {
          return this._listKebab.indexOf(k) > -1;
        }.bind(this))) return;
      }
      if (range.collapsed && !isRemoveFormat) {
        if (startCon.nodeType === 1 && !util.isBreak(startCon) && !util.isComponent(startCon)) {
          var afterNode = null;
          var focusNode = startCon.childNodes[startOff];
          if (focusNode) {
            if (!focusNode.nextSibling) {
              afterNode = null;
            } else {
              afterNode = util.isBreak(focusNode) ? focusNode : focusNode.nextSibling;
            }
          }
          var zeroWidth = util.createTextNode(util.zeroWidthSpace);
          startCon.insertBefore(zeroWidth, afterNode);
          this.setRange(zeroWidth, 1, zeroWidth, 1);
          range = this.getRange();
          startCon = range.startContainer;
          startOff = range.startOffset;
          endCon = range.endContainer;
          endOff = range.endOffset;
        }
      }
      if (util.isFormatElement(startCon)) {
        startCon = startCon.childNodes[startOff] || startCon.firstChild;
        startOff = 0;
      }
      if (util.isFormatElement(endCon)) {
        endCon = endCon.childNodes[endOff] || endCon.lastChild;
        endOff = endCon.textContent.length;
      }
      if (isRemoveNode) {
        appendNode = util.createElement('DIV');
      }
      var wRegExp = _w.RegExp;
      var newNodeName = appendNode.nodeName;

      /* checked same style property */
      if (!isRemoveFormat && startCon === endCon && !removeNodeArray && appendNode) {
        var sNode = startCon;
        var checkCnt = 0;
        var checkAttrs = [];
        var checkStyles = appendNode.style;
        for (var i = 0, len = checkStyles.length; i < len; i++) {
          checkAttrs.push(checkStyles[i]);
        }
        var ckeckClasses = appendNode.classList;
        for (var _i6 = 0, _len3 = ckeckClasses.length; _i6 < _len3; _i6++) {
          checkAttrs.push('.' + ckeckClasses[_i6]);
        }
        if (checkAttrs.length > 0) {
          while (!util.isFormatElement(sNode) && !util.isWysiwygDiv(sNode)) {
            for (var _i7 = 0; _i7 < checkAttrs.length; _i7++) {
              if (sNode.nodeType === 1) {
                var s = checkAttrs[_i7];
                var classReg = /^\./.test(s) ? new wRegExp('\\s*' + s.replace(/^\./, '') + '(\\s+|$)', 'ig') : false;
                var styleCheck = isRemoveNode ? !!sNode.style[s] : !!sNode.style[s] && !!appendNode.style[s] && sNode.style[s] === appendNode.style[s];
                var classCheck = classReg === false ? false : isRemoveNode ? !!sNode.className.match(classReg) : !!sNode.className.match(classReg) && !!appendNode.className.match(classReg);
                if (styleCheck || classCheck) {
                  checkCnt++;
                }
              }
            }
            sNode = sNode.parentNode;
          }
          if (checkCnt >= checkAttrs.length) return;
        }
      }
      var start = {},
        end = {};
      var newNode,
        styleRegExp = '',
        classRegExp = '',
        removeNodeRegExp = '';
      if (styleArray) {
        for (var _i8 = 0, _len4 = styleArray.length, _s; _i8 < _len4; _i8++) {
          _s = styleArray[_i8];
          if (/^\./.test(_s)) {
            classRegExp += (classRegExp ? '|' : '\\s*(?:') + _s.replace(/^\./, '');
          } else {
            styleRegExp += (styleRegExp ? '|' : '(?:;|^|\\s)(?:') + _s;
          }
        }
        if (styleRegExp) {
          styleRegExp += ')\\s*:[^;]*\\s*(?:;|$)';
          styleRegExp = new wRegExp(styleRegExp, 'ig');
        }
        if (classRegExp) {
          classRegExp += ')(?=\\s+|$)';
          classRegExp = new wRegExp(classRegExp, 'ig');
        }
      }
      if (removeNodeArray) {
        removeNodeRegExp = '^(?:' + removeNodeArray[0];
        for (var _i9 = 1; _i9 < removeNodeArray.length; _i9++) {
          removeNodeRegExp += '|' + removeNodeArray[_i9];
        }
        removeNodeRegExp += ')$';
        removeNodeRegExp = new wRegExp(removeNodeRegExp, 'i');
      }

      /** validation check function*/
      var wBoolean = _w.Boolean;
      var _removeCheck = {
        v: false
      };
      var validation = function validation(checkNode) {
        var vNode = checkNode.cloneNode(false);

        // all path
        if (vNode.nodeType === 3 || util.isBreak(vNode)) return vNode;
        // all remove
        if (isRemoveFormat) return null;

        // remove node check
        var tagRemove = !removeNodeRegExp && isRemoveNode || removeNodeRegExp && removeNodeRegExp.test(vNode.nodeName);

        // tag remove
        if (tagRemove && !strictRemove) {
          _removeCheck.v = true;
          return null;
        }

        // style regexp
        var originStyle = vNode.style.cssText;
        var style = '';
        if (styleRegExp && originStyle.length > 0) {
          style = originStyle.replace(styleRegExp, '').trim();
          if (style !== originStyle) _removeCheck.v = true;
        }

        // class check
        var originClasses = vNode.className;
        var classes = '';
        if (classRegExp && originClasses.length > 0) {
          classes = originClasses.replace(classRegExp, '').trim();
          if (classes !== originClasses) _removeCheck.v = true;
        }

        // remove only
        if (isRemoveNode) {
          if ((classRegExp || !originClasses) && (styleRegExp || !originStyle) && !style && !classes && tagRemove) {
            _removeCheck.v = true;
            return null;
          }
        }

        // change
        if (style || classes || vNode.nodeName !== newNodeName || wBoolean(styleRegExp) !== wBoolean(originStyle) || wBoolean(classRegExp) !== wBoolean(originClasses)) {
          if (styleRegExp && originStyle.length > 0) vNode.style.cssText = style;
          if (!vNode.style.cssText) {
            vNode.removeAttribute('style');
          }
          if (classRegExp && originClasses.length > 0) vNode.className = classes.trim();
          if (!vNode.className.trim()) {
            vNode.removeAttribute('class');
          }
          if (!vNode.style.cssText && !vNode.className && (vNode.nodeName === newNodeName || tagRemove)) {
            _removeCheck.v = true;
            return null;
          }
          return vNode;
        }
        _removeCheck.v = true;
        return null;
      };

      // get line nodes
      var lineNodes = this.getSelectedElements(null);
      range = this.getRange();
      startCon = range.startContainer;
      startOff = range.startOffset;
      endCon = range.endContainer;
      endOff = range.endOffset;
      if (!util.getFormatElement(startCon, null)) {
        startCon = util.getChildElement(lineNodes[0], function (current) {
          return current.nodeType === 3;
        }, false);
        startOff = 0;
      }
      if (!util.getFormatElement(endCon, null)) {
        endCon = util.getChildElement(lineNodes[lineNodes.length - 1], function (current) {
          return current.nodeType === 3;
        }, false);
        endOff = endCon.textContent.length;
      }
      var oneLine = util.getFormatElement(startCon, null) === util.getFormatElement(endCon, null);
      var endLength = lineNodes.length - (oneLine ? 0 : 1);

      // node Changes
      newNode = appendNode.cloneNode(false);
      var isRemoveAnchor = isRemoveFormat || isRemoveNode && function (arr) {
        for (var n = 0, _len5 = arr.length; n < _len5; n++) {
          if (util._isMaintainedNode(arr[n]) || util._isSizeNode(arr[n])) return true;
        }
        return false;
      }(removeNodeArray);
      var isSizeNode = isRemoveNode || util._isSizeNode(newNode);
      var _getMaintainedNode = this._util_getMaintainedNode.bind(util, isRemoveAnchor, isSizeNode);
      var _isMaintainedNode = this._util_isMaintainedNode.bind(util, isRemoveAnchor, isSizeNode);

      // one line
      if (oneLine) {
        if (this._resetCommonListCell(lineNodes[0], styleArray)) range = this.setRange(startCon, startOff, endCon, endOff);
        var newRange = this._nodeChange_oneLine(lineNodes[0], newNode, validation, startCon, startOff, endCon, endOff, isRemoveFormat, isRemoveNode, range.collapsed, _removeCheck, _getMaintainedNode, _isMaintainedNode);
        start.container = newRange.startContainer;
        start.offset = newRange.startOffset;
        end.container = newRange.endContainer;
        end.offset = newRange.endOffset;
        if (start.container === end.container && util.onlyZeroWidthSpace(start.container)) {
          start.offset = end.offset = 1;
        }
        this._setCommonListStyle(newRange.ancestor, null);
      } else {
        // multi line 
        var appliedCommonList = false;
        if (endLength > 0 && this._resetCommonListCell(lineNodes[endLength], styleArray)) appliedCommonList = true;
        if (this._resetCommonListCell(lineNodes[0], styleArray)) appliedCommonList = true;
        if (appliedCommonList) this.setRange(startCon, startOff, endCon, endOff);

        // end
        if (endLength > 0) {
          newNode = appendNode.cloneNode(false);
          end = this._nodeChange_endLine(lineNodes[endLength], newNode, validation, endCon, endOff, isRemoveFormat, isRemoveNode, _removeCheck, _getMaintainedNode, _isMaintainedNode);
        }

        // mid
        for (var _i10 = endLength - 1, _newRange; _i10 > 0; _i10--) {
          this._resetCommonListCell(lineNodes[_i10], styleArray);
          newNode = appendNode.cloneNode(false);
          _newRange = this._nodeChange_middleLine(lineNodes[_i10], newNode, validation, isRemoveFormat, isRemoveNode, _removeCheck, end.container);
          if (_newRange.endContainer && _newRange.ancestor.contains(_newRange.endContainer)) {
            end.ancestor = null;
            end.container = _newRange.endContainer;
          }
          this._setCommonListStyle(_newRange.ancestor, null);
        }

        // start
        newNode = appendNode.cloneNode(false);
        start = this._nodeChange_startLine(lineNodes[0], newNode, validation, startCon, startOff, isRemoveFormat, isRemoveNode, _removeCheck, _getMaintainedNode, _isMaintainedNode, end.container);
        if (start.endContainer) {
          end.ancestor = null;
          end.container = start.endContainer;
        }
        if (endLength <= 0) {
          end = start;
        } else if (!end.container) {
          end.ancestor = null;
          end.container = start.container;
          end.offset = start.container.textContent.length;
        }
        this._setCommonListStyle(start.ancestor, null);
        this._setCommonListStyle(end.ancestor || util.getFormatElement(end.container), null);
      }

      // set range
      this.controllersOff();
      this.setRange(start.container, start.offset, end.container, end.offset);

      // history stack
      this.history.push(false);
    },
    /**
     * @description Reset common style of list cell
     * @param {Element} el List cell element. <li>
     * @param {Array|null} styleArray Style array
     * @private
     */
    _resetCommonListCell: function _resetCommonListCell(el, styleArray) {
      if (!util.isListCell(el)) return;
      if (!styleArray) styleArray = this._listKebab;
      var children = util.getArrayItem(el.childNodes, function (current) {
        return !util.isBreak(current);
      }, true);
      var elStyles = el.style;
      var ec = [],
        ek = [],
        elKeys = util.getValues(elStyles);
      for (var i = 0, len = this._listKebab.length; i < len; i++) {
        if (elKeys.indexOf(this._listKebab[i]) > -1 && styleArray.indexOf(this._listKebab[i]) > -1) {
          ec.push(this._listCamel[i]);
          ek.push(this._listKebab[i]);
        }
      }
      if (!ec.length) return;

      // reset cell style---
      var refer = util.createElement('SPAN');
      for (var _i11 = 0, _len6 = ec.length; _i11 < _len6; _i11++) {
        refer.style[ec[_i11]] = elStyles[ek[_i11]];
        elStyles.removeProperty(ek[_i11]);
      }
      var sel = refer.cloneNode(false);
      var r = null,
        appliedEl = false;
      var _loop = function _loop(_c2, _s2) {
        _c2 = children[_i12];
        if (options._textTagsMap[_c2.nodeName.toLowerCase()]) {
          c = _c2, s = _s2;
          return "continue";
        }
        _s2 = util.getValues(_c2.style);
        if (_s2.length === 0 || ec.some(function (k) {
          return _s2.indexOf(k) === -1;
        }) && _s2.some(function (k) {
          ec.indexOf(k) > -1;
        })) {
          r = _c2.nextSibling;
          sel.appendChild(_c2);
        } else if (sel.childNodes.length > 0) {
          el.insertBefore(sel, r);
          sel = refer.cloneNode(false);
          r = null;
          appliedEl = true;
        }
        c = _c2, s = _s2;
      };
      for (var _i12 = 0, _len7 = children.length, c, s; _i12 < _len7; _i12++) {
        var _ret = _loop(c, s);
        if (_ret === "continue") continue;
      }
      if (sel.childNodes.length > 0) {
        el.insertBefore(sel, r);
        appliedEl = true;
      }
      if (!elStyles.length) {
        el.removeAttribute('style');
      }
      return appliedEl;
    },
    /**
     * @description If certain styles are applied to all child nodes of the list cell, the style of the list cell is also changed. (bold, color, size)
     * @param {Element} el List cell element. <li>
     * @param {Element|null} child Variable for recursive call. ("null" on the first call)
     * @private
     */
    _setCommonListStyle: function _setCommonListStyle(el, child) {
      if (!util.isListCell(el)) return;
      var children = util.getArrayItem((child || el).childNodes, function (current) {
        return !util.isBreak(current);
      }, true);
      child = children[0];
      if (!child || children.length > 1 || child.nodeType !== 1) return;

      // set cell style---
      var childStyle = child.style;
      var elStyle = el.style;
      var nodeName = child.nodeName.toLowerCase();
      var appliedEl = false;

      // bold, italic
      if (options._textTagsMap[nodeName] === options._defaultCommand.bold.toLowerCase()) elStyle.fontWeight = 'bold';
      if (options._textTagsMap[nodeName] === options._defaultCommand.italic.toLowerCase()) elStyle.fontStyle = 'italic';

      // styles
      var cKeys = util.getValues(childStyle);
      if (cKeys.length > 0) {
        for (var i = 0, len = this._listCamel.length; i < len; i++) {
          if (cKeys.indexOf(this._listKebab[i]) > -1) {
            elStyle[this._listCamel[i]] = childStyle[this._listCamel[i]];
            childStyle.removeProperty(this._listKebab[i]);
            appliedEl = true;
          }
        }
      }
      this._setCommonListStyle(el, child);
      if (!appliedEl) return;

      // common style
      if (!childStyle.length) {
        var ch = child.childNodes;
        var p = child.parentNode;
        var n = child.nextSibling;
        while (ch.length > 0) {
          p.insertBefore(ch[0], n);
        }
        util.removeItem(child);
      }
    },
    /**
     * @description Strip remove node
     * @param {Node} removeNode The remove node
     * @private
     */
    _stripRemoveNode: function _stripRemoveNode(removeNode) {
      var element = removeNode.parentNode;
      if (!removeNode || removeNode.nodeType === 3 || !element) return;
      var children = removeNode.childNodes;
      while (children[0]) {
        element.insertBefore(children[0], removeNode);
      }
      element.removeChild(removeNode);
    },
    /**
     * @description Return the parent maintained tag. (bind and use a util object)
     * @param {Element} element Element
     * @returns {Element}
     * @private
     */
    _util_getMaintainedNode: function _util_getMaintainedNode(_isRemove, _isSizeNode, element) {
      if (!element || _isRemove) return null;
      return this.getParentElement(element, this._isMaintainedNode.bind(this)) || (!_isSizeNode ? this.getParentElement(element, this._isSizeNode.bind(this)) : null);
    },
    /**
     * @description Check if element is a tag that should be persisted. (bind and use a util object)
     * @param {Element} element Element
     * @returns {Element}
     * @private
     */
    _util_isMaintainedNode: function _util_isMaintainedNode(_isRemove, _isSizeNode, element) {
      if (!element || _isRemove || element.nodeType !== 1) return false;
      var anchor = this._isMaintainedNode(element);
      return this.getParentElement(element, this._isMaintainedNode.bind(this)) ? anchor : anchor || (!_isSizeNode ? this._isSizeNode(element) : false);
    },
    /**
     * @description wraps text nodes of line selected text.
     * @param {Element} element The node of the line that contains the selected text node.
     * @param {Element} newInnerNode The dom that will wrap the selected text area
     * @param {Function} validation Check if the node should be stripped.
     * @param {Node} startCon The startContainer property of the selection object.
     * @param {Number} startOff The startOffset property of the selection object.
     * @param {Node} endCon The endContainer property of the selection object.
     * @param {Number} endOff The endOffset property of the selection object.
     * @param {Boolean} isRemoveFormat Is the remove all formats command?
     * @param {Boolean} isRemoveNode "newInnerNode" is remove node?
     * @param {Boolean} collapsed range.collapsed
     * @returns {{ancestor: *, startContainer: *, startOffset: *, endContainer: *, endOffset: *}}
     * @private
     */
    _nodeChange_oneLine: function _nodeChange_oneLine(element, newInnerNode, validation, startCon, startOff, endCon, endOff, isRemoveFormat, isRemoveNode, collapsed, _removeCheck, _getMaintainedNode, _isMaintainedNode) {
      // not add tag
      var parentCon = startCon.parentNode;
      while (!parentCon.nextSibling && !parentCon.previousSibling && !util.isFormatElement(parentCon.parentNode) && !util.isWysiwygDiv(parentCon.parentNode)) {
        if (parentCon.nodeName === newInnerNode.nodeName) break;
        parentCon = parentCon.parentNode;
      }
      if (!isRemoveNode && parentCon === endCon.parentNode && parentCon.nodeName === newInnerNode.nodeName) {
        if (util.onlyZeroWidthSpace(startCon.textContent.slice(0, startOff)) && util.onlyZeroWidthSpace(endCon.textContent.slice(endOff))) {
          var children = parentCon.childNodes;
          var sameTag = true;
          for (var i = 0, len = children.length, c, s, e, z; i < len; i++) {
            c = children[i];
            z = !util.onlyZeroWidthSpace(c);
            if (c === startCon) {
              s = true;
              continue;
            }
            if (c === endCon) {
              e = true;
              continue;
            }
            if (!s && z || s && e && z) {
              sameTag = false;
              break;
            }
          }
          if (sameTag) {
            util.copyTagAttributes(parentCon, newInnerNode);
            return {
              ancestor: element,
              startContainer: startCon,
              startOffset: startOff,
              endContainer: endCon,
              endOffset: endOff
            };
          }
        }
      }

      // add tag
      _removeCheck.v = false;
      var el = element;
      var nNodeArray = [newInnerNode];
      var pNode = element.cloneNode(false);
      var isSameNode = startCon === endCon;
      var startContainer = startCon;
      var startOffset = startOff;
      var endContainer = endCon;
      var endOffset = endOff;
      var startPass = false;
      var endPass = false;
      var pCurrent, newNode, appendNode, cssText, anchorNode;
      var wRegExp = _w.RegExp;
      function checkCss(vNode) {
        var regExp = new wRegExp('(?:;|^|\\s)(?:' + cssText + 'null)\\s*:[^;]*\\s*(?:;|$)', 'ig');
        var style = '';
        if (regExp && vNode.style.cssText.length > 0) {
          style = regExp.test(vNode.style.cssText);
        }
        return !style;
      }
      (function recursionFunc(current, ancestor) {
        var childNodes = current.childNodes;
        for (var _i13 = 0, _len8 = childNodes.length, vNode; _i13 < _len8; _i13++) {
          var child = childNodes[_i13];
          if (!child) continue;
          var coverNode = ancestor;
          var cloneNode = void 0;

          // startContainer
          if (!startPass && child === startContainer) {
            var line = pNode;
            anchorNode = _getMaintainedNode(child);
            var prevNode = util.createTextNode(startContainer.nodeType === 1 ? '' : startContainer.substringData(0, startOffset));
            var textNode = util.createTextNode(startContainer.nodeType === 1 ? '' : startContainer.substringData(startOffset, isSameNode ? endOffset >= startOffset ? endOffset - startOffset : startContainer.data.length - startOffset : startContainer.data.length - startOffset));
            if (anchorNode) {
              var a = _getMaintainedNode(ancestor);
              if (a && a.parentNode !== line) {
                var m = a;
                var p = null;
                while (m.parentNode !== line) {
                  ancestor = p = m.parentNode.cloneNode(false);
                  while (m.childNodes[0]) {
                    p.appendChild(m.childNodes[0]);
                  }
                  m.appendChild(p);
                  m = m.parentNode;
                }
                m.parentNode.appendChild(a);
              }
              anchorNode = anchorNode.cloneNode(false);
            }
            if (!util.onlyZeroWidthSpace(prevNode)) {
              ancestor.appendChild(prevNode);
            }
            var prevAnchorNode = _getMaintainedNode(ancestor);
            if (!!prevAnchorNode) anchorNode = prevAnchorNode;
            if (anchorNode) line = anchorNode;
            newNode = child;
            pCurrent = [];
            cssText = '';
            while (newNode !== line && newNode !== el && newNode !== null) {
              vNode = _isMaintainedNode(newNode) ? null : validation(newNode);
              if (vNode && newNode.nodeType === 1 && checkCss(newNode)) {
                pCurrent.push(vNode);
                cssText += newNode.style.cssText.substr(0, newNode.style.cssText.indexOf(':')) + '|';
              }
              newNode = newNode.parentNode;
            }
            var childNode = pCurrent.pop() || textNode;
            appendNode = newNode = childNode;
            while (pCurrent.length > 0) {
              newNode = pCurrent.pop();
              appendNode.appendChild(newNode);
              appendNode = newNode;
            }
            newInnerNode.appendChild(childNode);
            line.appendChild(newInnerNode);
            if (anchorNode && !_getMaintainedNode(endContainer)) {
              newInnerNode = newInnerNode.cloneNode(false);
              pNode.appendChild(newInnerNode);
              nNodeArray.push(newInnerNode);
            }
            startContainer = textNode;
            startOffset = 0;
            startPass = true;
            if (newNode !== textNode) newNode.appendChild(startContainer);
            if (!isSameNode) continue;
          }

          // endContainer
          if (!endPass && child === endContainer) {
            anchorNode = _getMaintainedNode(child);
            var afterNode = util.createTextNode(endContainer.nodeType === 1 ? '' : endContainer.substringData(endOffset, endContainer.length - endOffset));
            var _textNode = util.createTextNode(isSameNode || endContainer.nodeType === 1 ? '' : endContainer.substringData(0, endOffset));
            if (anchorNode) {
              anchorNode = anchorNode.cloneNode(false);
            } else if (_isMaintainedNode(newInnerNode.parentNode) && !anchorNode) {
              newInnerNode = newInnerNode.cloneNode(false);
              pNode.appendChild(newInnerNode);
              nNodeArray.push(newInnerNode);
            }
            if (!util.onlyZeroWidthSpace(afterNode)) {
              newNode = child;
              cssText = '';
              pCurrent = [];
              var anchors = [];
              while (newNode !== pNode && newNode !== el && newNode !== null) {
                if (newNode.nodeType === 1 && checkCss(newNode)) {
                  if (_isMaintainedNode(newNode)) anchors.push(newNode.cloneNode(false));else pCurrent.push(newNode.cloneNode(false));
                  cssText += newNode.style.cssText.substr(0, newNode.style.cssText.indexOf(':')) + '|';
                }
                newNode = newNode.parentNode;
              }
              pCurrent = pCurrent.concat(anchors);
              cloneNode = appendNode = newNode = pCurrent.pop() || afterNode;
              while (pCurrent.length > 0) {
                newNode = pCurrent.pop();
                appendNode.appendChild(newNode);
                appendNode = newNode;
              }
              pNode.appendChild(cloneNode);
              newNode.textContent = afterNode.data;
            }
            if (anchorNode && cloneNode) {
              var afterAnchorNode = _getMaintainedNode(cloneNode);
              if (afterAnchorNode) {
                anchorNode = afterAnchorNode;
              }
            }
            newNode = child;
            pCurrent = [];
            cssText = '';
            while (newNode !== pNode && newNode !== el && newNode !== null) {
              vNode = _isMaintainedNode(newNode) ? null : validation(newNode);
              if (vNode && newNode.nodeType === 1 && checkCss(newNode)) {
                pCurrent.push(vNode);
                cssText += newNode.style.cssText.substr(0, newNode.style.cssText.indexOf(':')) + '|';
              }
              newNode = newNode.parentNode;
            }
            var _childNode = pCurrent.pop() || _textNode;
            appendNode = newNode = _childNode;
            while (pCurrent.length > 0) {
              newNode = pCurrent.pop();
              appendNode.appendChild(newNode);
              appendNode = newNode;
            }
            if (anchorNode) {
              newInnerNode = newInnerNode.cloneNode(false);
              newInnerNode.appendChild(_childNode);
              anchorNode.insertBefore(newInnerNode, anchorNode.firstChild);
              pNode.appendChild(anchorNode);
              nNodeArray.push(newInnerNode);
              anchorNode = null;
            } else {
              newInnerNode.appendChild(_childNode);
            }
            endContainer = _textNode;
            endOffset = _textNode.data.length;
            endPass = true;
            if (!isRemoveFormat && collapsed) {
              newInnerNode = _textNode;
              _textNode.textContent = util.zeroWidthSpace;
            }
            if (newNode !== _textNode) newNode.appendChild(endContainer);
            continue;
          }

          // other
          if (startPass) {
            if (child.nodeType === 1 && !util.isBreak(child)) {
              if (util._isIgnoreNodeChange(child)) {
                pNode.appendChild(child.cloneNode(true));
                if (!collapsed) {
                  newInnerNode = newInnerNode.cloneNode(false);
                  pNode.appendChild(newInnerNode);
                  nNodeArray.push(newInnerNode);
                }
              } else {
                recursionFunc(child, child);
              }
              continue;
            }
            newNode = child;
            pCurrent = [];
            cssText = '';
            var _anchors = [];
            while (newNode.parentNode !== null && newNode !== el && newNode !== newInnerNode) {
              vNode = endPass ? newNode.cloneNode(false) : validation(newNode);
              if (newNode.nodeType === 1 && !util.isBreak(child) && vNode && checkCss(newNode)) {
                if (_isMaintainedNode(newNode)) {
                  if (!anchorNode) _anchors.push(vNode);
                } else {
                  pCurrent.push(vNode);
                }
                cssText += newNode.style.cssText.substr(0, newNode.style.cssText.indexOf(':')) + '|';
              }
              newNode = newNode.parentNode;
            }
            pCurrent = pCurrent.concat(_anchors);
            var _childNode2 = pCurrent.pop() || child;
            appendNode = newNode = _childNode2;
            while (pCurrent.length > 0) {
              newNode = pCurrent.pop();
              appendNode.appendChild(newNode);
              appendNode = newNode;
            }
            if (_isMaintainedNode(newInnerNode.parentNode) && !_isMaintainedNode(_childNode2) && !util.onlyZeroWidthSpace(newInnerNode)) {
              newInnerNode = newInnerNode.cloneNode(false);
              pNode.appendChild(newInnerNode);
              nNodeArray.push(newInnerNode);
            }
            if (!endPass && !anchorNode && _isMaintainedNode(_childNode2)) {
              newInnerNode = newInnerNode.cloneNode(false);
              var aChildren = _childNode2.childNodes;
              for (var _a = 0, aLen = aChildren.length; _a < aLen; _a++) {
                newInnerNode.appendChild(aChildren[_a]);
              }
              _childNode2.appendChild(newInnerNode);
              pNode.appendChild(_childNode2);
              nNodeArray.push(newInnerNode);
              if (newInnerNode.children.length > 0) ancestor = newNode;else ancestor = newInnerNode;
            } else if (_childNode2 === child) {
              if (!endPass) ancestor = newInnerNode;else ancestor = pNode;
            } else if (endPass) {
              pNode.appendChild(_childNode2);
              ancestor = newNode;
            } else {
              newInnerNode.appendChild(_childNode2);
              ancestor = newNode;
            }
            if (anchorNode && child.nodeType === 3) {
              if (_getMaintainedNode(child)) {
                var ancestorAnchorNode = util.getParentElement(ancestor, function (current) {
                  return this._isMaintainedNode(current.parentNode) || current.parentNode === pNode;
                }.bind(util));
                anchorNode.appendChild(ancestorAnchorNode);
                newInnerNode = ancestorAnchorNode.cloneNode(false);
                nNodeArray.push(newInnerNode);
                pNode.appendChild(newInnerNode);
              } else {
                anchorNode = null;
              }
            }
          }
          cloneNode = child.cloneNode(false);
          ancestor.appendChild(cloneNode);
          if (child.nodeType === 1 && !util.isBreak(child)) coverNode = cloneNode;
          recursionFunc(child, coverNode);
        }
      })(element, pNode);

      // not remove tag
      if (isRemoveNode && !isRemoveFormat && !_removeCheck.v) {
        return {
          ancestor: element,
          startContainer: startCon,
          startOffset: startOff,
          endContainer: endCon,
          endOffset: endOff
        };
      }
      isRemoveFormat = isRemoveFormat && isRemoveNode;
      if (isRemoveFormat) {
        for (var _i14 = 0; _i14 < nNodeArray.length; _i14++) {
          var removeNode = nNodeArray[_i14];
          var textNode = void 0,
            textNode_s = void 0,
            textNode_e = void 0;
          if (collapsed) {
            textNode = util.createTextNode(util.zeroWidthSpace);
            pNode.replaceChild(textNode, removeNode);
          } else {
            var rChildren = removeNode.childNodes;
            textNode_s = rChildren[0];
            while (rChildren[0]) {
              textNode_e = rChildren[0];
              pNode.insertBefore(textNode_e, removeNode);
            }
            util.removeItem(removeNode);
          }
          if (_i14 === 0) {
            if (collapsed) {
              startContainer = endContainer = textNode;
            } else {
              startContainer = textNode_s;
              endContainer = textNode_e;
            }
          }
        }
      } else {
        if (isRemoveNode) {
          for (var _i15 = 0; _i15 < nNodeArray.length; _i15++) {
            this._stripRemoveNode(nNodeArray[_i15]);
          }
        }
        if (collapsed) {
          startContainer = endContainer = newInnerNode;
        }
      }
      util.removeEmptyNode(pNode, newInnerNode);
      if (collapsed) {
        startOffset = startContainer.textContent.length;
        endOffset = endContainer.textContent.length;
      }

      // endContainer reset
      var endConReset = isRemoveFormat || endContainer.textContent.length === 0;
      if (!util.isBreak(endContainer) && endContainer.textContent.length === 0) {
        util.removeItem(endContainer);
        endContainer = startContainer;
      }
      endOffset = endConReset ? endContainer.textContent.length : endOffset;

      // node change
      var newStartOffset = {
        s: 0,
        e: 0
      };
      var startPath = util.getNodePath(startContainer, pNode, newStartOffset);
      var mergeEndCon = !endContainer.parentNode;
      if (mergeEndCon) endContainer = startContainer;
      var newEndOffset = {
        s: 0,
        e: 0
      };
      var endPath = util.getNodePath(endContainer, pNode, !mergeEndCon && !endConReset ? newEndOffset : null);
      startOffset += newStartOffset.s;
      endOffset = collapsed ? startOffset : mergeEndCon ? startContainer.textContent.length : endConReset ? endOffset + newStartOffset.s : endOffset + newEndOffset.s;

      // tag merge
      var newOffsets = util.mergeSameTags(pNode, [startPath, endPath], true);
      element.parentNode.replaceChild(pNode, element);
      startContainer = util.getNodeFromPath(startPath, pNode);
      endContainer = util.getNodeFromPath(endPath, pNode);
      return {
        ancestor: pNode,
        startContainer: startContainer,
        startOffset: startOffset + newOffsets[0],
        endContainer: endContainer,
        endOffset: endOffset + newOffsets[1]
      };
    },
    /**
     * @description wraps first line selected text.
     * @param {Element} element The node of the line that contains the selected text node.
     * @param {Element} newInnerNode The dom that will wrap the selected text area
     * @param {Function} validation Check if the node should be stripped.
     * @param {Node} startCon The startContainer property of the selection object.
     * @param {Number} startOff The startOffset property of the selection object.
     * @param {Boolean} isRemoveFormat Is the remove all formats command?
     * @param {Boolean} isRemoveNode "newInnerNode" is remove node?
     * @returns {null|Node} If end container is renewed, returned renewed node
     * @returns {Object} { ancestor, container, offset, endContainer }
     * @private
     */
    _nodeChange_startLine: function _nodeChange_startLine(element, newInnerNode, validation, startCon, startOff, isRemoveFormat, isRemoveNode, _removeCheck, _getMaintainedNode, _isMaintainedNode, _endContainer) {
      // not add tag
      var parentCon = startCon.parentNode;
      while (!parentCon.nextSibling && !parentCon.previousSibling && !util.isFormatElement(parentCon.parentNode) && !util.isWysiwygDiv(parentCon.parentNode)) {
        if (parentCon.nodeName === newInnerNode.nodeName) break;
        parentCon = parentCon.parentNode;
      }
      if (!isRemoveNode && parentCon.nodeName === newInnerNode.nodeName && !util.isFormatElement(parentCon) && !parentCon.nextSibling && util.onlyZeroWidthSpace(startCon.textContent.slice(0, startOff))) {
        var sameTag = true;
        var s = startCon.previousSibling;
        while (s) {
          if (!util.onlyZeroWidthSpace(s)) {
            sameTag = false;
            break;
          }
          s = s.previousSibling;
        }
        if (sameTag) {
          util.copyTagAttributes(parentCon, newInnerNode);
          return {
            ancestor: element,
            container: startCon,
            offset: startOff
          };
        }
      }

      // add tag
      _removeCheck.v = false;
      var el = element;
      var nNodeArray = [newInnerNode];
      var pNode = element.cloneNode(false);
      var container = startCon;
      var offset = startOff;
      var passNode = false;
      var pCurrent, newNode, appendNode, anchorNode;
      (function recursionFunc(current, ancestor) {
        var childNodes = current.childNodes;
        for (var i = 0, len = childNodes.length, vNode, cloneChild; i < len; i++) {
          var child = childNodes[i];
          if (!child) continue;
          var coverNode = ancestor;
          if (passNode && !util.isBreak(child)) {
            if (child.nodeType === 1) {
              if (util._isIgnoreNodeChange(child)) {
                newInnerNode = newInnerNode.cloneNode(false);
                cloneChild = child.cloneNode(true);
                pNode.appendChild(cloneChild);
                pNode.appendChild(newInnerNode);
                nNodeArray.push(newInnerNode);

                // end container
                if (_endContainer && child.contains(_endContainer)) {
                  var endPath = util.getNodePath(_endContainer, child);
                  _endContainer = util.getNodeFromPath(endPath, cloneChild);
                }
              } else {
                recursionFunc(child, child);
              }
              continue;
            }
            newNode = child;
            pCurrent = [];
            var anchors = [];
            while (newNode.parentNode !== null && newNode !== el && newNode !== newInnerNode) {
              vNode = validation(newNode);
              if (newNode.nodeType === 1 && vNode) {
                if (_isMaintainedNode(newNode)) {
                  if (!anchorNode) anchors.push(vNode);
                } else {
                  pCurrent.push(vNode);
                }
              }
              newNode = newNode.parentNode;
            }
            pCurrent = pCurrent.concat(anchors);
            var isTopNode = pCurrent.length > 0;
            var childNode = pCurrent.pop() || child;
            appendNode = newNode = childNode;
            while (pCurrent.length > 0) {
              newNode = pCurrent.pop();
              appendNode.appendChild(newNode);
              appendNode = newNode;
            }
            if (_isMaintainedNode(newInnerNode.parentNode) && !_isMaintainedNode(childNode)) {
              newInnerNode = newInnerNode.cloneNode(false);
              pNode.appendChild(newInnerNode);
              nNodeArray.push(newInnerNode);
            }
            if (!anchorNode && _isMaintainedNode(childNode)) {
              newInnerNode = newInnerNode.cloneNode(false);
              var aChildren = childNode.childNodes;
              for (var a = 0, aLen = aChildren.length; a < aLen; a++) {
                newInnerNode.appendChild(aChildren[a]);
              }
              childNode.appendChild(newInnerNode);
              pNode.appendChild(childNode);
              ancestor = !_isMaintainedNode(newNode) ? newNode : newInnerNode;
              nNodeArray.push(newInnerNode);
            } else if (isTopNode) {
              newInnerNode.appendChild(childNode);
              ancestor = newNode;
            } else {
              ancestor = newInnerNode;
            }
            if (anchorNode && child.nodeType === 3) {
              if (_getMaintainedNode(child)) {
                var ancestorAnchorNode = util.getParentElement(ancestor, function (current) {
                  return this._isMaintainedNode(current.parentNode) || current.parentNode === pNode;
                }.bind(util));
                anchorNode.appendChild(ancestorAnchorNode);
                newInnerNode = ancestorAnchorNode.cloneNode(false);
                nNodeArray.push(newInnerNode);
                pNode.appendChild(newInnerNode);
              } else {
                anchorNode = null;
              }
            }
          }

          // startContainer
          if (!passNode && child === container) {
            var line = pNode;
            anchorNode = _getMaintainedNode(child);
            var prevNode = util.createTextNode(container.nodeType === 1 ? '' : container.substringData(0, offset));
            var textNode = util.createTextNode(container.nodeType === 1 ? '' : container.substringData(offset, container.length - offset));
            if (anchorNode) {
              var _a2 = _getMaintainedNode(ancestor);
              if (_a2 && _a2.parentNode !== line) {
                var m = _a2;
                var p = null;
                while (m.parentNode !== line) {
                  ancestor = p = m.parentNode.cloneNode(false);
                  while (m.childNodes[0]) {
                    p.appendChild(m.childNodes[0]);
                  }
                  m.appendChild(p);
                  m = m.parentNode;
                }
                m.parentNode.appendChild(_a2);
              }
              anchorNode = anchorNode.cloneNode(false);
            }
            if (!util.onlyZeroWidthSpace(prevNode)) {
              ancestor.appendChild(prevNode);
            }
            var prevAnchorNode = _getMaintainedNode(ancestor);
            if (!!prevAnchorNode) anchorNode = prevAnchorNode;
            if (anchorNode) line = anchorNode;
            newNode = ancestor;
            pCurrent = [];
            while (newNode !== line && newNode !== null) {
              vNode = validation(newNode);
              if (newNode.nodeType === 1 && vNode) {
                pCurrent.push(vNode);
              }
              newNode = newNode.parentNode;
            }
            var _childNode3 = pCurrent.pop() || ancestor;
            appendNode = newNode = _childNode3;
            while (pCurrent.length > 0) {
              newNode = pCurrent.pop();
              appendNode.appendChild(newNode);
              appendNode = newNode;
            }
            if (_childNode3 !== ancestor) {
              newInnerNode.appendChild(_childNode3);
              ancestor = newNode;
            } else {
              ancestor = newInnerNode;
            }
            if (util.isBreak(child)) newInnerNode.appendChild(child.cloneNode(false));
            line.appendChild(newInnerNode);
            container = textNode;
            offset = 0;
            passNode = true;
            ancestor.appendChild(container);
            continue;
          }
          vNode = !passNode ? child.cloneNode(false) : validation(child);
          if (vNode) {
            ancestor.appendChild(vNode);
            if (child.nodeType === 1 && !util.isBreak(child)) coverNode = vNode;
          }
          recursionFunc(child, coverNode);
        }
      })(element, pNode);

      // not remove tag
      if (isRemoveNode && !isRemoveFormat && !_removeCheck.v) {
        return {
          ancestor: element,
          container: startCon,
          offset: startOff,
          endContainer: _endContainer
        };
      }
      isRemoveFormat = isRemoveFormat && isRemoveNode;
      if (isRemoveFormat) {
        for (var i = 0; i < nNodeArray.length; i++) {
          var removeNode = nNodeArray[i];
          var rChildren = removeNode.childNodes;
          var textNode = rChildren[0];
          while (rChildren[0]) {
            pNode.insertBefore(rChildren[0], removeNode);
          }
          util.removeItem(removeNode);
          if (i === 0) container = textNode;
        }
      } else if (isRemoveNode) {
        newInnerNode = newInnerNode.firstChild;
        for (var _i16 = 0; _i16 < nNodeArray.length; _i16++) {
          this._stripRemoveNode(nNodeArray[_i16]);
        }
      }
      if (!isRemoveFormat && pNode.childNodes.length === 0) {
        if (element.childNodes) {
          container = element.childNodes[0];
        } else {
          container = util.createTextNode(util.zeroWidthSpace);
          element.appendChild(container);
        }
      } else {
        util.removeEmptyNode(pNode, newInnerNode);
        if (util.onlyZeroWidthSpace(pNode.textContent)) {
          container = pNode.firstChild;
          offset = 0;
        }

        // node change
        var offsets = {
          s: 0,
          e: 0
        };
        var path = util.getNodePath(container, pNode, offsets);
        offset += offsets.s;

        // tag merge
        var newOffsets = util.mergeSameTags(pNode, [path], true);
        element.parentNode.replaceChild(pNode, element);
        container = util.getNodeFromPath(path, pNode);
        offset += newOffsets[0];
      }
      return {
        ancestor: pNode,
        container: container,
        offset: offset,
        endContainer: _endContainer
      };
    },
    /**
     * @description wraps mid lines selected text.
     * @param {Element} element The node of the line that contains the selected text node.
     * @param {Element} newInnerNode The dom that will wrap the selected text area
     * @param {Function} validation Check if the node should be stripped.
     * @param {Boolean} isRemoveFormat Is the remove all formats command?
     * @param {Boolean} isRemoveNode "newInnerNode" is remove node?
     * @param {Node} _endContainer Offset node of last line already modified (end.container)
     * @returns {Object} { ancestor, endContainer: "If end container is renewed, returned renewed node" }
     * @private
     */
    _nodeChange_middleLine: function _nodeChange_middleLine(element, newInnerNode, validation, isRemoveFormat, isRemoveNode, _removeCheck, _endContainer) {
      // not add tag
      if (!isRemoveNode) {
        // end container path
        var endPath = null;
        if (_endContainer && element.contains(_endContainer)) endPath = util.getNodePath(_endContainer, element);
        var tempNode = element.cloneNode(true);
        var newNodeName = newInnerNode.nodeName;
        var newCssText = newInnerNode.style.cssText;
        var newClass = newInnerNode.className;
        var children = tempNode.childNodes;
        var i = 0,
          len = children.length;
        for (var child; i < len; i++) {
          child = children[i];
          if (child.nodeType === 3) break;
          if (child.nodeName === newNodeName) {
            child.style.cssText += newCssText;
            util.addClass(child, newClass);
          } else if (!util.isBreak(child) && util._isIgnoreNodeChange(child)) {
            continue;
          } else if (len === 1) {
            children = child.childNodes;
            len = children.length;
            i = -1;
            continue;
          } else {
            break;
          }
        }
        if (len > 0 && i === len) {
          element.innerHTML = tempNode.innerHTML;
          return {
            ancestor: element,
            endContainer: endPath ? util.getNodeFromPath(endPath, element) : null
          };
        }
      }

      // add tag
      _removeCheck.v = false;
      var pNode = element.cloneNode(false);
      var nNodeArray = [newInnerNode];
      var noneChange = true;
      (function recursionFunc(current, ancestor) {
        var childNodes = current.childNodes;
        for (var _i17 = 0, _len9 = childNodes.length, vNode, cloneChild; _i17 < _len9; _i17++) {
          var _child = childNodes[_i17];
          if (!_child) continue;
          var coverNode = ancestor;
          if (!util.isBreak(_child) && util._isIgnoreNodeChange(_child)) {
            if (newInnerNode.childNodes.length > 0) {
              pNode.appendChild(newInnerNode);
              newInnerNode = newInnerNode.cloneNode(false);
            }
            cloneChild = _child.cloneNode(true);
            pNode.appendChild(cloneChild);
            pNode.appendChild(newInnerNode);
            nNodeArray.push(newInnerNode);
            ancestor = newInnerNode;

            // end container
            if (_endContainer && _child.contains(_endContainer)) {
              var _endPath = util.getNodePath(_endContainer, _child);
              _endContainer = util.getNodeFromPath(_endPath, cloneChild);
            }
            continue;
          } else {
            vNode = validation(_child);
            if (vNode) {
              noneChange = false;
              ancestor.appendChild(vNode);
              if (_child.nodeType === 1) coverNode = vNode;
            }
          }
          if (!util.isBreak(_child)) recursionFunc(_child, coverNode);
        }
      })(element, newInnerNode);

      // not remove tag
      if (noneChange || isRemoveNode && !isRemoveFormat && !_removeCheck.v) return {
        ancestor: element,
        endContainer: _endContainer
      };
      pNode.appendChild(newInnerNode);
      if (isRemoveFormat && isRemoveNode) {
        for (var _i18 = 0; _i18 < nNodeArray.length; _i18++) {
          var removeNode = nNodeArray[_i18];
          var rChildren = removeNode.childNodes;
          while (rChildren[0]) {
            pNode.insertBefore(rChildren[0], removeNode);
          }
          util.removeItem(removeNode);
        }
      } else if (isRemoveNode) {
        newInnerNode = newInnerNode.firstChild;
        for (var _i19 = 0; _i19 < nNodeArray.length; _i19++) {
          this._stripRemoveNode(nNodeArray[_i19]);
        }
      }
      util.removeEmptyNode(pNode, newInnerNode);
      util.mergeSameTags(pNode, null, true);

      // node change
      element.parentNode.replaceChild(pNode, element);
      return {
        ancestor: pNode,
        endContainer: _endContainer
      };
    },
    /**
     * @description wraps last line selected text.
     * @param {Element} element The node of the line that contains the selected text node.
     * @param {Element} newInnerNode The dom that will wrap the selected text area
     * @param {Function} validation Check if the node should be stripped.
     * @param {Node} endCon The endContainer property of the selection object.
     * @param {Number} endOff The endOffset property of the selection object.
     * @param {Boolean} isRemoveFormat Is the remove all formats command?
     * @param {Boolean} isRemoveNode "newInnerNode" is remove node?
     * @returns {Object} { ancestor, container, offset }
     * @private
     */
    _nodeChange_endLine: function _nodeChange_endLine(element, newInnerNode, validation, endCon, endOff, isRemoveFormat, isRemoveNode, _removeCheck, _getMaintainedNode, _isMaintainedNode) {
      // not add tag
      var parentCon = endCon.parentNode;
      while (!parentCon.nextSibling && !parentCon.previousSibling && !util.isFormatElement(parentCon.parentNode) && !util.isWysiwygDiv(parentCon.parentNode)) {
        if (parentCon.nodeName === newInnerNode.nodeName) break;
        parentCon = parentCon.parentNode;
      }
      if (!isRemoveNode && parentCon.nodeName === newInnerNode.nodeName && !util.isFormatElement(parentCon) && !parentCon.previousSibling && util.onlyZeroWidthSpace(endCon.textContent.slice(endOff))) {
        var sameTag = true;
        var e = endCon.nextSibling;
        while (e) {
          if (!util.onlyZeroWidthSpace(e)) {
            sameTag = false;
            break;
          }
          e = e.nextSibling;
        }
        if (sameTag) {
          util.copyTagAttributes(parentCon, newInnerNode);
          return {
            ancestor: element,
            container: endCon,
            offset: endOff
          };
        }
      }

      // add tag
      _removeCheck.v = false;
      var el = element;
      var nNodeArray = [newInnerNode];
      var pNode = element.cloneNode(false);
      var container = endCon;
      var offset = endOff;
      var passNode = false;
      var pCurrent, newNode, appendNode, anchorNode;
      (function recursionFunc(current, ancestor) {
        var childNodes = current.childNodes;
        for (var i = childNodes.length - 1, vNode; 0 <= i; i--) {
          var child = childNodes[i];
          if (!child) continue;
          var coverNode = ancestor;
          if (passNode && !util.isBreak(child)) {
            if (child.nodeType === 1) {
              if (util._isIgnoreNodeChange(child)) {
                newInnerNode = newInnerNode.cloneNode(false);
                var cloneChild = child.cloneNode(true);
                pNode.insertBefore(cloneChild, ancestor);
                pNode.insertBefore(newInnerNode, cloneChild);
                nNodeArray.push(newInnerNode);
              } else {
                recursionFunc(child, child);
              }
              continue;
            }
            newNode = child;
            pCurrent = [];
            var anchors = [];
            while (newNode.parentNode !== null && newNode !== el && newNode !== newInnerNode) {
              vNode = validation(newNode);
              if (vNode && newNode.nodeType === 1) {
                if (_isMaintainedNode(newNode)) {
                  if (!anchorNode) anchors.push(vNode);
                } else {
                  pCurrent.push(vNode);
                }
              }
              newNode = newNode.parentNode;
            }
            pCurrent = pCurrent.concat(anchors);
            var isTopNode = pCurrent.length > 0;
            var childNode = pCurrent.pop() || child;
            appendNode = newNode = childNode;
            while (pCurrent.length > 0) {
              newNode = pCurrent.pop();
              appendNode.appendChild(newNode);
              appendNode = newNode;
            }
            if (_isMaintainedNode(newInnerNode.parentNode) && !_isMaintainedNode(childNode)) {
              newInnerNode = newInnerNode.cloneNode(false);
              pNode.insertBefore(newInnerNode, pNode.firstChild);
              nNodeArray.push(newInnerNode);
            }
            if (!anchorNode && _isMaintainedNode(childNode)) {
              newInnerNode = newInnerNode.cloneNode(false);
              var aChildren = childNode.childNodes;
              for (var a = 0, aLen = aChildren.length; a < aLen; a++) {
                newInnerNode.appendChild(aChildren[a]);
              }
              childNode.appendChild(newInnerNode);
              pNode.insertBefore(childNode, pNode.firstChild);
              nNodeArray.push(newInnerNode);
              if (newInnerNode.children.length > 0) ancestor = newNode;else ancestor = newInnerNode;
            } else if (isTopNode) {
              newInnerNode.insertBefore(childNode, newInnerNode.firstChild);
              ancestor = newNode;
            } else {
              ancestor = newInnerNode;
            }
            if (anchorNode && child.nodeType === 3) {
              if (_getMaintainedNode(child)) {
                var ancestorAnchorNode = util.getParentElement(ancestor, function (current) {
                  return this._isMaintainedNode(current.parentNode) || current.parentNode === pNode;
                }.bind(util));
                anchorNode.appendChild(ancestorAnchorNode);
                newInnerNode = ancestorAnchorNode.cloneNode(false);
                nNodeArray.push(newInnerNode);
                pNode.insertBefore(newInnerNode, pNode.firstChild);
              } else {
                anchorNode = null;
              }
            }
          }

          // endContainer
          if (!passNode && child === container) {
            anchorNode = _getMaintainedNode(child);
            var afterNode = util.createTextNode(container.nodeType === 1 ? '' : container.substringData(offset, container.length - offset));
            var textNode = util.createTextNode(container.nodeType === 1 ? '' : container.substringData(0, offset));
            if (anchorNode) {
              anchorNode = anchorNode.cloneNode(false);
              var _a3 = _getMaintainedNode(ancestor);
              if (_a3 && _a3.parentNode !== pNode) {
                var m = _a3;
                var p = null;
                while (m.parentNode !== pNode) {
                  ancestor = p = m.parentNode.cloneNode(false);
                  while (m.childNodes[0]) {
                    p.appendChild(m.childNodes[0]);
                  }
                  m.appendChild(p);
                  m = m.parentNode;
                }
                m.parentNode.insertBefore(_a3, m.parentNode.firstChild);
              }
              anchorNode = anchorNode.cloneNode(false);
            } else if (_isMaintainedNode(newInnerNode.parentNode) && !anchorNode) {
              newInnerNode = newInnerNode.cloneNode(false);
              pNode.appendChild(newInnerNode);
              nNodeArray.push(newInnerNode);
            }
            if (!util.onlyZeroWidthSpace(afterNode)) {
              ancestor.insertBefore(afterNode, ancestor.firstChild);
            }
            newNode = ancestor;
            pCurrent = [];
            while (newNode !== pNode && newNode !== null) {
              vNode = _isMaintainedNode(newNode) ? null : validation(newNode);
              if (vNode && newNode.nodeType === 1) {
                pCurrent.push(vNode);
              }
              newNode = newNode.parentNode;
            }
            var _childNode4 = pCurrent.pop() || ancestor;
            appendNode = newNode = _childNode4;
            while (pCurrent.length > 0) {
              newNode = pCurrent.pop();
              appendNode.appendChild(newNode);
              appendNode = newNode;
            }
            if (_childNode4 !== ancestor) {
              newInnerNode.insertBefore(_childNode4, newInnerNode.firstChild);
              ancestor = newNode;
            } else {
              ancestor = newInnerNode;
            }
            if (util.isBreak(child)) newInnerNode.appendChild(child.cloneNode(false));
            if (anchorNode) {
              anchorNode.insertBefore(newInnerNode, anchorNode.firstChild);
              pNode.insertBefore(anchorNode, pNode.firstChild);
              anchorNode = null;
            } else {
              pNode.insertBefore(newInnerNode, pNode.firstChild);
            }
            container = textNode;
            offset = textNode.data.length;
            passNode = true;
            ancestor.insertBefore(container, ancestor.firstChild);
            continue;
          }
          vNode = !passNode ? child.cloneNode(false) : validation(child);
          if (vNode) {
            ancestor.insertBefore(vNode, ancestor.firstChild);
            if (child.nodeType === 1 && !util.isBreak(child)) coverNode = vNode;
          }
          recursionFunc(child, coverNode);
        }
      })(element, pNode);

      // not remove tag
      if (isRemoveNode && !isRemoveFormat && !_removeCheck.v) {
        return {
          ancestor: element,
          container: endCon,
          offset: endOff
        };
      }
      isRemoveFormat = isRemoveFormat && isRemoveNode;
      if (isRemoveFormat) {
        for (var i = 0; i < nNodeArray.length; i++) {
          var removeNode = nNodeArray[i];
          var rChildren = removeNode.childNodes;
          var textNode = null;
          while (rChildren[0]) {
            textNode = rChildren[0];
            pNode.insertBefore(textNode, removeNode);
          }
          util.removeItem(removeNode);
          if (i === nNodeArray.length - 1) {
            container = textNode;
            offset = textNode.textContent.length;
          }
        }
      } else if (isRemoveNode) {
        newInnerNode = newInnerNode.firstChild;
        for (var _i20 = 0; _i20 < nNodeArray.length; _i20++) {
          this._stripRemoveNode(nNodeArray[_i20]);
        }
      }
      if (!isRemoveFormat && pNode.childNodes.length === 0) {
        if (element.childNodes) {
          container = element.childNodes[0];
        } else {
          container = util.createTextNode(util.zeroWidthSpace);
          element.appendChild(container);
        }
      } else {
        if (!isRemoveNode && newInnerNode.textContent.length === 0) {
          util.removeEmptyNode(pNode, null);
          return {
            ancestor: null,
            container: null,
            offset: 0
          };
        }
        util.removeEmptyNode(pNode, newInnerNode);
        if (util.onlyZeroWidthSpace(pNode.textContent)) {
          container = pNode.firstChild;
          offset = container.textContent.length;
        } else if (util.onlyZeroWidthSpace(container)) {
          container = newInnerNode;
          offset = 1;
        }

        // node change
        var offsets = {
          s: 0,
          e: 0
        };
        var path = util.getNodePath(container, pNode, offsets);
        offset += offsets.s;

        // tag merge
        var newOffsets = util.mergeSameTags(pNode, [path], true);
        element.parentNode.replaceChild(pNode, element);
        container = util.getNodeFromPath(path, pNode);
        offset += newOffsets[0];
      }
      return {
        ancestor: pNode,
        container: container,
        offset: container.nodeType === 1 && offset === 1 ? container.childNodes.length : offset
      };
    },
    /**
     * @description Run plugin calls and basic commands.
     * @param {String} command Command string
     * @param {String} display Display type string ('command', 'submenu', 'dialog', 'container')
     * @param {Element} target The element of command button
     */
    actionCall: function actionCall(command, display, target) {
      // call plugins
      if (display) {
        if (/more/i.test(display)) {
          if (target !== this._moreLayerActiveButton) {
            var layer = context.element.toolbar.querySelector('.' + command);
            if (layer) {
              if (this._moreLayerActiveButton) this.moreLayerOff();
              this._moreLayerActiveButton = target;
              layer.style.display = 'block';
              event._showToolbarBalloon();
              event._showToolbarInline();
            }
            util.addClass(target, 'on');
          } else {
            var _layer = context.element.toolbar.querySelector('.' + this._moreLayerActiveButton.getAttribute('data-command'));
            if (_layer) {
              this.moreLayerOff();
              event._showToolbarBalloon();
              event._showToolbarInline();
            }
          }
          return;
        }
        if (/container/.test(display) && (this._menuTray[command] === null || target !== this.containerActiveButton)) {
          this.callPlugin(command, this.containerOn.bind(this, target), target);
          return;
        }
        if (this.isReadOnly && util.arrayIncludes(this.resizingDisabledButtons, target)) return;
        if (/submenu/.test(display) && (this._menuTray[command] === null || target !== this.submenuActiveButton)) {
          this.callPlugin(command, this.submenuOn.bind(this, target), target);
          return;
        } else if (/dialog/.test(display)) {
          this.callPlugin(command, this.plugins[command].open.bind(this), target);
          return;
        } else if (/command/.test(display)) {
          this.callPlugin(command, this.plugins[command].action.bind(this), target);
        } else if (/fileBrowser/.test(display)) {
          this.callPlugin(command, this.plugins[command].open.bind(this, null), target);
        }
      } // default command
      else if (command) {
        this.commandHandler(target, command);
      }
      if (/submenu/.test(display)) {
        this.submenuOff();
      } else if (!/command/.test(display)) {
        this.submenuOff();
        this.containerOff();
      }
    },
    /**
     * @description Execute command of command button(All Buttons except submenu and dialog)
     * (selectAll, codeView, fullScreen, indent, outdent, undo, redo, removeFormat, print, preview, showBlocks, save, bold, underline, italic, strike, subscript, superscript, copy, cut, paste)
     * @param {Element|null} target The element of command button
     * @param {String} command Property of command button (data-value)
     */
    commandHandler: function commandHandler(target, command) {
      if (core.isReadOnly && !/copy|cut|selectAll|codeView|fullScreen|print|preview|showBlocks/.test(command)) return;
      switch (command) {
        case 'copy':
        case 'cut':
          this.execCommand(command);
          break;
        case 'paste':
          break;
        case 'selectAll':
          this.containerOff();
          var wysiwyg = context.element.wysiwyg;
          var first = util.getChildElement(wysiwyg.firstChild, function (current) {
            return current.childNodes.length === 0 || current.nodeType === 3;
          }, false) || wysiwyg.firstChild;
          var last = util.getChildElement(wysiwyg.lastChild, function (current) {
            return current.childNodes.length === 0 || current.nodeType === 3;
          }, true) || wysiwyg.lastChild;
          if (!first || !last) return;
          if (util.isMedia(first)) {
            var info = this.getFileComponent(first);
            var br = util.createElement('BR');
            var format = util.createElement(options.defaultTag);
            format.appendChild(br);
            first = info ? info.component : first;
            first.parentNode.insertBefore(format, first);
            first = br;
          }
          if (util.isMedia(last)) {
            var _br = util.createElement('BR');
            var _format2 = util.createElement(options.defaultTag);
            _format2.appendChild(_br);
            wysiwyg.appendChild(_format2);
            last = _br;
          }
          event._showToolbarBalloon(this.setRange(first, 0, last, last.textContent.length));
          break;
        case 'codeView':
          this.toggleCodeView();
          break;
        case 'fullScreen':
          this.toggleFullScreen(target);
          break;
        case 'indent':
        case 'outdent':
          this.indent(command);
          break;
        case 'undo':
          this.history.undo();
          break;
        case 'redo':
          this.history.redo();
          break;
        case 'removeFormat':
          this.removeFormat();
          this.focus();
          break;
        case 'print':
          this.print();
          break;
        case 'preview':
          this.preview();
          break;
        case 'showBlocks':
          this.toggleDisplayBlocks();
          break;
        case 'dir':
          this.setDir(options.rtl ? 'ltr' : 'rtl');
          break;
        case 'dir_ltr':
          this.setDir('ltr');
          break;
        case 'dir_rtl':
          this.setDir('rtl');
          break;
        case 'save':
          if (typeof options.callBackSave === 'function') {
            options.callBackSave(this.getContents(false), this._variable.isChanged);
          } else if (this._variable.isChanged && typeof functions.save === 'function') {
            functions.save();
          } else {
            throw Error('[SUNEDITOR.core.commandHandler.fail] Please register call back function in creation option. (callBackSave : Function)');
          }
          this._variable.isChanged = false;
          if (context.tool.save) context.tool.save.setAttribute('disabled', true);
          break;
        default:
          // 'STRONG', 'U', 'EM', 'DEL', 'SUB', 'SUP'..
          command = options._defaultCommand[command.toLowerCase()] || command;
          if (!this.commandMap[command]) this.commandMap[command] = target;
          var nodesMap = this._variable.currentNodesMap;
          var cmd = nodesMap.indexOf(command) > -1 ? null : util.createElement(command);
          var removeNode = command;
          if (/^SUB$/i.test(command) && nodesMap.indexOf('SUP') > -1) {
            removeNode = 'SUP';
          } else if (/^SUP$/i.test(command) && nodesMap.indexOf('SUB') > -1) {
            removeNode = 'SUB';
          }
          this.nodeChange(cmd, this._commandMapStyles[command] || null, [removeNode], false);
          this.focus();
      }
    },
    /**
     * @description Remove format of the currently selected range
     */
    removeFormat: function removeFormat() {
      this.nodeChange(null, null, null, null);
    },
    /**
     * @description This method implements indentation to selected range.
     * Setted "margin-left" to "25px" in the top "P" tag of the parameter node.
     * @param {String} command Separator ("indent" or "outdent")
     */
    indent: function indent(command) {
      var range = this.getRange();
      var rangeLines = this.getSelectedElements(null);
      var cells = [];
      var shift = 'indent' !== command;
      var marginDir = options.rtl ? 'marginRight' : 'marginLeft';
      var sc = range.startContainer;
      var ec = range.endContainer;
      var so = range.startOffset;
      var eo = range.endOffset;
      for (var i = 0, len = rangeLines.length, f, margin; i < len; i++) {
        f = rangeLines[i];
        if (!util.isListCell(f) || !this.plugins.list) {
          margin = /\d+/.test(f.style[marginDir]) ? util.getNumber(f.style[marginDir], 0) : 0;
          if (shift) {
            margin -= 25;
          } else {
            margin += 25;
          }
          util.setStyle(f, marginDir, margin <= 0 ? '' : margin + 'px');
        } else {
          if (shift || f.previousElementSibling) {
            cells.push(f);
          }
        }
      }

      // list cells
      if (cells.length > 0) {
        this.plugins.list.editInsideList.call(this, shift, cells);
      }
      this.effectNode = null;
      this.setRange(sc, so, ec, eo);

      // history stack
      this.history.push(false);
    },
    /**
     * @description Add or remove the class name of "body" so that the code block is visible
     */
    toggleDisplayBlocks: function toggleDisplayBlocks() {
      var wysiwyg = context.element.wysiwyg;
      util.toggleClass(wysiwyg, 'se-show-block');
      if (util.hasClass(wysiwyg, 'se-show-block')) {
        util.addClass(this._styleCommandMap.showBlocks, 'active');
      } else {
        util.removeClass(this._styleCommandMap.showBlocks, 'active');
      }
      this._resourcesStateChange();
    },
    /**
     * @description Changes to code view or wysiwyg view
     */
    toggleCodeView: function toggleCodeView() {
      var isCodeView = this._variable.isCodeView;
      this.controllersOff();
      util.setDisabledButtons(!isCodeView, this.codeViewDisabledButtons);
      if (isCodeView) {
        if (!util.isNonEditable(context.element.wysiwygFrame)) this._setCodeDataToEditor();
        context.element.wysiwygFrame.scrollTop = 0;
        context.element.code.style.display = 'none';
        context.element.wysiwygFrame.style.display = 'block';
        this._variable._codeOriginCssText = this._variable._codeOriginCssText.replace(/(\s?display(\s+)?:(\s+)?)[a-zA-Z]+(?=;)/, 'display: none');
        this._variable._wysiwygOriginCssText = this._variable._wysiwygOriginCssText.replace(/(\s?display(\s+)?:(\s+)?)[a-zA-Z]+(?=;)/, 'display: block');
        if (options.height === 'auto' && !options.codeMirrorEditor) context.element.code.style.height = '0px';
        this._variable.isCodeView = false;
        if (!this._variable.isFullScreen) {
          this._notHideToolbar = false;
          if (/balloon|balloon-always/i.test(options.mode)) {
            context.element._arrow.style.display = '';
            this._isInline = false;
            this._isBalloon = true;
            event._hideToolbar();
          }
        }
        this.nativeFocus();
        util.removeClass(this._styleCommandMap.codeView, 'active');

        // history stack
        if (!util.isNonEditable(context.element.wysiwygFrame)) {
          this.history.push(false);
          this.history._resetCachingButton();
        }
      } else {
        this._setEditorDataToCodeView();
        this._variable._codeOriginCssText = this._variable._codeOriginCssText.replace(/(\s?display(\s+)?:(\s+)?)[a-zA-Z]+(?=;)/, 'display: block');
        this._variable._wysiwygOriginCssText = this._variable._wysiwygOriginCssText.replace(/(\s?display(\s+)?:(\s+)?)[a-zA-Z]+(?=;)/, 'display: none');
        if (this._variable.isFullScreen) context.element.code.style.height = '100%';else if (options.height === 'auto' && !options.codeMirrorEditor) context.element.code.style.height = context.element.code.scrollHeight > 0 ? context.element.code.scrollHeight + 'px' : 'auto';
        if (options.codeMirrorEditor) options.codeMirrorEditor.refresh();
        this._variable.isCodeView = true;
        if (!this._variable.isFullScreen) {
          this._notHideToolbar = true;
          if (this._isBalloon) {
            context.element._arrow.style.display = 'none';
            context.element.toolbar.style.left = '';
            this._isInline = true;
            this._isBalloon = false;
            event._showToolbarInline();
          }
        }
        this._variable._range = null;
        context.element.code.focus();
        util.addClass(this._styleCommandMap.codeView, 'active');
      }
      this._checkPlaceholder();
      if (this.isReadOnly) util.setDisabledButtons(true, this.resizingDisabledButtons);

      // user event
      if (typeof functions.toggleCodeView === 'function') functions.toggleCodeView(this._variable.isCodeView, this);
    },
    /**
     * @description Convert the data of the code view and put it in the WYSIWYG area.
     * @private
     */
    _setCodeDataToEditor: function _setCodeDataToEditor() {
      var code_html = this._getCodeView();
      if (options.fullPage) {
        var parseDocument = this._parser.parseFromString(code_html, 'text/html');
        var headChildren = parseDocument.head.children;
        for (var i = 0, len = headChildren.length; i < len; i++) {
          if (/^script$/i.test(headChildren[i].tagName)) {
            parseDocument.head.removeChild(headChildren[i]);
            i--, len--;
          }
        }
        var headers = parseDocument.head.innerHTML;
        if (!parseDocument.head.querySelector('link[rel="stylesheet"]') || this.options.height === 'auto' && !parseDocument.head.querySelector('style')) {
          headers += util._setIframeCssTags(this.options);
        }
        this._wd.head.innerHTML = headers;
        this._wd.body.innerHTML = this.convertContentsForEditor(parseDocument.body.innerHTML);
        var attrs = parseDocument.body.attributes;
        for (var _i21 = 0, _len10 = attrs.length; _i21 < _len10; _i21++) {
          if (attrs[_i21].name === 'contenteditable') continue;
          this._wd.body.setAttribute(attrs[_i21].name, attrs[_i21].value);
        }
        if (!util.hasClass(this._wd.body, 'sun-editor-editable')) {
          var editableClasses = options._editableClass.split(' ');
          for (var _i22 = 0; _i22 < editableClasses.length; _i22++) {
            util.addClass(this._wd.body, options._editableClass[_i22]);
          }
        }
      } else {
        context.element.wysiwyg.innerHTML = code_html.length > 0 ? this.convertContentsForEditor(code_html) : '<' + options.defaultTag + '><br></' + options.defaultTag + '>';
      }
    },
    /**
     * @description Convert the data of the WYSIWYG area and put it in the code view area.
     * @private
     */
    _setEditorDataToCodeView: function _setEditorDataToCodeView() {
      var codeContents = this.convertHTMLForCodeView(context.element.wysiwyg, false);
      var codeValue = '';
      if (options.fullPage) {
        var attrs = util.getAttributesToString(this._wd.body, null);
        codeValue = '<!DOCTYPE html>\n<html>\n' + this._wd.head.outerHTML.replace(/>(?!\n)/g, '>\n') + '<body ' + attrs + '>\n' + codeContents + '</body>\n</html>';
      } else {
        codeValue = codeContents;
      }
      context.element.code.style.display = 'block';
      context.element.wysiwygFrame.style.display = 'none';
      this._setCodeView(codeValue);
    },
    /**
     * @description Changes to full screen or default screen
     * @param {Element|null} element full screen button
     */
    toggleFullScreen: function toggleFullScreen(element) {
      var topArea = context.element.topArea;
      var toolbar = context.element.toolbar;
      var editorArea = context.element.editorArea;
      var wysiwygFrame = context.element.wysiwygFrame;
      var code = context.element.code;
      var _var = this._variable;
      this.controllersOff();
      var wasToolbarHidden = toolbar.style.display === 'none' || this._isInline && !this._inlineToolbarAttr.isShow;
      if (!_var.isFullScreen) {
        _var.isFullScreen = true;
        _var._fullScreenAttrs.inline = this._isInline;
        _var._fullScreenAttrs.balloon = this._isBalloon;
        if (this._isInline || this._isBalloon) {
          this._isInline = false;
          this._isBalloon = false;
        }
        if (!!options.toolbarContainer) context.element.relative.insertBefore(toolbar, editorArea);
        topArea.style.position = 'fixed';
        topArea.style.top = '0';
        topArea.style.left = '0';
        topArea.style.width = '100%';
        topArea.style.maxWidth = '100%';
        topArea.style.height = '100%';
        topArea.style.zIndex = '2147483647';
        if (context.element._stickyDummy.style.display !== ( true && '')) {
          _var._fullScreenAttrs.sticky = true;
          context.element._stickyDummy.style.display = 'none';
          util.removeClass(toolbar, 'se-toolbar-sticky');
        }
        _var._bodyOverflow = _d.body.style.overflow;
        _d.body.style.overflow = 'hidden';
        _var._editorAreaOriginCssText = editorArea.style.cssText;
        _var._wysiwygOriginCssText = wysiwygFrame.style.cssText;
        _var._codeOriginCssText = code.style.cssText;
        editorArea.style.cssText = toolbar.style.cssText = '';
        wysiwygFrame.style.cssText = (wysiwygFrame.style.cssText.match(/\s?display(\s+)?:(\s+)?[a-zA-Z]+;/) || [''])[0] + options.defaultStyle;
        code.style.cssText = (code.style.cssText.match(/\s?display(\s+)?:(\s+)?[a-zA-Z]+;/) || [''])[0];
        toolbar.style.width = wysiwygFrame.style.height = code.style.height = '100%';
        toolbar.style.position = 'relative';
        toolbar.style.display = 'block';
        _var.innerHeight_fullScreen = _w.innerHeight - toolbar.offsetHeight;
        editorArea.style.height = _var.innerHeight_fullScreen - options.fullScreenOffset + 'px';
        if (element) util.changeElement(element.firstElementChild, icons.reduction);
        if (options.iframe && options.height === 'auto') {
          editorArea.style.overflow = 'auto';
          this._iframeAutoHeight();
        }
        context.element.topArea.style.marginTop = options.fullScreenOffset + 'px';
        util.addClass(this._styleCommandMap.fullScreen, 'active');
      } else {
        _var.isFullScreen = false;
        wysiwygFrame.style.cssText = _var._wysiwygOriginCssText;
        code.style.cssText = _var._codeOriginCssText;
        toolbar.style.cssText = '';
        editorArea.style.cssText = _var._editorAreaOriginCssText;
        topArea.style.cssText = _var._originCssText;
        _d.body.style.overflow = _var._bodyOverflow;
        if (options.height === 'auto' && !options.codeMirrorEditor) event._codeViewAutoHeight();
        if (!!options.toolbarContainer) options.toolbarContainer.appendChild(toolbar);
        if (options.stickyToolbar > -1) {
          util.removeClass(toolbar, 'se-toolbar-sticky');
        }
        if (_var._fullScreenAttrs.sticky && !options.toolbarContainer) {
          _var._fullScreenAttrs.sticky = false;
          context.element._stickyDummy.style.display = 'block';
          util.addClass(toolbar, "se-toolbar-sticky");
        }
        this._isInline = _var._fullScreenAttrs.inline;
        this._isBalloon = _var._fullScreenAttrs.balloon;
        if (this._isInline) event._showToolbarInline();
        if (!!options.toolbarContainer) util.removeClass(toolbar, 'se-toolbar-balloon');
        event.onScroll_window();
        if (element) util.changeElement(element.firstElementChild, icons.expansion);
        context.element.topArea.style.marginTop = '';
        util.removeClass(this._styleCommandMap.fullScreen, 'active');
      }
      if (wasToolbarHidden) functions.toolbar.hide();

      // user event
      if (typeof functions.toggleFullScreen === 'function') functions.toggleFullScreen(this._variable.isFullScreen, this);
    },
    /**
     * @description Prints the current contents of the editor.
     */
    print: function print() {
      var iframe = util.createElement('IFRAME');
      iframe.style.display = 'none';
      _d.body.appendChild(iframe);
      var contentsHTML = options.printTemplate ? options.printTemplate.replace(/\{\{\s*contents\s*\}\}/i, this.getContents(true)) : this.getContents(true);
      var printDocument = util.getIframeDocument(iframe);
      var wDoc = this._wd;
      if (options.iframe) {
        var arrts = options._printClass !== null ? 'class="' + options._printClass + '"' : options.fullPage ? util.getAttributesToString(wDoc.body, ['contenteditable']) : 'class="' + options._editableClass + '"';
        printDocument.write('' + '<!DOCTYPE html><html>' + '<head>' + wDoc.head.innerHTML + '</head>' + '<body ' + arrts + '>' + contentsHTML + '</body>' + '</html>');
      } else {
        var links = _d.head.getElementsByTagName('link');
        var styles = _d.head.getElementsByTagName('style');
        var linkHTML = '';
        for (var i = 0, len = links.length; i < len; i++) {
          linkHTML += links[i].outerHTML;
        }
        for (var _i23 = 0, _len11 = styles.length; _i23 < _len11; _i23++) {
          linkHTML += styles[_i23].outerHTML;
        }
        printDocument.write('' + '<!DOCTYPE html><html>' + '<head>' + linkHTML + '</head>' + '<body class="' + (options._printClass !== null ? options._printClass : options._editableClass) + '">' + contentsHTML + '</body>' + '</html>');
      }
      this.showLoading();
      _w.setTimeout(function () {
        try {
          iframe.focus();
          // IE or Edge, Chromium
          if (util.isIE_Edge || util.isChromium || !!_d.documentMode || !!_w.StyleMedia) {
            try {
              iframe.contentWindow.document.execCommand('print', false, null);
            } catch (e) {
              iframe.contentWindow.print();
            }
          } else {
            // Other browsers
            iframe.contentWindow.print();
          }
        } catch (error) {
          throw Error('[SUNEDITOR.core.print.fail] error: ' + error);
        } finally {
          core.closeLoading();
          util.removeItem(iframe);
        }
      }, 1000);
    },
    /**
     * @description Open the preview window.
     */
    preview: function preview() {
      core.submenuOff();
      core.containerOff();
      core.controllersOff();
      var contentsHTML = options.previewTemplate ? options.previewTemplate.replace(/\{\{\s*contents\s*\}\}/i, this.getContents(true)) : this.getContents(true);
      var windowObject = _w.open('', '_blank');
      windowObject.mimeType = 'text/html';
      var wDoc = this._wd;
      if (options.iframe) {
        var arrts = options._printClass !== null ? 'class="' + options._printClass + '"' : options.fullPage ? util.getAttributesToString(wDoc.body, ['contenteditable']) : 'class="' + options._editableClass + '"';
        windowObject.document.write('' + '<!DOCTYPE html><html>' + '<head>' + wDoc.head.innerHTML + '<style>body {overflow:auto !important; margin: 10px auto !important; height:auto !important; outline:1px dashed #ccc;}</style>' + '</head>' + '<body ' + arrts + '>' + contentsHTML + '</body>' + '</html>');
      } else {
        var links = _d.head.getElementsByTagName('link');
        var styles = _d.head.getElementsByTagName('style');
        var linkHTML = '';
        for (var i = 0, len = links.length; i < len; i++) {
          linkHTML += links[i].outerHTML;
        }
        for (var _i24 = 0, _len12 = styles.length; _i24 < _len12; _i24++) {
          linkHTML += styles[_i24].outerHTML;
        }
        windowObject.document.write('' + '<!DOCTYPE html><html>' + '<head>' + '<meta charset="utf-8" />' + '<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">' + '<title>' + lang.toolbar.preview + '</title>' + linkHTML + '</head>' + '<body class="' + (options._printClass !== null ? options._printClass : options._editableClass) + '" style="margin:10px auto !important; height:auto !important; outline:1px dashed #ccc;">' + contentsHTML + '</body>' + '</html>');
      }
    },
    /**
     * @description Set direction to "rtl" or "ltr".
     * @param {String} dir "rtl" or "ltr"
     */
    setDir: function setDir(dir) {
      var rtl = dir === 'rtl';
      var changeDir = this._prevRtl !== rtl;
      this._prevRtl = options.rtl = rtl;
      if (changeDir) {
        // align buttons
        if (this.plugins.align) {
          this.plugins.align.exchangeDir.call(this);
        }
        // indent buttons
        if (context.tool.indent) util.changeElement(context.tool.indent.firstElementChild, icons.indent);
        if (context.tool.outdent) util.changeElement(context.tool.outdent.firstElementChild, icons.outdent);
      }
      var el = context.element;
      if (rtl) {
        util.addClass(el.topArea, 'se-rtl');
        util.addClass(el.wysiwygFrame, 'se-rtl');
      } else {
        util.removeClass(el.topArea, 'se-rtl');
        util.removeClass(el.wysiwygFrame, 'se-rtl');
      }
      var lineNodes = util.getListChildren(el.wysiwyg, function (current) {
        return util.isFormatElement(current) && (current.style.marginRight || current.style.marginLeft || current.style.textAlign);
      });
      for (var i = 0, len = lineNodes.length, n, l, r; i < len; i++) {
        n = lineNodes[i];
        // indent margin
        r = n.style.marginRight;
        l = n.style.marginLeft;
        if (r || l) {
          n.style.marginRight = l;
          n.style.marginLeft = r;
        }
        // text align
        r = n.style.textAlign;
        if (r === 'left') n.style.textAlign = 'right';else if (r === 'right') n.style.textAlign = 'left';
      }
      var tool = context.tool;
      if (tool.dir) {
        util.changeTxt(tool.dir.querySelector('.se-tooltip-text'), lang.toolbar[options.rtl ? 'dir_ltr' : 'dir_rtl']);
        util.changeElement(tool.dir.firstElementChild, icons[options.rtl ? 'dir_ltr' : 'dir_rtl']);
      }
      if (tool.dir_ltr) {
        if (rtl) util.removeClass(tool.dir_ltr, 'active');else util.addClass(tool.dir_ltr, 'active');
      }
      if (tool.dir_rtl) {
        if (rtl) util.addClass(tool.dir_rtl, 'active');else util.removeClass(tool.dir_rtl, 'active');
      }
    },
    /**
     * @description Sets the HTML string
     * @param {String|undefined} html HTML string
     */
    setContents: function setContents(html) {
      this.removeRange();
      var convertValue = html === null || html === undefined ? '' : this.convertContentsForEditor(html);
      this._resetComponents();
      if (!this._variable.isCodeView) {
        context.element.wysiwyg.innerHTML = convertValue;
        // history stack
        this.history.push(false);
      } else {
        var value = this.convertHTMLForCodeView(convertValue, false);
        this._setCodeView(value);
      }
    },
    /**
     * @description Sets the contents of the iframe's head tag and body tag when using the "iframe" or "fullPage" option.
     * @param {Object} ctx { head: HTML string, body: HTML string}
     */
    setIframeContents: function setIframeContents(ctx) {
      if (!options.iframe) return false;
      if (ctx.head) this._wd.head.innerHTML = ctx.head.replace(/<script[\s\S]*>[\s\S]*<\/script>/gi, '');
      if (ctx.body) this._wd.body.innerHTML = this.convertContentsForEditor(ctx.body);
    },
    /**
     * @description Gets the current contents
     * @param {Boolean} onlyContents Return only the contents of the body without headers when the "fullPage" option is true
     * @returns {Object}
     */
    getContents: function getContents(onlyContents) {
      var contents = this.convertHTMLForCodeView(context.element.wysiwyg, true);
      var renderHTML = util.createElement('DIV');
      renderHTML.innerHTML = contents;
      var figcaptions = util.getListChildren(renderHTML, function (current) {
        return /FIGCAPTION/i.test(current.nodeName);
      });
      for (var i = 0, len = figcaptions.length; i < len; i++) {
        figcaptions[i].removeAttribute('contenteditable');
      }
      if (options.fullPage && !onlyContents) {
        var attrs = util.getAttributesToString(this._wd.body, ['contenteditable']);
        return '<!DOCTYPE html><html>' + this._wd.head.outerHTML + '<body ' + attrs + '>' + renderHTML.innerHTML + '</body></html>';
      } else {
        return renderHTML.innerHTML;
      }
    },
    /**
     * @description Gets the current contents with containing parent div(div.sun-editor-editable).
     * <div class="sun-editor-editable">{contents}</div>
     * @param {Boolean} onlyContents Return only the contents of the body without headers when the "fullPage" option is true
     * @returns {String}
     */
    getFullContents: function getFullContents(onlyContents) {
      return '<div class="sun-editor-editable' + (options.rtl ? ' se-rtl' : '') + '">' + this.getContents(onlyContents) + '</div>';
    },
    /**
     * @description Returns HTML string according to tag type and configuration.
     * Use only "cleanHTML"
     * @param {Node} node Node
     * @param {Boolean} requireFormat If true, text nodes that do not have a format node is wrapped with the format tag.
     * @private
     */
    _makeLine: function _makeLine(node, requireFormat) {
      var defaultTag = options.defaultTag;
      // element
      if (node.nodeType === 1) {
        if (util._disallowedTags(node)) return '';
        var ch = util.getListChildNodes(node, function (current) {
          return util.isSpanWithoutAttr(current);
        }) || [];
        for (var i = ch.length - 1; i >= 0; i--) {
          ch[i].outerHTML = ch[i].innerHTML;
        }
        if (!requireFormat || util.isFormatElement(node) || util.isRangeFormatElement(node) || util.isComponent(node) || util.isMedia(node) || util.isAnchor(node) && util.isMedia(node.firstElementChild)) {
          return util.isSpanWithoutAttr(node) ? node.innerHTML : node.outerHTML;
        } else {
          return '<' + defaultTag + '>' + (util.isSpanWithoutAttr(node) ? node.innerHTML : node.outerHTML) + '</' + defaultTag + '>';
        }
      }
      // text
      if (node.nodeType === 3) {
        if (!requireFormat) return util._HTMLConvertor(node.textContent);
        var textArray = node.textContent.split(/\n/g);
        var html = '';
        for (var _i25 = 0, tLen = textArray.length, text; _i25 < tLen; _i25++) {
          text = textArray[_i25].trim();
          if (text.length > 0) html += '<' + defaultTag + '>' + util._HTMLConvertor(text) + '</' + defaultTag + '>';
        }
        return html;
      }
      // comments
      if (node.nodeType === 8 && this._allowHTMLComments) {
        return '<!--' + node.textContent.trim() + '-->';
      }
      return '';
    },
    /**
     * @description Removes attribute values such as style and converts tags that do not conform to the "html5" standard.
     * @param {String} text 
     * @returns {String} HTML string
     * @private
     */
    _tagConvertor: function _tagConvertor(text) {
      if (!this._disallowedTextTagsRegExp) return text;
      var ec = options._textTagsMap;
      return text.replace(this._disallowedTextTagsRegExp, function (m, t, n, p) {
        return t + (typeof ec[n] === 'string' ? ec[n] : n) + (p ? ' ' + p : '');
      });
    },
    /**
     * @description Delete disallowed tags
     * @param {String} html HTML string
     * @returns {String}
     * @private
     */
    _deleteDisallowedTags: function _deleteDisallowedTags(html) {
      return html.replace(/\n/g, '').replace(/<(script|style)[\s\S]*>[\s\S]*<\/(script|style)>/gi, '').replace(/<[a-z0-9]+\:[a-z0-9]+[^>^\/]*>[^>]*<\/[a-z0-9]+\:[a-z0-9]+>/gi, '').replace(this.editorTagsWhitelistRegExp, '').replace(this.editorTagsBlacklistRegExp, '');
    },
    _convertFontSize: function _convertFontSize(to, size) {
      var value = size.match(/(\d+(?:\.\d+)?)(.+)/);
      var sizeNum = value[1] * 1;
      var from = value[2];
      var pxSize = sizeNum;
      if (/em/.test(from)) {
        pxSize = this.round(sizeNum / 0.0625);
      } else if (from === 'pt') {
        pxSize = this.round(sizeNum * 1.333);
      } else if (from === '%') {
        pxSize = sizeNum / 100;
      }
      switch (to) {
        case 'em':
        case 'rem':
        case '%':
          return (pxSize * 0.0625).toFixed(2) + to;
        case 'pt':
          return this.floor(pxSize / 1.333) + to;
        default:
          // px
          return pxSize + to;
      }
    },
    _cleanStyle: function _cleanStyle(m, v, name) {
      var sv = m.match(/style\s*=\s*(?:"|')[^"']*(?:"|')/);
      if (sv) {
        if (!v) v = [];
        var style = sv[0].replace(/&quot;/g, '').match(this._cleanStyleRegExp[name]);
        if (style) {
          var allowedStyle = [];
          for (var i = 0, len = style.length, r; i < len; i++) {
            r = style[i].match(/([a-zA-Z0-9-]+)(:)([^:]+$)/);
            if (r && !/inherit|initial/i.test(r[3])) {
              var k = util.kebabToCamelCase(r[1].trim());
              var _v = this.wwComputedStyle[k].replace(/"/g, '');
              var c = r[3].trim();
              switch (k) {
                case 'fontFamily':
                  if (!options.plugins.font || options.font.indexOf(c) === -1) continue;
                  break;
                case 'fontSize':
                  if (!options.plugins.fontSize) continue;
                  if (!this._cleanStyleRegExp.fontSizeUnit.test(r[0])) {
                    r[0] = r[0].replace(this._w.RegExp('\\d+' + r[0].match(/\d+(.+$)/)[1]), this._convertFontSize.bind(this._w.Math, options.fontSizeUnit));
                  }
                  break;
                case 'color':
                  if (!options.plugins.fontColor || /rgba\(([0-9]+\s*,\s*){3}0\)|windowtext/i.test(c)) continue;
                  break;
                case 'backgroundColor':
                  if (!options.plugins.hiliteColor || /rgba\(([0-9]+\s*,\s*){3}0\)|windowtext/i.test(c)) continue;
                  break;
              }
              if (_v !== c) {
                allowedStyle.push(r[0]);
              }
            }
          }
          if (allowedStyle.length > 0) v.push('style="' + allowedStyle.join(';') + '"');
        }
      }
      return v;
    },
    /**
     * @description Tag and tag attribute check RegExp function. (used by "cleanHTML" and "convertContentsForEditor")
     * @param {Boolean} lowLevelCheck Row level check
     * @param {String} m RegExp value
     * @param {String} t RegExp value
     * @returns {String}
     * @private
     */
    _cleanTags: function _cleanTags(lowLevelCheck, m, t) {
      if (/^<[a-z0-9]+\:[a-z0-9]+/i.test(m)) return m;
      var v = null;
      var tagName = t.match(/(?!<)[a-zA-Z0-9\-]+/)[0].toLowerCase();

      // blacklist
      var bAttr = this._attributesTagsBlacklist[tagName];
      m = m.replace(/\s(?:on[a-z]+)\s*=\s*(")[^"]*\1/ig, '');
      if (bAttr) m = m.replace(bAttr, '');else m = m.replace(this._attributesBlacklistRegExp, '');

      // whitelist
      var wAttr = this._attributesTagsWhitelist[tagName];
      if (wAttr) v = m.match(wAttr);else v = m.match(lowLevelCheck ? this._attributesWhitelistRegExp : this._attributesWhitelistRegExp_all_data);

      // attribute
      if (lowLevelCheck) {
        if (tagName === 'a') {
          var sv = m.match(/(?:(?:id|name)\s*=\s*(?:"|')[^"']*(?:"|'))/g);
          if (sv) {
            if (!v) v = [];
            v.push(sv[0]);
          }
        } else if (!v || !/style=/i.test(v.toString())) {
          if (tagName === 'span') {
            v = this._cleanStyle(m, v, 'span');
          } else if (/^(P|DIV|H[1-6]|PRE)$/i.test(tagName)) {
            v = this._cleanStyle(m, v, 'format');
          }
        }
      } else {
        var _sv = m.match(/style\s*=\s*(?:"|')[^"']*(?:"|')/);
        if (_sv && !v) v = [_sv[0]];else if (_sv && !v.some(function (v) {
          return /^style/.test(v.trim());
        })) v.push(_sv[0]);
      }

      // img
      if (tagName === 'img') {
        var w = '',
          h = '';
        var _sv2 = m.match(/style\s*=\s*(?:"|')[^"']*(?:"|')/);
        if (!v) v = [];
        if (_sv2) {
          w = _sv2[0].match(/width:(.+);/);
          w = util.getNumber(w ? w[1] : '', -1) || '';
          h = _sv2[0].match(/height:(.+);/);
          h = util.getNumber(h ? h[1] : '', -1) || '';
        }
        if (!w || !h) {
          var avw = m.match(/width\s*=\s*((?:"|')[^"']*(?:"|'))/);
          var avh = m.match(/height\s*=\s*((?:"|')[^"']*(?:"|'))/);
          if (avw || avh) {
            w = !w ? util.getNumber(avw ? avw[1] : '') || '' : w;
            h = !h ? util.getNumber(avh ? avh[1] : '') || '' : h;
          }
        }
        v.push('data-origin="' + (w + ',' + h) + '"');
      }
      if (v) {
        for (var i = 0, len = v.length; i < len; i++) {
          if (lowLevelCheck && /^class="(?!(__se__|se-|katex))/.test(v[i].trim())) continue;
          t += ' ' + (/^(?:href|src)\s*=\s*('|"|\s)*javascript\s*\:/i.test(v[i].trim()) ? '' : v[i]);
        }
      }
      return t;
    },
    /**
     * @description Determines if formatting is required and returns a domTree
     * @param {Element} dom documentFragment
     * @returns {Element}
     * @private
     */
    _editFormat: function _editFormat(dom) {
      var value = '',
        f;
      var tempTree = dom.childNodes;
      for (var i = 0, len = tempTree.length, n; i < len; i++) {
        n = tempTree[i];
        if (!util.isFormatElement(n) && !util.isRangeFormatElement(n) && !util.isComponent(n) && !/meta/i.test(n.nodeName)) {
          if (!f) f = util.createElement(options.defaultTag);
          f.appendChild(n);
          i--;
          len--;
        } else {
          if (f) {
            value += f.outerHTML;
            f = null;
          }
          value += n.outerHTML;
        }
      }
      if (f) value += f.outerHTML;
      return _d.createRange().createContextualFragment(value);
    },
    _convertListCell: function _convertListCell(domTree) {
      var html = '';
      for (var i = 0, len = domTree.length, node; i < len; i++) {
        node = domTree[i];
        if (node.nodeType === 1) {
          if (util.isList(node)) {
            html += node.innerHTML;
          } else if (util.isListCell(node)) {
            html += node.outerHTML;
          } else if (util.isFormatElement(node)) {
            html += '<li>' + (node.innerHTML.trim() || '<br>') + '</li>';
          } else if (util.isRangeFormatElement(node) && !util.isTable(node)) {
            html += this._convertListCell(node);
          } else {
            html += '<li>' + node.outerHTML + '</li>';
          }
        } else {
          html += '<li>' + (node.textContent || '<br>') + '</li>';
        }
      }
      return html;
    },
    _isFormatData: function _isFormatData(domTree) {
      var requireFormat = false;
      for (var i = 0, len = domTree.length, t; i < len; i++) {
        t = domTree[i];
        if (t.nodeType === 1 && !util.isTextStyleElement(t) && !util.isBreak(t) && !util._disallowedTags(t)) {
          requireFormat = true;
          break;
        }
      }
      return requireFormat;
    },
    /**
     * @description Gets the clean HTML code for editor
     * @param {String} html HTML string
     * @param {String|RegExp|null} whitelist Regular expression of allowed tags.
     * RegExp object is create by util.createTagsWhitelist method. (core.pasteTagsWhitelistRegExp)
     * @param {String|RegExp|null} blacklist Regular expression of disallowed tags.
     * RegExp object is create by util.createTagsBlacklist method. (core.pasteTagsBlacklistRegExp)
     * @returns {String}
     */
    cleanHTML: function cleanHTML(html, whitelist, blacklist) {
      html = this._deleteDisallowedTags(this._parser.parseFromString(html, 'text/html').body.innerHTML).replace(/(<[a-zA-Z0-9\-]+)[^>]*(?=>)/g, this._cleanTags.bind(this, true));
      var dom = _d.createRange().createContextualFragment(html);
      try {
        util._consistencyCheckOfHTML(dom, this._htmlCheckWhitelistRegExp, this._htmlCheckBlacklistRegExp, true);
      } catch (error) {
        console.warn('[SUNEDITOR.cleanHTML.consistencyCheck.fail] ' + error);
      }
      if (this.managedTagsInfo && this.managedTagsInfo.query) {
        var textCompList = dom.querySelectorAll(this.managedTagsInfo.query);
        for (var i = 0, len = textCompList.length, initMethod, classList; i < len; i++) {
          classList = [].slice.call(textCompList[i].classList);
          for (var c = 0, cLen = classList.length; c < cLen; c++) {
            initMethod = this.managedTagsInfo.map[classList[c]];
            if (initMethod) {
              initMethod(textCompList[i]);
              break;
            }
          }
        }
      }
      var domTree = dom.childNodes;
      var cleanHTML = '';
      var requireFormat = this._isFormatData(domTree);
      if (requireFormat) {
        domTree = this._editFormat(dom).childNodes;
      }
      for (var _i26 = 0, _len13 = domTree.length; _i26 < _len13; _i26++) {
        cleanHTML += this._makeLine(domTree[_i26], requireFormat);
      }
      cleanHTML = util.htmlRemoveWhiteSpace(cleanHTML);
      if (!cleanHTML) {
        cleanHTML = html;
      } else {
        if (whitelist) cleanHTML = cleanHTML.replace(typeof whitelist === 'string' ? util.createTagsWhitelist(whitelist) : whitelist, '');
        if (blacklist) cleanHTML = cleanHTML.replace(typeof blacklist === 'string' ? util.createTagsBlacklist(blacklist) : blacklist, '');
      }
      return this._tagConvertor(cleanHTML);
    },
    /**
     * @description Converts contents into a format that can be placed in an editor
     * @param {String} contents contents
     * @returns {String}
     */
    convertContentsForEditor: function convertContentsForEditor(contents) {
      contents = this._deleteDisallowedTags(this._parser.parseFromString(contents, 'text/html').body.innerHTML).replace(/(<[a-zA-Z0-9\-]+)[^>]*(?=>)/g, this._cleanTags.bind(this, false));
      var dom = _d.createRange().createContextualFragment(contents);
      try {
        util._consistencyCheckOfHTML(dom, this._htmlCheckWhitelistRegExp, this._htmlCheckBlacklistRegExp, false);
      } catch (error) {
        console.warn('[SUNEDITOR.convertContentsForEditor.consistencyCheck.fail] ' + error);
      }
      if (this.managedTagsInfo && this.managedTagsInfo.query) {
        var textCompList = dom.querySelectorAll(this.managedTagsInfo.query);
        for (var i = 0, len = textCompList.length, initMethod, classList; i < len; i++) {
          classList = [].slice.call(textCompList[i].classList);
          for (var c = 0, cLen = classList.length; c < cLen; c++) {
            initMethod = this.managedTagsInfo.map[classList[c]];
            if (initMethod) {
              initMethod(textCompList[i]);
              break;
            }
          }
        }
      }
      var domTree = dom.childNodes;
      var cleanHTML = '',
        p = null;
      for (var _i27 = 0, t; _i27 < domTree.length; _i27++) {
        t = domTree[_i27];
        if (!util.isFormatElement(t) && !util.isRangeFormatElement(t) && !util.isComponent(t) && !util.isMedia(t) && t.nodeType !== 8) {
          if (!p) p = util.createElement(options.defaultTag);
          p.appendChild(t);
          _i27--;
          if (domTree[_i27 + 1] && !util.isFormatElement(domTree[_i27 + 1])) {
            continue;
          } else {
            t = p;
            p = null;
          }
        }
        if (p) {
          cleanHTML += this._makeLine(p, true);
          p = null;
        }
        cleanHTML += this._makeLine(t, true);
      }
      if (p) cleanHTML += this._makeLine(p, true);
      if (cleanHTML.length === 0) return '<' + options.defaultTag + '><br></' + options.defaultTag + '>';
      cleanHTML = util.htmlRemoveWhiteSpace(cleanHTML);
      return this._tagConvertor(cleanHTML);
    },
    /**
     * @description Converts wysiwyg area element into a format that can be placed in an editor of code view mode
     * @param {Element|String} html WYSIWYG element (context.element.wysiwyg) or HTML string.
     * @param {Boolean} comp If true, does not line break and indentation of tags.
     * @returns {String}
     */
    convertHTMLForCodeView: function convertHTMLForCodeView(html, comp) {
      var returnHTML = '';
      var wRegExp = _w.RegExp;
      var brReg = new wRegExp('^(BLOCKQUOTE|PRE|TABLE|THEAD|TBODY|TR|TH|TD|OL|UL|IMG|IFRAME|VIDEO|AUDIO|FIGURE|FIGCAPTION|HR|BR|CANVAS|SELECT)$', 'i');
      var wDoc = typeof html === 'string' ? _d.createRange().createContextualFragment(html) : html;
      var isFormat = function (current) {
        return this.isFormatElement(current) || this.isComponent(current);
      }.bind(util);
      var brChar = comp ? '' : '\n';
      var indentSize = comp ? 0 : this._variable.codeIndent * 1;
      indentSize = indentSize > 0 ? new _w.Array(indentSize + 1).join(' ') : '';
      (function recursionFunc(element, indent) {
        var children = element.childNodes;
        var elementRegTest = brReg.test(element.nodeName);
        var elementIndent = elementRegTest ? indent : '';
        for (var i = 0, len = children.length, node, br, lineBR, nodeRegTest, tag, tagIndent; i < len; i++) {
          node = children[i];
          nodeRegTest = brReg.test(node.nodeName);
          br = nodeRegTest ? brChar : '';
          lineBR = isFormat(node) && !elementRegTest && !/^(TH|TD)$/i.test(element.nodeName) ? brChar : '';
          if (node.nodeType === 8) {
            returnHTML += '\n<!-- ' + node.textContent.trim() + ' -->' + br;
            continue;
          }
          if (node.nodeType === 3) {
            if (!util.isList(node.parentElement)) returnHTML += util._HTMLConvertor(/^\n+$/.test(node.data) ? '' : node.data);
            continue;
          }
          if (node.childNodes.length === 0) {
            returnHTML += (/^HR$/i.test(node.nodeName) ? brChar : '') + (/^PRE$/i.test(node.parentElement.nodeName) && /^BR$/i.test(node.nodeName) ? '' : elementIndent) + node.outerHTML + br;
            continue;
          }
          if (!node.outerHTML) {
            // IE
            returnHTML += new _w.XMLSerializer().serializeToString(node);
          } else {
            tag = node.nodeName.toLowerCase();
            tagIndent = elementIndent || nodeRegTest ? indent : '';
            returnHTML += (lineBR || (elementRegTest ? '' : br)) + tagIndent + node.outerHTML.match(wRegExp('<' + tag + '[^>]*>', 'i'))[0] + br;
            recursionFunc(node, indent + indentSize, '');
            returnHTML += (/\n$/.test(returnHTML) ? tagIndent : '') + '</' + tag + '>' + (lineBR || br || elementRegTest ? brChar :  false || /^(TH|TD)$/i.test(node.nodeName) ? brChar : '');
          }
        }
      })(wDoc, '');
      return returnHTML.trim() + brChar;
    },
    /**
     * @description Add an event to document.
     * When created as an Iframe, the same event is added to the document in the Iframe.
     * @param {String} type Event type
     * @param {Function} listener Event listener
     * @param {Boolean} useCapture Use event capture
     */
    addDocEvent: function addDocEvent(type, listener, useCapture) {
      _d.addEventListener(type, listener, useCapture);
      if (options.iframe) {
        this._wd.addEventListener(type, listener);
      }
    },
    /**
     * @description Remove events from document.
     * When created as an Iframe, the event of the document inside the Iframe is also removed.
     * @param {String} type Event type
     * @param {Function} listener Event listener
     */
    removeDocEvent: function removeDocEvent(type, listener) {
      _d.removeEventListener(type, listener);
      if (options.iframe) {
        this._wd.removeEventListener(type, listener);
      }
    },
    /**
     * @description The current number of characters is counted and displayed.
     * @param {String} inputText Text added.
     * @returns {Boolean}
     * @private
     */
    _charCount: function _charCount(inputText) {
      var maxCharCount = options.maxCharCount;
      var countType = options.charCounterType;
      var nextCharCount = 0;
      if (!!inputText) nextCharCount = this.getCharLength(inputText, countType);
      this._setCharCount();
      if (maxCharCount > 0) {
        var over = false;
        var count = functions.getCharCount(countType);
        if (count > maxCharCount) {
          over = true;
          if (nextCharCount > 0) {
            this._editorRange();
            var range = this.getRange();
            var endOff = range.endOffset - 1;
            var text = this.getSelectionNode().textContent;
            var slicePosition = range.endOffset - (count - maxCharCount);
            this.getSelectionNode().textContent = text.slice(0, slicePosition < 0 ? 0 : slicePosition) + text.slice(range.endOffset, text.length);
            this.setRange(range.endContainer, endOff, range.endContainer, endOff);
          }
        } else if (count + nextCharCount > maxCharCount) {
          over = true;
        }
        if (over) {
          this._callCounterBlink();
          if (nextCharCount > 0) return false;
        }
      }
      return true;
    },
    /**
     * @description When "element" is added, if it is greater than "options.maxCharCount", false is returned.
     * @param {Node|String} element Element node or String.
     * @param {String|null} charCounterType charCounterType. If it is null, the options.charCounterType
     * @returns {Boolean}
     */
    checkCharCount: function checkCharCount(element, charCounterType) {
      if (options.maxCharCount) {
        var countType = charCounterType || options.charCounterType;
        var length = this.getCharLength(typeof element === 'string' ? element : this._charTypeHTML && element.nodeType === 1 ? element.outerHTML : element.textContent, countType);
        if (length > 0 && length + functions.getCharCount(countType) > options.maxCharCount) {
          this._callCounterBlink();
          return false;
        }
      }
      return true;
    },
    /**
     * @description Get the length of the content.
     * Depending on the option, the length of the character is taken. (charCounterType)
     * @param {String} content Content to count
     * @param {String} charCounterType options.charCounterType
     * @returns {Number}
     */
    getCharLength: function getCharLength(content, charCounterType) {
      return /byte/.test(charCounterType) ? util.getByteLength(content) : content.length;
    },
    /**
     * @description Reset buttons of the responsive toolbar.
     */
    resetResponsiveToolbar: function resetResponsiveToolbar() {
      core.controllersOff();
      var responsiveSize = event._responsiveButtonSize;
      if (responsiveSize) {
        var w = 0;
        if ((core._isBalloon || core._isInline) && options.toolbarWidth === 'auto') {
          w = context.element.topArea.offsetWidth;
        } else {
          w = context.element.toolbar.offsetWidth;
        }
        var responsiveWidth = 'default';
        for (var i = 1, len = responsiveSize.length; i < len; i++) {
          if (w < responsiveSize[i]) {
            responsiveWidth = responsiveSize[i] + '';
            break;
          }
        }
        if (event._responsiveCurrentSize !== responsiveWidth) {
          event._responsiveCurrentSize = responsiveWidth;
          functions.setToolbarButtons(event._responsiveButtons[responsiveWidth]);
        }
      }
    },
    /**
     * @description Set the char count to charCounter element textContent.
     * @private
     */
    _setCharCount: function _setCharCount() {
      if (context.element.charCounter) {
        _w.setTimeout(function () {
          context.element.charCounter.textContent = functions.getCharCount(options.charCounterType);
        });
      }
    },
    /**
     * @description The character counter blinks.
     * @private
     */
    _callCounterBlink: function _callCounterBlink() {
      var charWrapper = context.element.charWrapper;
      if (charWrapper && !util.hasClass(charWrapper, 'se-blink')) {
        util.addClass(charWrapper, 'se-blink');
        _w.setTimeout(function () {
          util.removeClass(charWrapper, 'se-blink');
        }, 600);
      }
    },
    /**
     * @description Check the components such as image and video and modify them according to the format.
     * @private
     */
    _checkComponents: function _checkComponents() {
      for (var i = 0, len = this._fileInfoPluginsCheck.length; i < len; i++) {
        this._fileInfoPluginsCheck[i]();
      }
    },
    /**
     * @description Initialize the information of the components.
     * @private
     */
    _resetComponents: function _resetComponents() {
      for (var i = 0, len = this._fileInfoPluginsReset.length; i < len; i++) {
        this._fileInfoPluginsReset[i]();
      }
    },
    /**
     * @description Set method in the code view area
     * @param {String} value HTML string
     * @private
     */
    _setCodeView: function _setCodeView(value) {
      if (options.codeMirrorEditor) {
        options.codeMirrorEditor.getDoc().setValue(value);
      } else {
        context.element.code.value = value;
      }
    },
    /**
     * @description Get method in the code view area
     * @private
     */
    _getCodeView: function _getCodeView() {
      return options.codeMirrorEditor ? options.codeMirrorEditor.getDoc().getValue() : context.element.code.value;
    },
    /**
     * @description remove class, display text.
     * @param {Array|null} ignoredList Igonred button list
     */
    _setKeyEffect: function _setKeyEffect(ignoredList) {
      var commandMap = this.commandMap;
      var activePlugins = this.activePlugins;
      for (var key in commandMap) {
        if (ignoredList.indexOf(key) > -1 || !util.hasOwn(commandMap, key)) continue;
        if (activePlugins.indexOf(key) > -1) {
          plugins[key].active.call(this, null);
        } else if (commandMap.OUTDENT && /^OUTDENT$/i.test(key)) {
          if (!util.isImportantDisabled(commandMap.OUTDENT)) commandMap.OUTDENT.setAttribute('disabled', true);
        } else if (commandMap.INDENT && /^INDENT$/i.test(key)) {
          if (!util.isImportantDisabled(commandMap.INDENT)) commandMap.INDENT.removeAttribute('disabled');
        } else {
          util.removeClass(commandMap[key], 'active');
        }
      }
    },
    /**
     * @description Initializ core variable
     * @param {Boolean} reload Is relooad?
     * @param {String} _initHTML initial html string
     * @private
     */
    _init: function _init(reload, _initHTML) {
      var wRegExp = _w.RegExp;
      this._ww = options.iframe ? context.element.wysiwygFrame.contentWindow : _w;
      this._wd = _d;
      this._charTypeHTML = options.charCounterType === 'byte-html';
      this.wwComputedStyle = _w.getComputedStyle(context.element.wysiwyg);
      this._editorHeight = context.element.wysiwygFrame.offsetHeight;
      this._editorHeightPadding = util.getNumber(this.wwComputedStyle.getPropertyValue('padding-top')) + util.getNumber(this.wwComputedStyle.getPropertyValue('padding-bottom'));
      if (!options.iframe && typeof _w.ShadowRoot === 'function') {
        var child = context.element.wysiwygFrame;
        while (child) {
          if (child.shadowRoot) {
            this._shadowRoot = child.shadowRoot;
            break;
          } else if (child instanceof _w.ShadowRoot) {
            this._shadowRoot = child;
            break;
          }
          child = child.parentNode;
        }
        if (this._shadowRoot) this._shadowRootControllerEventTarget = [];
      }

      // set disallow text nodes
      var disallowTextTags = _w.Object.keys(options._textTagsMap);
      var allowTextTags = !options.addTagsWhitelist ? [] : options.addTagsWhitelist.split('|').filter(function (v) {
        return /b|i|ins|s|strike/i.test(v);
      });
      for (var i = 0; i < allowTextTags.length; i++) {
        disallowTextTags.splice(disallowTextTags.indexOf(allowTextTags[i].toLowerCase()), 1);
      }
      this._disallowedTextTagsRegExp = disallowTextTags.length === 0 ? null : new wRegExp('(<\\/?)(' + disallowTextTags.join('|') + ')\\b\\s*([^>^<]+)?\\s*(?=>)', 'gi');

      // set whitelist
      var getRegList = function getRegList(str, str2) {
        return !str ? '^' : str === '*' ? '[a-z-]+' : !str2 ? str : str + '|' + str2;
      };
      // tags
      var defaultAttr = 'contenteditable|colspan|rowspan|target|href|download|rel|src|alt|class|type|controls|origin-size';
      var dataAttr = 'data-format|data-size|data-file-size|data-file-name|data-origin|data-align|data-image-link|data-rotate|data-proportion|data-percentage|data-exp|data-font-size';
      this._allowHTMLComments = options._editorTagsWhitelist.indexOf('//') > -1 || options._editorTagsWhitelist === '*';
      // html check
      this._htmlCheckWhitelistRegExp = new wRegExp('^(' + getRegList(options._editorTagsWhitelist.replace('|//', ''), '') + ')$', 'i');
      this._htmlCheckBlacklistRegExp = new wRegExp('^(' + (options.tagsBlacklist || '^') + ')$', 'i');
      // tags
      this.editorTagsWhitelistRegExp = util.createTagsWhitelist(getRegList(options._editorTagsWhitelist.replace('|//', '|<!--|-->'), ''));
      this.editorTagsBlacklistRegExp = util.createTagsBlacklist(options.tagsBlacklist.replace('|//', '|<!--|-->'));
      // paste tags
      this.pasteTagsWhitelistRegExp = util.createTagsWhitelist(getRegList(options.pasteTagsWhitelist, ''));
      this.pasteTagsBlacklistRegExp = util.createTagsBlacklist(options.pasteTagsBlacklist);
      // attributes
      var regEndStr = '\\s*=\\s*(\")[^\"]*\\1';
      var _wAttr = options.attributesWhitelist;
      var tagsAttr = {};
      var allAttr = '';
      if (!!_wAttr) {
        for (var k in _wAttr) {
          if (!util.hasOwn(_wAttr, k) || /^on[a-z]+$/i.test(_wAttr[k])) continue;
          if (k === 'all') {
            allAttr = getRegList(_wAttr[k], defaultAttr);
          } else {
            tagsAttr[k] = new wRegExp('\\s(?:' + getRegList(_wAttr[k], '') + ')' + regEndStr, 'ig');
          }
        }
      }
      this._attributesWhitelistRegExp = new wRegExp('\\s(?:' + (allAttr || defaultAttr + '|' + dataAttr) + ')' + regEndStr, 'ig');
      this._attributesWhitelistRegExp_all_data = new wRegExp('\\s(?:' + ((allAttr || defaultAttr) + '|data-[a-z0-9\\-]+') + ')' + regEndStr, 'ig');
      this._attributesTagsWhitelist = tagsAttr;

      // blacklist
      var _bAttr = options.attributesBlacklist;
      tagsAttr = {};
      allAttr = '';
      if (!!_bAttr) {
        for (var _k in _bAttr) {
          if (!util.hasOwn(_bAttr, _k)) continue;
          if (_k === 'all') {
            allAttr = getRegList(_bAttr[_k], '');
          } else {
            tagsAttr[_k] = new wRegExp('\\s(?:' + getRegList(_bAttr[_k], '') + ')' + regEndStr, 'ig');
          }
        }
      }
      this._attributesBlacklistRegExp = new wRegExp('\\s(?:' + (allAttr || '^') + ')' + regEndStr, 'ig');
      this._attributesTagsBlacklist = tagsAttr;

      // set modes
      this._isInline = /inline/i.test(options.mode);
      this._isBalloon = /balloon|balloon-always/i.test(options.mode);
      this._isBalloonAlways = /balloon-always/i.test(options.mode);

      // caching buttons
      this._cachingButtons();

      // file components
      this._fileInfoPluginsCheck = [];
      this._fileInfoPluginsReset = [];

      // text components
      this.managedTagsInfo = {
        query: '',
        map: {}
      };
      var managedClass = [];

      // Command and file plugins registration
      this.activePlugins = [];
      this._fileManager.tags = [];
      this._fileManager.pluginMap = {};
      var filePluginRegExp = [];
      var plugin, button;
      for (var key in plugins) {
        if (!util.hasOwn(plugins, key)) continue;
        plugin = plugins[key];
        button = pluginCallButtons[key];
        if ((plugin.active || plugin.action) && button) {
          this.callPlugin(key, null, button);
        }
        if (typeof plugin.checkFileInfo === 'function' && typeof plugin.resetFileInfo === 'function') {
          this.callPlugin(key, null, button);
          this._fileInfoPluginsCheck.push(plugin.checkFileInfo.bind(this));
          this._fileInfoPluginsReset.push(plugin.resetFileInfo.bind(this));
        }
        if (_w.Array.isArray(plugin.fileTags)) {
          var fileTags = plugin.fileTags;
          this.callPlugin(key, null, button);
          this._fileManager.tags = this._fileManager.tags.concat(fileTags);
          filePluginRegExp.push(key);
          for (var tag = 0, tLen = fileTags.length; tag < tLen; tag++) {
            this._fileManager.pluginMap[fileTags[tag].toLowerCase()] = key;
          }
        }
        if (plugin.managedTags) {
          var info = plugin.managedTags();
          managedClass.push('.' + info.className);
          this.managedTagsInfo.map[info.className] = info.method.bind(this);
        }
      }
      this.managedTagsInfo.query = managedClass.toString();
      this._fileManager.queryString = this._fileManager.tags.join(',');
      this._fileManager.regExp = new wRegExp('^(' + (this._fileManager.tags.join('|') || '^') + ')$', 'i');
      this._fileManager.pluginRegExp = new wRegExp('^(' + (filePluginRegExp.length === 0 ? '^' : filePluginRegExp.join('|')) + ')$', 'i');

      // cache editor's element
      this._variable._originCssText = context.element.topArea.style.cssText;
      this._placeholder = context.element.placeholder;
      this._lineBreaker = context.element.lineBreaker;
      this._lineBreakerButton = this._lineBreaker.querySelector('button');

      // Excute history function
      this.history = lib_history(this, this._onChange_historyStack.bind(this));

      // register notice module
      this.addModule([_notice]);

      // Init, validate
      if (options.iframe) {
        this._wd = context.element.wysiwygFrame.contentDocument;
        context.element.wysiwyg = this._wd.body;
        if (options._editorStyles.editor) context.element.wysiwyg.style.cssText = options._editorStyles.editor;
        if (options.height === 'auto') this._iframeAuto = this._wd.body;
      }
      this._initWysiwygArea(reload, _initHTML);
    },
    /**
     * @description Caching basic buttons to use
     * @private
     */
    _cachingButtons: function _cachingButtons() {
      this.codeViewDisabledButtons = context.element._buttonTray.querySelectorAll('.se-menu-list button[data-display]:not([class~="se-code-view-enabled"]):not([data-display="MORE"])');
      this.resizingDisabledButtons = context.element._buttonTray.querySelectorAll('.se-menu-list button[data-display]:not([class~="se-resizing-enabled"]):not([data-display="MORE"])');
      this._saveButtonStates();
      var tool = context.tool;
      this.commandMap = {
        OUTDENT: tool.outdent,
        INDENT: tool.indent
      };
      this.commandMap[options.textTags.bold.toUpperCase()] = tool.bold;
      this.commandMap[options.textTags.underline.toUpperCase()] = tool.underline;
      this.commandMap[options.textTags.italic.toUpperCase()] = tool.italic;
      this.commandMap[options.textTags.strike.toUpperCase()] = tool.strike;
      this.commandMap[options.textTags.sub.toUpperCase()] = tool.subscript;
      this.commandMap[options.textTags.sup.toUpperCase()] = tool.superscript;
      this._styleCommandMap = {
        fullScreen: tool.fullScreen,
        showBlocks: tool.showBlocks,
        codeView: tool.codeView
      };
    },
    /**
     * @description Initializ wysiwyg area (Only called from core._init)
     * @param {Boolean} reload Is relooad?
     * @param {String} _initHTML initial html string
     * @private
     */
    _initWysiwygArea: function _initWysiwygArea(reload, _initHTML) {
      context.element.wysiwyg.innerHTML = reload ? _initHTML : this.convertContentsForEditor(typeof _initHTML === 'string' ? _initHTML : context.element.originElement.value);
    },
    /**
     * @description Called when there are changes to tags in the wysiwyg region.
     * @private
     */
    _resourcesStateChange: function _resourcesStateChange() {
      this._iframeAutoHeight();
      this._checkPlaceholder();
    },
    /**
     * @description Called when after execute "history.push"
     * @private
     */
    _onChange_historyStack: function _onChange_historyStack() {
      if (this.hasFocus) event._applyTagEffects();
      this._variable.isChanged = true;
      if (context.tool.save) context.tool.save.removeAttribute('disabled');
      // user event
      if (functions.onChange) functions.onChange(this.getContents(true), this);
      if (context.element.toolbar.style.display === 'block') event._showToolbarBalloon();
    },
    /**
     * @description Modify the height value of the iframe when the height of the iframe is automatic.
     * @private
     */
    _iframeAutoHeight: function _iframeAutoHeight() {
      if (this._iframeAuto) {
        _w.setTimeout(function () {
          var h = core._iframeAuto.offsetHeight;
          context.element.wysiwygFrame.style.height = h + 'px';
          if (util.isIE) core.__callResizeFunction(h, null);
        });
      } else if (util.isIE) {
        core.__callResizeFunction(context.element.wysiwygFrame.offsetHeight, null);
      }
    },
    __callResizeFunction: function __callResizeFunction(h, resizeObserverEntry) {
      h = h === -1 ? resizeObserverEntry.borderBoxSize && resizeObserverEntry.borderBoxSize[0] ? resizeObserverEntry.borderBoxSize[0].blockSize : resizeObserverEntry.contentRect.height + this._editorHeightPadding : h;
      if (this._editorHeight !== h) {
        if (typeof functions.onResizeEditor === 'function') functions.onResizeEditor(h, this._editorHeight, core, resizeObserverEntry);
        this._editorHeight = h;
      }
    },
    /**
     * @description Set display property when there is placeholder.
     * @private
     */
    _checkPlaceholder: function _checkPlaceholder() {
      if (this._placeholder) {
        if (this._variable.isCodeView) {
          this._placeholder.style.display = 'none';
          return;
        }
        var wysiwyg = context.element.wysiwyg;
        if (!util.onlyZeroWidthSpace(wysiwyg.textContent) || wysiwyg.querySelector(util._allowedEmptyNodeList) || (wysiwyg.innerText.match(/\n/g) || '').length > 1) {
          this._placeholder.style.display = 'none';
        } else {
          this._placeholder.style.display = 'block';
        }
      }
    },
    /**
     * @description If there is no default format, add a format and move "selection".
     * @param {String|null} formatName Format tag name (default: 'P')
     * @returns {undefined|null}
     * @private
     */
    _setDefaultFormat: function _setDefaultFormat(formatName) {
      if (this._fileManager.pluginRegExp.test(this.currentControllerName)) return;
      var range = this.getRange();
      var commonCon = range.commonAncestorContainer;
      var startCon = range.startContainer;
      var rangeEl = util.getRangeFormatElement(commonCon, null);
      var focusNode, offset, format;
      var fileComponent = util.getParentElement(commonCon, util.isComponent);
      if (fileComponent && !util.isTable(fileComponent)) {
        return;
      } else if (commonCon.nodeType === 1 && commonCon.getAttribute('data-se-embed') === 'true') {
        var el = commonCon.nextElementSibling;
        if (!util.isFormatElement(el)) el = this.appendFormatTag(commonCon, options.defaultTag);
        this.setRange(el.firstChild, 0, el.firstChild, 0);
        return;
      }
      if ((util.isRangeFormatElement(startCon) || util.isWysiwygDiv(startCon)) && (util.isComponent(startCon.children[range.startOffset]) || util.isComponent(startCon.children[range.startOffset - 1]))) return;
      if (util.getParentElement(commonCon, util.isNotCheckingNode)) return null;
      if (rangeEl) {
        format = util.createElement(formatName || options.defaultTag);
        format.innerHTML = rangeEl.innerHTML;
        if (format.childNodes.length === 0) format.innerHTML = util.zeroWidthSpace;
        rangeEl.innerHTML = format.outerHTML;
        format = rangeEl.firstChild;
        focusNode = util.getEdgeChildNodes(format, null).sc;
        if (!focusNode) {
          focusNode = util.createTextNode(util.zeroWidthSpace);
          format.insertBefore(focusNode, format.firstChild);
        }
        offset = focusNode.textContent.length;
        this.setRange(focusNode, offset, focusNode, offset);
        return;
      }
      if (util.isRangeFormatElement(commonCon) && commonCon.childNodes.length <= 1) {
        var br = null;
        if (commonCon.childNodes.length === 1 && util.isBreak(commonCon.firstChild)) {
          br = commonCon.firstChild;
        } else {
          br = util.createTextNode(util.zeroWidthSpace);
          commonCon.appendChild(br);
        }
        this.setRange(br, 1, br, 1);
        return;
      }
      this.execCommand('formatBlock', false, formatName || options.defaultTag);
      focusNode = util.getEdgeChildNodes(commonCon, commonCon);
      focusNode = focusNode ? focusNode.ec : commonCon;
      format = util.getFormatElement(focusNode, null);
      if (!format) {
        this.removeRange();
        this._editorRange();
        return;
      }
      if (util.isBreak(format.nextSibling)) util.removeItem(format.nextSibling);
      if (util.isBreak(format.previousSibling)) util.removeItem(format.previousSibling);
      if (util.isBreak(focusNode)) {
        var zeroWidth = util.createTextNode(util.zeroWidthSpace);
        focusNode.parentNode.insertBefore(zeroWidth, focusNode);
        focusNode = zeroWidth;
      }
      this.effectNode = null;
      this.nativeFocus();
    },
    /**
     * @description Initialization after "setOptions"
     * @param {Object} el context.element
     * @param {String} _initHTML Initial html string
     * @private
     */
    _setOptionsInit: function _setOptionsInit(el, _initHTML) {
      this.context = context = lib_context(el.originElement, this._getConstructed(el), options);
      this._componentsInfoReset = true;
      this._editorInit(true, _initHTML);
    },
    /**
     * @description Initializ editor
     * @param {Boolean} reload Is relooad?
     * @param {String} _initHTML initial html string
     * @private
     */
    _editorInit: function _editorInit(reload, _initHTML) {
      // initialize core and add event listeners
      this._init(reload, _initHTML);
      event._addEvent();
      this._setCharCount();
      event._offStickyToolbar();
      event.onResize_window();

      // toolbar visibility
      context.element.toolbar.style.visibility = '';
      // wisywig attributes
      var attr = options.frameAttrbutes;
      for (var k in attr) {
        context.element.wysiwyg.setAttribute(k, attr[k]);
      }
      this._checkComponents();
      this._componentsInfoInit = false;
      this._componentsInfoReset = false;
      this.history.reset(true);
      _w.setTimeout(function () {
        // observer
        if (event._resizeObserver) event._resizeObserver.observe(context.element.wysiwygFrame);
        if (event._toolbarObserver) event._toolbarObserver.observe(context.element._toolbarShadow);
        // resource state
        core._resourcesStateChange();
        // user event
        if (typeof functions.onload === 'function') functions.onload(core, reload);
      });
    },
    /**
     * @description Create and return an object to cache the new context.
     * @param {Element} contextEl context.element
     * @returns {Object}
     * @private
     */
    _getConstructed: function _getConstructed(contextEl) {
      return {
        _top: contextEl.topArea,
        _relative: contextEl.relative,
        _toolBar: contextEl.toolbar,
        _toolbarShadow: contextEl._toolbarShadow,
        _menuTray: contextEl._menuTray,
        _editorArea: contextEl.editorArea,
        _wysiwygArea: contextEl.wysiwygFrame,
        _codeArea: contextEl.code,
        _placeholder: contextEl.placeholder,
        _resizingBar: contextEl.resizingBar,
        _navigation: contextEl.navigation,
        _charCounter: contextEl.charCounter,
        _charWrapper: contextEl.charWrapper,
        _loading: contextEl.loading,
        _lineBreaker: contextEl.lineBreaker,
        _lineBreaker_t: contextEl.lineBreaker_t,
        _lineBreaker_b: contextEl.lineBreaker_b,
        _resizeBack: contextEl.resizeBackground,
        _stickyDummy: contextEl._stickyDummy,
        _arrow: contextEl._arrow
      };
    }
  };

  /**
   * @description event function
   */
  var event = {
    _IEisComposing: false,
    // In IE, there is no "e.isComposing" in the key-up event.
    _lineBreakerBind: null,
    _responsiveCurrentSize: 'default',
    _responsiveButtonSize: null,
    _responsiveButtons: null,
    _directionKeyCode: new _w.RegExp('^(8|13|3[2-9]|40|46)$'),
    _nonTextKeyCode: new _w.RegExp('^(8|13|1[6-9]|20|27|3[3-9]|40|45|46|11[2-9]|12[0-3]|144|145)$'),
    _historyIgnoreKeyCode: new _w.RegExp('^(1[6-9]|20|27|3[3-9]|40|45|11[2-9]|12[0-3]|144|145)$'),
    _onButtonsCheck: new _w.RegExp('^(' + _w.Object.keys(options._textTagsMap).join('|') + ')$', 'i'),
    _frontZeroWidthReg: new _w.RegExp(util.zeroWidthSpace + '+', ''),
    _keyCodeShortcut: {
      65: 'A',
      66: 'B',
      83: 'S',
      85: 'U',
      73: 'I',
      89: 'Y',
      90: 'Z',
      219: '[',
      221: ']'
    },
    _shortcutCommand: function _shortcutCommand(keyCode, shift) {
      var command = null;
      var keyStr = event._keyCodeShortcut[keyCode];
      switch (keyStr) {
        case 'A':
          command = 'selectAll';
          break;
        case 'B':
          if (options.shortcutsDisable.indexOf('bold') === -1) {
            command = 'bold';
          }
          break;
        case 'S':
          if (shift && options.shortcutsDisable.indexOf('strike') === -1) {
            command = 'strike';
          } else if (!shift && options.shortcutsDisable.indexOf('save') === -1) {
            command = 'save';
          }
          break;
        case 'U':
          if (options.shortcutsDisable.indexOf('underline') === -1) {
            command = 'underline';
          }
          break;
        case 'I':
          if (options.shortcutsDisable.indexOf('italic') === -1) {
            command = 'italic';
          }
          break;
        case 'Z':
          if (options.shortcutsDisable.indexOf('undo') === -1) {
            if (shift) {
              command = 'redo';
            } else {
              command = 'undo';
            }
          }
          break;
        case 'Y':
          if (options.shortcutsDisable.indexOf('undo') === -1) {
            command = 'redo';
          }
          break;
        case '[':
          if (options.shortcutsDisable.indexOf('indent') === -1) {
            command = options.rtl ? 'indent' : 'outdent';
          }
          break;
        case ']':
          if (options.shortcutsDisable.indexOf('indent') === -1) {
            command = options.rtl ? 'outdent' : 'indent';
          }
          break;
      }
      if (!command) return !!keyStr;
      core.commandHandler(core.commandMap[command], command);
      return true;
    },
    _applyTagEffects: function _applyTagEffects() {
      var selectionNode = core.getSelectionNode();
      if (selectionNode === core.effectNode) return;
      core.effectNode = selectionNode;
      var marginDir = options.rtl ? 'marginRight' : 'marginLeft';
      var commandMap = core.commandMap;
      var classOnCheck = event._onButtonsCheck;
      var commandMapNodes = [];
      var currentNodes = [];
      var activePlugins = core.activePlugins;
      var cLen = activePlugins.length;
      var nodeName = '';
      while (selectionNode.firstChild) {
        selectionNode = selectionNode.firstChild;
      }
      for (var element = selectionNode; !util.isWysiwygDiv(element); element = element.parentNode) {
        if (!element) break;
        if (element.nodeType !== 1 || util.isBreak(element)) continue;
        nodeName = element.nodeName.toUpperCase();
        currentNodes.push(nodeName);

        /* Active plugins */
        if (!core.isReadOnly) {
          for (var c = 0, name; c < cLen; c++) {
            name = activePlugins[c];
            if (commandMapNodes.indexOf(name) === -1 && plugins[name].active.call(core, element)) {
              commandMapNodes.push(name);
            }
          }
        }
        if (util.isFormatElement(element)) {
          /* Outdent */
          if (commandMapNodes.indexOf('OUTDENT') === -1 && commandMap.OUTDENT && !util.isImportantDisabled(commandMap.OUTDENT)) {
            if (util.isListCell(element) || element.style[marginDir] && util.getNumber(element.style[marginDir], 0) > 0) {
              commandMapNodes.push('OUTDENT');
              commandMap.OUTDENT.removeAttribute('disabled');
            }
          }

          /* Indent */
          if (commandMapNodes.indexOf('INDENT') === -1 && commandMap.INDENT && !util.isImportantDisabled(commandMap.INDENT)) {
            commandMapNodes.push('INDENT');
            if (util.isListCell(element) && !element.previousElementSibling) {
              commandMap.INDENT.setAttribute('disabled', true);
            } else {
              commandMap.INDENT.removeAttribute('disabled');
            }
          }
          continue;
        }

        /** default active buttons [strong, ins, em, del, sub, sup] */
        if (classOnCheck && classOnCheck.test(nodeName)) {
          commandMapNodes.push(nodeName);
          util.addClass(commandMap[nodeName], 'active');
        }
      }
      core._setKeyEffect(commandMapNodes);

      /** save current nodes */
      core._variable.currentNodes = currentNodes.reverse();
      core._variable.currentNodesMap = commandMapNodes;

      /**  Displays the current node structure to resizingBar */
      if (options.showPathLabel) context.element.navigation.textContent = core._variable.currentNodes.join(' > ');
    },
    _cancelCaptionEdit: function _cancelCaptionEdit() {
      this.setAttribute('contenteditable', false);
      this.removeEventListener('blur', event._cancelCaptionEdit);
    },
    _buttonsEventHandler: function _buttonsEventHandler(e) {
      var target = e.target;
      if (core._bindControllersOff) e.stopPropagation();
      if (/^(input|textarea|select|option)$/i.test(target.nodeName)) {
        core._antiBlur = false;
      } else {
        e.preventDefault();
      }
      if (util.getParentElement(target, '.se-submenu')) {
        e.stopPropagation();
        core._notHideToolbar = true;
      } else {
        var command = target.getAttribute('data-command');
        var className = target.className;
        while (!command && !/se-menu-list/.test(className) && !/sun-editor-common/.test(className)) {
          target = target.parentNode;
          command = target.getAttribute('data-command');
          className = target.className;
        }
        if (command === core._submenuName || command === core._containerName) {
          e.stopPropagation();
        }
      }
    },
    onClick_toolbar: function onClick_toolbar(e) {
      var target = e.target;
      var display = target.getAttribute('data-display');
      var command = target.getAttribute('data-command');
      var className = target.className;
      core.controllersOff();
      while (target.parentNode && !command && !/se-menu-list/.test(className) && !/se-toolbar/.test(className)) {
        target = target.parentNode;
        command = target.getAttribute('data-command');
        display = target.getAttribute('data-display');
        className = target.className;
      }
      if (!command && !display) return;
      if (target.disabled) return;
      core.actionCall(command, display, target);
    },
    onMouseDown_wysiwyg: function onMouseDown_wysiwyg(e) {
      if (core.isReadOnly || util.isNonEditable(context.element.wysiwyg)) return;

      // user event
      if (typeof functions.onMouseDown === 'function' && functions.onMouseDown(e, core) === false) return;
      var tableCell = util.getParentElement(e.target, util.isCell);
      if (tableCell) {
        var tablePlugin = core.plugins.table;
        if (tablePlugin && tableCell !== tablePlugin._fixedCell && !tablePlugin._shift) {
          core.callPlugin('table', function () {
            tablePlugin.onTableCellMultiSelect.call(core, tableCell, false);
          }, null);
        }
      }
      if (core._isBalloon) {
        event._hideToolbar();
      }
      if (/FIGURE/i.test(e.target.nodeName)) e.preventDefault();
    },
    onClick_wysiwyg: function onClick_wysiwyg(e) {
      var targetElement = e.target;
      if (core.isReadOnly) {
        e.preventDefault();
        if (util.isAnchor(targetElement)) {
          _w.open(targetElement.href, targetElement.target);
        }
        return false;
      }
      if (util.isNonEditable(context.element.wysiwyg)) return;

      // user event
      if (typeof functions.onClick === 'function' && functions.onClick(e, core) === false) return;
      var fileComponentInfo = core.getFileComponent(targetElement);
      if (fileComponentInfo) {
        e.preventDefault();
        core.selectComponent(fileComponentInfo.target, fileComponentInfo.pluginName);
        return;
      }
      var figcaption = util.getParentElement(targetElement, 'FIGCAPTION');
      if (figcaption && (util.isNonEditable(figcaption) || !figcaption.getAttribute("contenteditable"))) {
        e.preventDefault();
        figcaption.setAttribute('contenteditable', true);
        figcaption.focus();
        if (core._isInline && !core._inlineToolbarAttr.isShow) {
          event._showToolbarInline();
          var hideToolbar = function hideToolbar() {
            event._hideToolbar();
            figcaption.removeEventListener('blur', hideToolbar);
          };
          figcaption.addEventListener('blur', hideToolbar);
        }
      }
      _w.setTimeout(core._editorRange.bind(core));
      core._editorRange();
      var selectionNode = core.getSelectionNode();
      var formatEl = util.getFormatElement(selectionNode, null);
      var rangeEl = util.getRangeFormatElement(selectionNode, null);
      if (!formatEl && !util.isNonEditable(targetElement) && !util.isList(rangeEl)) {
        var range = core.getRange();
        if (util.getFormatElement(range.startContainer) === util.getFormatElement(range.endContainer)) {
          if (util.isList(rangeEl)) {
            e.preventDefault();
            var oLi = util.createElement('LI');
            var prevLi = selectionNode.nextElementSibling;
            oLi.appendChild(selectionNode);
            rangeEl.insertBefore(oLi, prevLi);
            core.focus();
          } else if (!util.isWysiwygDiv(selectionNode) && !util.isComponent(selectionNode) && (!util.isTable(selectionNode) || util.isCell(selectionNode)) && core._setDefaultFormat(util.isRangeFormatElement(rangeEl) ? 'DIV' : options.defaultTag) !== null) {
            e.preventDefault();
            core.focus();
          } else {
            event._applyTagEffects();
          }
        }
      } else {
        event._applyTagEffects();
      }
      if (core._isBalloon) _w.setTimeout(event._toggleToolbarBalloon);
    },
    _balloonDelay: null,
    _showToolbarBalloonDelay: function _showToolbarBalloonDelay() {
      if (event._balloonDelay) {
        _w.clearTimeout(event._balloonDelay);
      }
      event._balloonDelay = _w.setTimeout(function () {
        _w.clearTimeout(this._balloonDelay);
        this._balloonDelay = null;
        this._showToolbarBalloon();
      }.bind(event), 350);
    },
    _toggleToolbarBalloon: function _toggleToolbarBalloon() {
      core._editorRange();
      var range = core.getRange();
      if (core._bindControllersOff || !core._isBalloonAlways && range.collapsed) event._hideToolbar();else event._showToolbarBalloon(range);
    },
    _showToolbarBalloon: function _showToolbarBalloon(rangeObj) {
      if (!core._isBalloon) return;
      var range = rangeObj || core.getRange();
      var toolbar = context.element.toolbar;
      var topArea = context.element.topArea;
      var selection = core.getSelection();
      var isDirTop;
      if (core._isBalloonAlways && range.collapsed) {
        isDirTop = true;
      } else if (selection.focusNode === selection.anchorNode) {
        isDirTop = selection.focusOffset < selection.anchorOffset;
      } else {
        var childNodes = util.getListChildNodes(range.commonAncestorContainer, null);
        isDirTop = util.getArrayIndex(childNodes, selection.focusNode) < util.getArrayIndex(childNodes, selection.anchorNode);
      }
      var rects = range.getClientRects();
      rects = rects[isDirTop ? 0 : rects.length - 1];
      var globalScroll = core.getGlobalScrollOffset();
      var scrollLeft = globalScroll.left;
      var scrollTop = globalScroll.top;
      var editorWidth = topArea.offsetWidth;
      var offsets = event._getEditorOffsets(null);
      var stickyTop = offsets.top;
      var editorLeft = offsets.left;
      toolbar.style.top = '-10000px';
      toolbar.style.visibility = 'hidden';
      toolbar.style.display = 'block';
      if (!rects) {
        var node = core.getSelectionNode();
        if (util.isFormatElement(node)) {
          var zeroWidth = util.createTextNode(util.zeroWidthSpace);
          core.insertNode(zeroWidth, null, false);
          core.setRange(zeroWidth, 1, zeroWidth, 1);
          core._editorRange();
          rects = core.getRange().getClientRects();
          rects = rects[isDirTop ? 0 : rects.length - 1];
        }
        if (!rects) {
          var nodeOffset = util.getOffset(node, context.element.wysiwygFrame);
          rects = {
            left: nodeOffset.left,
            top: nodeOffset.top,
            right: nodeOffset.left,
            bottom: nodeOffset.top + node.offsetHeight,
            noText: true
          };
          scrollLeft = 0;
          scrollTop = 0;
        }
        isDirTop = true;
      }
      var arrowMargin = _w.Math.round(context.element._arrow.offsetWidth / 2);
      var toolbarWidth = toolbar.offsetWidth;
      var toolbarHeight = toolbar.offsetHeight;
      var iframeRects = /iframe/i.test(context.element.wysiwygFrame.nodeName) ? context.element.wysiwygFrame.getClientRects()[0] : null;
      if (iframeRects) {
        rects = {
          left: rects.left + iframeRects.left,
          top: rects.top + iframeRects.top,
          right: rects.right + iframeRects.right - iframeRects.width,
          bottom: rects.bottom + iframeRects.bottom - iframeRects.height
        };
      }
      event._setToolbarOffset(isDirTop, rects, toolbar, editorLeft, editorWidth, scrollLeft, scrollTop, stickyTop, arrowMargin);
      if (toolbarWidth !== toolbar.offsetWidth || toolbarHeight !== toolbar.offsetHeight) {
        event._setToolbarOffset(isDirTop, rects, toolbar, editorLeft, editorWidth, scrollLeft, scrollTop, stickyTop, arrowMargin);
      }
      if (options.toolbarContainer) {
        var editorParent = topArea.parentElement;
        var container = options.toolbarContainer;
        var left = container.offsetLeft;
        var top = container.offsetTop;
        while (!container.parentElement.contains(editorParent) || !/^(BODY|HTML)$/i.test(container.parentElement.nodeName)) {
          container = container.offsetParent;
          left += container.offsetLeft;
          top += container.offsetTop;
        }
        toolbar.style.left = toolbar.offsetLeft - left + topArea.offsetLeft + 'px';
        toolbar.style.top = toolbar.offsetTop - top + topArea.offsetTop + 'px';
      }
      toolbar.style.visibility = '';
    },
    _setToolbarOffset: function _setToolbarOffset(isDirTop, rects, toolbar, editorLeft, editorWidth, scrollLeft, scrollTop, stickyTop, arrowMargin) {
      var padding = 1;
      var toolbarWidth = toolbar.offsetWidth;
      var toolbarHeight = rects.noText && !isDirTop ? 0 : toolbar.offsetHeight;
      var absoluteLeft = (isDirTop ? rects.left : rects.right) - editorLeft - toolbarWidth / 2 + scrollLeft;
      var overRight = absoluteLeft + toolbarWidth - editorWidth;
      var t = (isDirTop ? rects.top - toolbarHeight - arrowMargin : rects.bottom + arrowMargin) - (rects.noText ? 0 : stickyTop) + scrollTop;
      var l = absoluteLeft < 0 ? padding : overRight < 0 ? absoluteLeft : absoluteLeft - overRight - padding - 1;
      var resetTop = false;
      var space = t + (isDirTop ? event._getEditorOffsets(null).top : toolbar.offsetHeight - context.element.wysiwyg.offsetHeight);
      if (!isDirTop && space > 0 && event._getPageBottomSpace() < space) {
        isDirTop = true;
        resetTop = true;
      } else if (isDirTop && _d.documentElement.offsetTop > space) {
        isDirTop = false;
        resetTop = true;
      }
      if (resetTop) t = (isDirTop ? rects.top - toolbarHeight - arrowMargin : rects.bottom + arrowMargin) - (rects.noText ? 0 : stickyTop) + scrollTop;
      toolbar.style.left = _w.Math.floor(l) + 'px';
      toolbar.style.top = _w.Math.floor(t) + 'px';
      if (isDirTop) {
        util.removeClass(context.element._arrow, 'se-arrow-up');
        util.addClass(context.element._arrow, 'se-arrow-down');
        context.element._arrow.style.top = toolbarHeight + 'px';
      } else {
        util.removeClass(context.element._arrow, 'se-arrow-down');
        util.addClass(context.element._arrow, 'se-arrow-up');
        context.element._arrow.style.top = -arrowMargin + 'px';
      }
      var arrow_left = _w.Math.floor(toolbarWidth / 2 + (absoluteLeft - l));
      context.element._arrow.style.left = (arrow_left + arrowMargin > toolbar.offsetWidth ? toolbar.offsetWidth - arrowMargin : arrow_left < arrowMargin ? arrowMargin : arrow_left) + 'px';
    },
    _showToolbarInline: function _showToolbarInline() {
      if (!core._isInline) return;
      var toolbar = context.element.toolbar;
      if (options.toolbarContainer) toolbar.style.position = 'relative';else toolbar.style.position = 'absolute';
      toolbar.style.visibility = 'hidden';
      toolbar.style.display = 'block';
      core._inlineToolbarAttr.width = toolbar.style.width = options.toolbarWidth;
      core._inlineToolbarAttr.top = toolbar.style.top = (options.toolbarContainer ? 0 : -1 - toolbar.offsetHeight) + 'px';
      if (typeof functions.showInline === 'function') functions.showInline(toolbar, context, core);
      event.onScroll_window();
      core._inlineToolbarAttr.isShow = true;
      toolbar.style.visibility = '';
    },
    _hideToolbar: function _hideToolbar() {
      if (!core._notHideToolbar && !core._variable.isFullScreen) {
        context.element.toolbar.style.display = 'none';
        core._inlineToolbarAttr.isShow = false;
      }
    },
    onInput_wysiwyg: function onInput_wysiwyg(e) {
      if (core.isReadOnly || core.isDisabled) {
        e.preventDefault();
        e.stopPropagation();
        core.history.go(core.history.getCurrentIndex());
        return false;
      }
      core._editorRange();
      var data = (e.data === null ? '' : e.data === undefined ? ' ' : e.data) || '';
      if (!core._charCount(data)) {
        e.preventDefault();
        e.stopPropagation();
        return false;
      }

      // user event
      if (typeof functions.onInput === 'function' && functions.onInput(e, core) === false) return;

      // history stack
      core.history.push(true);
    },
    _isUneditableNode: function _isUneditableNode(range, isFront) {
      var container = isFront ? range.startContainer : range.endContainer;
      var offset = isFront ? range.startOffset : range.endOffset;
      var siblingKey = isFront ? 'previousSibling' : 'nextSibling';
      var isElement = container.nodeType === 1;
      var siblingNode;
      if (isElement) {
        siblingNode = event._isUneditableNode_getSibling(container.childNodes[offset], siblingKey, container);
        return siblingNode && siblingNode.nodeType === 1 && siblingNode.getAttribute('contenteditable') === 'false';
      } else {
        siblingNode = event._isUneditableNode_getSibling(container, siblingKey, container);
        return core.isEdgePoint(container, offset, isFront ? 'front' : 'end') && siblingNode && siblingNode.nodeType === 1 && siblingNode.getAttribute('contenteditable') === 'false';
      }
    },
    _isUneditableNode_getSibling: function _isUneditableNode_getSibling(selectNode, siblingKey, container) {
      if (!selectNode) return null;
      var siblingNode = selectNode[siblingKey];
      if (!siblingNode) {
        siblingNode = util.getFormatElement(container);
        siblingNode = siblingNode ? siblingNode[siblingKey] : null;
        if (siblingNode && !util.isComponent(siblingNode)) siblingNode = siblingKey === 'previousSibling' ? siblingNode.firstElementChild : siblingNode.lastElementChild;else return null;
      }
      return siblingNode;
    },
    _onShortcutKey: false,
    onKeyDown_wysiwyg: function onKeyDown_wysiwyg(e) {
      var keyCode = e.keyCode;
      var shift = e.shiftKey;
      var ctrl = e.ctrlKey || e.metaKey || keyCode === 91 || keyCode === 92 || keyCode === 224;
      var alt = e.altKey;
      event._IEisComposing = keyCode === 229;
      if (!ctrl && core.isReadOnly && !event._directionKeyCode.test(keyCode)) {
        e.preventDefault();
        return false;
      }
      core.submenuOff();
      if (core._isBalloon) {
        event._hideToolbar();
      }

      // user event
      if (typeof functions.onKeyDown === 'function' && functions.onKeyDown(e, core) === false) return;

      /** Shortcuts */
      if (ctrl && event._shortcutCommand(keyCode, shift)) {
        event._onShortcutKey = true;
        e.preventDefault();
        e.stopPropagation();
        return false;
      } else if (event._onShortcutKey) {
        event._onShortcutKey = false;
      }

      /** default key action */
      var selectionNode = core.getSelectionNode();
      var range = core.getRange();
      var selectRange = !range.collapsed || range.startContainer !== range.endContainer;
      var fileComponentName = core._fileManager.pluginRegExp.test(core.currentControllerName) ? core.currentControllerName : '';
      var formatEl = util.getFormatElement(selectionNode, null) || selectionNode;
      var rangeEl = util.getRangeFormatElement(formatEl, null);
      switch (keyCode) {
        case 8:
          /** backspace key */
          if (!selectRange) {
            if (fileComponentName) {
              e.preventDefault();
              e.stopPropagation();
              core.plugins[fileComponentName].destroy.call(core);
              break;
            }
          }
          if (selectRange && event._hardDelete()) {
            e.preventDefault();
            e.stopPropagation();
            break;
          }
          if (!util.isFormatElement(formatEl) && !context.element.wysiwyg.firstElementChild && !util.isComponent(selectionNode) && core._setDefaultFormat(options.defaultTag) !== null) {
            e.preventDefault();
            e.stopPropagation();
            return false;
          }
          if (!selectRange && !formatEl.previousElementSibling && range.startOffset === 0 && !selectionNode.previousSibling && !util.isListCell(formatEl) && util.isFormatElement(formatEl) && (!util.isFreeFormatElement(formatEl) || util.isClosureFreeFormatElement(formatEl))) {
            // closure range
            if (util.isClosureRangeFormatElement(formatEl.parentNode)) {
              e.preventDefault();
              e.stopPropagation();
              return false;
            }
            // maintain default format
            if (util.isWysiwygDiv(formatEl.parentNode) && formatEl.childNodes.length <= 1 && (!formatEl.firstChild || util.onlyZeroWidthSpace(formatEl.textContent))) {
              e.preventDefault();
              e.stopPropagation();
              if (formatEl.nodeName.toUpperCase() === options.defaultTag.toUpperCase()) {
                formatEl.innerHTML = '<br>';
                var attrs = formatEl.attributes;
                while (attrs[0]) {
                  formatEl.removeAttribute(attrs[0].name);
                }
              } else {
                var defaultFormat = util.createElement(options.defaultTag);
                defaultFormat.innerHTML = '<br>';
                formatEl.parentElement.replaceChild(defaultFormat, formatEl);
              }
              core.nativeFocus();
              return false;
            }
          }

          // clean remove tag
          if (formatEl && range.startContainer === range.endContainer && selectionNode.nodeType === 3 && !util.isFormatElement(selectionNode.parentNode)) {
            if (range.collapsed ? selectionNode.textContent.length === 1 : range.endOffset - range.startOffset === selectionNode.textContent.length) {
              e.preventDefault();
              var offset = null;
              var prev = selectionNode.parentNode.previousSibling;
              var next = selectionNode.parentNode.nextSibling;
              if (!prev) {
                if (!next) {
                  prev = util.createElement('BR');
                  formatEl.appendChild(prev);
                } else {
                  prev = next;
                  offset = 0;
                }
              }
              selectionNode.textContent = '';
              util.removeItemAllParents(selectionNode, null, formatEl);
              offset = typeof offset === 'number' ? offset : prev.nodeType === 3 ? prev.textContent.length : 1;
              core.setRange(prev, offset, prev, offset);
              break;
            }
          }

          // tag[contenteditable="false"]
          if (event._isUneditableNode(range, true)) {
            e.preventDefault();
            e.stopPropagation();
            break;
          }

          // nested list
          var commonCon = range.commonAncestorContainer;
          formatEl = util.getFormatElement(range.startContainer, null);
          rangeEl = util.getRangeFormatElement(formatEl, null);
          if (rangeEl && formatEl && !util.isCell(rangeEl) && !/^FIGCAPTION$/i.test(rangeEl.nodeName)) {
            if (util.isListCell(formatEl) && util.isList(rangeEl) && (util.isListCell(rangeEl.parentNode) || formatEl.previousElementSibling) && (selectionNode === formatEl || selectionNode.nodeType === 3 && (!selectionNode.previousSibling || util.isList(selectionNode.previousSibling))) && (util.getFormatElement(range.startContainer, null) !== util.getFormatElement(range.endContainer, null) ? rangeEl.contains(range.startContainer) : range.startOffset === 0 && range.collapsed)) {
              if (range.startContainer !== range.endContainer) {
                e.preventDefault();
                core.removeNode();
                if (range.startContainer.nodeType === 3) {
                  core.setRange(range.startContainer, range.startContainer.textContent.length, range.startContainer, range.startContainer.textContent.length);
                }
                // history stack
                core.history.push(true);
              } else {
                var _prev = formatEl.previousElementSibling || rangeEl.parentNode;
                if (util.isListCell(_prev)) {
                  e.preventDefault();
                  var prevLast = _prev;
                  if (!_prev.contains(formatEl) && util.isListCell(prevLast) && util.isList(prevLast.lastElementChild)) {
                    prevLast = prevLast.lastElementChild.lastElementChild;
                    while (util.isListCell(prevLast) && util.isList(prevLast.lastElementChild)) {
                      prevLast = prevLast.lastElementChild && prevLast.lastElementChild.lastElementChild;
                    }
                    _prev = prevLast;
                  }
                  var con = _prev === rangeEl.parentNode ? rangeEl.previousSibling : _prev.lastChild;
                  if (!con) {
                    con = util.createTextNode(util.zeroWidthSpace);
                    rangeEl.parentNode.insertBefore(con, rangeEl.parentNode.firstChild);
                  }
                  var _offset = con.nodeType === 3 ? con.textContent.length : 1;
                  var children = formatEl.childNodes;
                  var after = con;
                  var child = children[0];
                  while (child = children[0]) {
                    _prev.insertBefore(child, after.nextSibling);
                    after = child;
                  }
                  util.removeItem(formatEl);
                  if (rangeEl.children.length === 0) util.removeItem(rangeEl);
                  core.setRange(con, _offset, con, _offset);
                  // history stack
                  core.history.push(true);
                }
              }
              break;
            }

            // detach range
            if (!selectRange && range.startOffset === 0) {
              var detach = true;
              var comm = commonCon;
              while (comm && comm !== rangeEl && !util.isWysiwygDiv(comm)) {
                if (comm.previousSibling) {
                  if (comm.previousSibling.nodeType === 1 || !util.onlyZeroWidthSpace(comm.previousSibling.textContent.trim())) {
                    detach = false;
                    break;
                  }
                }
                comm = comm.parentNode;
              }
              if (detach && rangeEl.parentNode) {
                e.preventDefault();
                core.detachRangeFormatElement(rangeEl, util.isListCell(formatEl) ? [formatEl] : null, null, false, false);
                // history stack
                core.history.push(true);
                break;
              }
            }
          }

          // component
          if (!selectRange && formatEl && (range.startOffset === 0 || (selectionNode === formatEl ? !!formatEl.childNodes[range.startOffset] : false))) {
            var sel = selectionNode === formatEl ? formatEl.childNodes[range.startOffset] : selectionNode;
            var _prev2 = formatEl.previousSibling;
            // select file component
            var ignoreZWS = (commonCon.nodeType === 3 || util.isBreak(commonCon)) && !commonCon.previousSibling && range.startOffset === 0;
            if (!sel.previousSibling && (util.isComponent(commonCon.previousSibling) || ignoreZWS && util.isComponent(_prev2))) {
              var fileComponentInfo = core.getFileComponent(_prev2);
              if (fileComponentInfo) {
                e.preventDefault();
                e.stopPropagation();
                if (formatEl.textContent.length === 0) util.removeItem(formatEl);
                if (core.selectComponent(fileComponentInfo.target, fileComponentInfo.pluginName) === false) core.blur();
              } else if (util.isComponent(_prev2)) {
                e.preventDefault();
                e.stopPropagation();
                util.removeItem(_prev2);
              }
              break;
            }
            // delete nonEditable
            if (util.isNonEditable(sel.previousSibling)) {
              e.preventDefault();
              e.stopPropagation();
              util.removeItem(sel.previousSibling);
              break;
            }
          }
          break;
        case 46:
          /** delete key */
          if (fileComponentName) {
            e.preventDefault();
            e.stopPropagation();
            core.plugins[fileComponentName].destroy.call(core);
            break;
          }
          if (selectRange && event._hardDelete()) {
            e.preventDefault();
            e.stopPropagation();
            break;
          }

          // tag[contenteditable="false"]
          if (event._isUneditableNode(range, false)) {
            e.preventDefault();
            e.stopPropagation();
            break;
          }

          // component
          if ((util.isFormatElement(selectionNode) || selectionNode.nextSibling === null || util.onlyZeroWidthSpace(selectionNode.nextSibling) && selectionNode.nextSibling.nextSibling === null) && range.startOffset === selectionNode.textContent.length) {
            var nextEl = formatEl.nextElementSibling;
            if (!nextEl) break;
            if (util.isComponent(nextEl)) {
              e.preventDefault();
              if (util.onlyZeroWidthSpace(formatEl)) {
                util.removeItem(formatEl);
                // table component
                if (util.isTable(nextEl)) {
                  var cell = util.getChildElement(nextEl, util.isCell, false);
                  cell = cell.firstElementChild || cell;
                  core.setRange(cell, 0, cell, 0);
                  break;
                }
              }

              // select file component
              var _fileComponentInfo = core.getFileComponent(nextEl);
              if (_fileComponentInfo) {
                e.stopPropagation();
                if (core.selectComponent(_fileComponentInfo.target, _fileComponentInfo.pluginName) === false) core.blur();
              } else if (util.isComponent(nextEl)) {
                e.stopPropagation();
                util.removeItem(nextEl);
              }
              break;
            }
          }
          if (!selectRange && (core.isEdgePoint(range.endContainer, range.endOffset) || (selectionNode === formatEl ? !!formatEl.childNodes[range.startOffset] : false))) {
            var _sel = selectionNode === formatEl ? formatEl.childNodes[range.startOffset] || selectionNode : selectionNode;
            // delete nonEditable
            if (_sel && util.isNonEditable(_sel.nextSibling)) {
              e.preventDefault();
              e.stopPropagation();
              util.removeItem(_sel.nextSibling);
              break;
            } else if (util.isComponent(_sel)) {
              e.preventDefault();
              e.stopPropagation();
              util.removeItem(_sel);
              break;
            }
          }

          // nested list
          formatEl = util.getFormatElement(range.startContainer, null);
          rangeEl = util.getRangeFormatElement(formatEl, null);
          if (util.isListCell(formatEl) && util.isList(rangeEl) && (selectionNode === formatEl || selectionNode.nodeType === 3 && (!selectionNode.nextSibling || util.isList(selectionNode.nextSibling)) && (util.getFormatElement(range.startContainer, null) !== util.getFormatElement(range.endContainer, null) ? rangeEl.contains(range.endContainer) : range.endOffset === selectionNode.textContent.length && range.collapsed))) {
            if (range.startContainer !== range.endContainer) core.removeNode();
            var _next = util.getArrayItem(formatEl.children, util.isList, false);
            _next = _next || formatEl.nextElementSibling || rangeEl.parentNode.nextElementSibling;
            if (_next && (util.isList(_next) || util.getArrayItem(_next.children, util.isList, false))) {
              e.preventDefault();
              var _con, _children;
              if (util.isList(_next)) {
                var _child2 = _next.firstElementChild;
                _children = _child2.childNodes;
                _con = _children[0];
                while (_children[0]) {
                  formatEl.insertBefore(_children[0], _next);
                }
                util.removeItem(_child2);
              } else {
                _con = _next.firstChild;
                _children = _next.childNodes;
                while (_children[0]) {
                  formatEl.appendChild(_children[0]);
                }
                util.removeItem(_next);
              }
              core.setRange(_con, 0, _con, 0);
              // history stack
              core.history.push(true);
            }
            break;
          }
          break;
        case 9:
          /** tab key */
          if (fileComponentName || options.tabDisable) break;
          e.preventDefault();
          if (ctrl || alt || util.isWysiwygDiv(selectionNode)) break;
          var isEdge = !range.collapsed || core.isEdgePoint(range.startContainer, range.startOffset);
          var selectedFormats = core.getSelectedElements(null);
          selectionNode = core.getSelectionNode();
          var cells = [];
          var lines = [];
          var fc = util.isListCell(selectedFormats[0]),
            lc = util.isListCell(selectedFormats[selectedFormats.length - 1]);
          var r = {
            sc: range.startContainer,
            so: range.startOffset,
            ec: range.endContainer,
            eo: range.endOffset
          };
          for (var i = 0, len = selectedFormats.length, f; i < len; i++) {
            f = selectedFormats[i];
            if (util.isListCell(f)) {
              if (!f.previousElementSibling && !shift) {
                continue;
              } else {
                cells.push(f);
              }
            } else {
              lines.push(f);
            }
          }

          // Nested list
          if (cells.length > 0 && isEdge && core.plugins.list) {
            r = core.plugins.list.editInsideList.call(core, shift, cells);
          } else {
            // table
            var tableCell = util.getParentElement(selectionNode, util.isCell);
            if (tableCell && isEdge) {
              var table = util.getParentElement(tableCell, 'table');
              var _cells = util.getListChildren(table, util.isCell);
              var idx = shift ? util.prevIdx(_cells, tableCell) : util.nextIdx(_cells, tableCell);
              if (idx === _cells.length && !shift) idx = 0;
              if (idx === -1 && shift) idx = _cells.length - 1;
              var moveCell = _cells[idx];
              if (!moveCell) break;
              moveCell = moveCell.firstElementChild || moveCell;
              core.setRange(moveCell, 0, moveCell, 0);
              break;
            }
            lines = lines.concat(cells);
            fc = lc = null;
          }

          // Lines tab(4)
          if (lines.length > 0) {
            if (!shift) {
              var tabText = util.createTextNode(new _w.Array(core._variable.tabSize + 1).join("\xA0"));
              if (lines.length === 1) {
                var textRange = core.insertNode(tabText, null, true);
                if (!textRange) return false;
                if (!fc) {
                  r.sc = tabText;
                  r.so = textRange.endOffset;
                }
                if (!lc) {
                  r.ec = tabText;
                  r.eo = textRange.endOffset;
                }
              } else {
                var _len14 = lines.length - 1;
                for (var _i28 = 0, _child3; _i28 <= _len14; _i28++) {
                  _child3 = lines[_i28].firstChild;
                  if (!_child3) continue;
                  if (util.isBreak(_child3)) {
                    lines[_i28].insertBefore(tabText.cloneNode(false), _child3);
                  } else {
                    _child3.textContent = tabText.textContent + _child3.textContent;
                  }
                }
                var firstChild = util.getChildElement(lines[0], 'text', false);
                var endChild = util.getChildElement(lines[_len14], 'text', true);
                if (!fc && firstChild) {
                  r.sc = firstChild;
                  r.so = 0;
                }
                if (!lc && endChild) {
                  r.ec = endChild;
                  r.eo = endChild.textContent.length;
                }
              }
            } else {
              var _len15 = lines.length - 1;
              for (var _i29 = 0, line; _i29 <= _len15; _i29++) {
                line = lines[_i29].childNodes;
                for (var c = 0, cLen = line.length, _child4; c < cLen; c++) {
                  _child4 = line[c];
                  if (!_child4) break;
                  if (util.onlyZeroWidthSpace(_child4)) continue;
                  if (/^\s{1,4}$/.test(_child4.textContent)) {
                    util.removeItem(_child4);
                  } else if (/^\s{1,4}/.test(_child4.textContent)) {
                    _child4.textContent = _child4.textContent.replace(/^\s{1,4}/, '');
                  }
                  break;
                }
              }
              var _firstChild = util.getChildElement(lines[0], 'text', false);
              var _endChild = util.getChildElement(lines[_len15], 'text', true);
              if (!fc && _firstChild) {
                r.sc = _firstChild;
                r.so = 0;
              }
              if (!lc && _endChild) {
                r.ec = _endChild;
                r.eo = _endChild.textContent.length;
              }
            }
          }
          core.setRange(r.sc, r.so, r.ec, r.eo);
          // history stack
          core.history.push(false);
          break;
        case 13:
          /** enter key */
          var freeFormatEl = util.getFreeFormatElement(selectionNode, null);
          if (core._charTypeHTML) {
            var enterHTML = '';
            if (!shift && freeFormatEl || shift) {
              enterHTML = '<br>';
            } else {
              enterHTML = '<' + formatEl.nodeName + '><br></' + formatEl.nodeName + '>';
            }
            if (!core.checkCharCount(enterHTML, 'byte-html')) {
              e.preventDefault();
              return false;
            }
          }
          if (!shift) {
            var formatInners = core._isEdgeFormat(range.endContainer, range.endOffset, 'end');
            if (formatInners && /^H[1-6]$/i.test(formatEl.nodeName) || /^HR$/i.test(formatEl.nodeName)) {
              e.preventDefault();
              var temp = null;
              var newFormat = core.appendFormatTag(formatEl, options.defaultTag);
              if (formatInners && formatInners.length > 0) {
                temp = formatInners.pop();
                var innerNode = temp;
                while (formatInners.length > 0) {
                  temp = temp.appendChild(formatInners.pop());
                }
                newFormat.appendChild(innerNode);
              }
              temp = !temp ? newFormat.firstChild : temp.appendChild(newFormat.firstChild);
              core.setRange(temp, 0, temp, 0);
              break;
            } else if (options.lineAttrReset && formatEl && !util.isListCell(formatEl)) {
              e.preventDefault();
              e.stopPropagation();
              var newEl;
              if (!range.collapsed) {
                var isMultiLine = util.getFormatElement(range.startContainer, null) !== util.getFormatElement(range.endContainer, null);
                var _r2 = core.removeNode();
                if (isMultiLine) {
                  newEl = util.getFormatElement(_r2.container, null);
                  if (!_r2.prevContainer) {
                    var _newFormat = formatEl.cloneNode(false);
                    _newFormat.innerHTML = '<br>';
                    newEl.parentNode.insertBefore(_newFormat, newEl);
                  } else if (newEl !== formatEl && newEl.nextElementSibling === formatEl) {
                    newEl = formatEl;
                  }
                } else {
                  newEl = util.splitElement(_r2.container, _r2.offset, 0);
                }
              } else {
                if (util.onlyZeroWidthSpace(formatEl)) newEl = core.appendFormatTag(formatEl, formatEl.cloneNode(false));else newEl = util.splitElement(range.endContainer, range.endOffset, 0);
              }
              var resetAttr = options.lineAttrReset === '*' ? null : options.lineAttrReset;
              var _attrs = newEl.attributes;
              var _i30 = 0;
              while (_attrs[_i30]) {
                if (resetAttr && resetAttr.test(_attrs[_i30].name)) {
                  _i30++;
                  continue;
                }
                newEl.removeAttribute(_attrs[_i30].name);
              }
              core.setRange(newEl.firstChild, 0, newEl.firstChild, 0);
              break;
            }
            if (freeFormatEl) {
              e.preventDefault();
              var selectionFormat = selectionNode === freeFormatEl;
              var wSelection = core.getSelection();
              var _children2 = selectionNode.childNodes,
                _offset2 = wSelection.focusOffset,
                _prev3 = selectionNode.previousElementSibling,
                _next2 = selectionNode.nextSibling;
              if (!util.isClosureFreeFormatElement(freeFormatEl) && !!_children2 && (selectionFormat && range.collapsed && _children2.length - 1 <= _offset2 + 1 && util.isBreak(_children2[_offset2]) && (!_children2[_offset2 + 1] || (!_children2[_offset2 + 2] || util.onlyZeroWidthSpace(_children2[_offset2 + 2].textContent)) && _children2[_offset2 + 1].nodeType === 3 && util.onlyZeroWidthSpace(_children2[_offset2 + 1].textContent)) && _offset2 > 0 && util.isBreak(_children2[_offset2 - 1]) || !selectionFormat && util.onlyZeroWidthSpace(selectionNode.textContent) && util.isBreak(_prev3) && (util.isBreak(_prev3.previousSibling) || !util.onlyZeroWidthSpace(_prev3.previousSibling.textContent)) && (!_next2 || !util.isBreak(_next2) && util.onlyZeroWidthSpace(_next2.textContent)))) {
                if (selectionFormat) util.removeItem(_children2[_offset2 - 1]);else util.removeItem(selectionNode);
                var _newEl = core.appendFormatTag(freeFormatEl, util.isFormatElement(freeFormatEl.nextElementSibling) && !util.isRangeFormatElement(freeFormatEl.nextElementSibling) ? freeFormatEl.nextElementSibling : null);
                util.copyFormatAttributes(_newEl, freeFormatEl);
                core.setRange(_newEl, 1, _newEl, 1);
                break;
              }
              if (selectionFormat) {
                functions.insertHTML(range.collapsed && util.isBreak(range.startContainer.childNodes[range.startOffset - 1]) ? '<br>' : '<br><br>', true, false);
                var focusNode = wSelection.focusNode;
                var wOffset = wSelection.focusOffset;
                if (freeFormatEl === focusNode) {
                  focusNode = focusNode.childNodes[wOffset - _offset2 > 1 ? wOffset - 1 : wOffset];
                }
                core.setRange(focusNode, 1, focusNode, 1);
              } else {
                var focusNext = wSelection.focusNode.nextSibling;
                var br = util.createElement('BR');
                core.insertNode(br, null, false);
                var brPrev = br.previousSibling,
                  brNext = br.nextSibling;
                if (!util.isBreak(focusNext) && !util.isBreak(brPrev) && (!brNext || util.onlyZeroWidthSpace(brNext))) {
                  br.parentNode.insertBefore(br.cloneNode(false), br);
                  core.setRange(br, 1, br, 1);
                } else {
                  core.setRange(brNext, 0, brNext, 0);
                }
              }
              event._onShortcutKey = true;
              break;
            }
          }
          if (selectRange) break;
          if (rangeEl && formatEl && !util.isCell(rangeEl) && !/^FIGCAPTION$/i.test(rangeEl.nodeName)) {
            var _range = core.getRange();
            if (core.isEdgePoint(_range.endContainer, _range.endOffset) && util.isList(selectionNode.nextSibling)) {
              e.preventDefault();
              var _newEl2 = util.createElement('LI');
              var _br2 = util.createElement('BR');
              _newEl2.appendChild(_br2);
              formatEl.parentNode.insertBefore(_newEl2, formatEl.nextElementSibling);
              _newEl2.appendChild(selectionNode.nextSibling);
              core.setRange(_br2, 1, _br2, 1);
              break;
            }
            if ((_range.commonAncestorContainer.nodeType === 3 ? !_range.commonAncestorContainer.nextElementSibling : true) && util.onlyZeroWidthSpace(formatEl.innerText.trim())) {
              e.preventDefault();
              var _newEl3 = null;
              if (util.isListCell(rangeEl.parentNode)) {
                rangeEl = formatEl.parentNode.parentNode.parentNode;
                _newEl3 = util.splitElement(formatEl, null, util.getElementDepth(formatEl) - 2);
                if (!_newEl3) {
                  var newListCell = util.createElement('LI');
                  newListCell.innerHTML = '<br>';
                  rangeEl.insertBefore(newListCell, _newEl3);
                  _newEl3 = newListCell;
                }
              } else {
                var _newFormat2 = util.isCell(rangeEl.parentNode) ? 'DIV' : util.isList(rangeEl.parentNode) ? 'LI' : util.isFormatElement(rangeEl.nextElementSibling) && !util.isRangeFormatElement(rangeEl.nextElementSibling) ? rangeEl.nextElementSibling.nodeName : util.isFormatElement(rangeEl.previousElementSibling) && !util.isRangeFormatElement(rangeEl.previousElementSibling) ? rangeEl.previousElementSibling.nodeName : options.defaultTag;
                _newEl3 = util.createElement(_newFormat2);
                var edge = core.detachRangeFormatElement(rangeEl, [formatEl], null, true, true);
                edge.cc.insertBefore(_newEl3, edge.ec);
              }
              _newEl3.innerHTML = '<br>';
              util.removeItemAllParents(formatEl, null, null);
              core.setRange(_newEl3, 1, _newEl3, 1);
              break;
            }
          }
          if (rangeEl && util.getParentElement(rangeEl, 'FIGCAPTION') && util.getParentElement(rangeEl, util.isList)) {
            e.preventDefault();
            formatEl = core.appendFormatTag(formatEl, null);
            core.setRange(formatEl, 0, formatEl, 0);
          }
          if (fileComponentName) {
            e.preventDefault();
            e.stopPropagation();
            var compContext = context[fileComponentName];
            var container = compContext._container;
            var sibling = container.previousElementSibling || container.nextElementSibling;
            var _newEl4 = null;
            if (util.isListCell(container.parentNode)) {
              _newEl4 = util.createElement('BR');
            } else {
              _newEl4 = util.createElement(util.isFormatElement(sibling) && !util.isRangeFormatElement(sibling) ? sibling.nodeName : options.defaultTag);
              _newEl4.innerHTML = '<br>';
            }
            container.parentNode.insertBefore(_newEl4, container);
            core.callPlugin(fileComponentName, function () {
              if (core.selectComponent(compContext._element, fileComponentName) === false) core.blur();
            }, null);
          }
          break;
        case 27:
          if (fileComponentName) {
            e.preventDefault();
            e.stopPropagation();
            core.controllersOff();
            return false;
          }
          break;
      }
      if (shift && keyCode === 16) {
        e.preventDefault();
        e.stopPropagation();
        var tablePlugin = core.plugins.table;
        if (tablePlugin && !tablePlugin._shift && !tablePlugin._ref) {
          var _cell = util.getParentElement(formatEl, util.isCell);
          if (_cell) {
            tablePlugin.onTableCellMultiSelect.call(core, _cell, true);
            return;
          }
        }
      } else if (shift && (util.isOSX_IOS ? alt : ctrl) && keyCode === 32) {
        e.preventDefault();
        e.stopPropagation();
        var nbsp = core.insertNode(util.createTextNode("\xA0"));
        if (nbsp && nbsp.container) {
          core.setRange(nbsp.container, nbsp.endOffset, nbsp.container, nbsp.endOffset);
          return;
        }
      }
      if (util.isIE && !ctrl && !alt && !selectRange && !event._nonTextKeyCode.test(keyCode) && util.isBreak(range.commonAncestorContainer)) {
        var zeroWidth = util.createTextNode(util.zeroWidthSpace);
        core.insertNode(zeroWidth, null, false);
        core.setRange(zeroWidth, 1, zeroWidth, 1);
      }
    },
    onKeyUp_wysiwyg: function onKeyUp_wysiwyg(e) {
      if (event._onShortcutKey) return;
      core._editorRange();
      var keyCode = e.keyCode;
      var ctrl = e.ctrlKey || e.metaKey || keyCode === 91 || keyCode === 92 || keyCode === 224;
      var alt = e.altKey;
      if (core.isReadOnly) {
        if (!ctrl && event._directionKeyCode.test(keyCode)) event._applyTagEffects();
        return;
      }
      var range = core.getRange();
      var selectionNode = core.getSelectionNode();
      if (core._isBalloon && (core._isBalloonAlways && keyCode !== 27 || !range.collapsed)) {
        if (core._isBalloonAlways) {
          if (keyCode !== 27) event._showToolbarBalloonDelay();
        } else {
          event._showToolbarBalloon();
          return;
        }
      }

      /** when format tag deleted */
      if (keyCode === 8 && util.isWysiwygDiv(selectionNode) && selectionNode.textContent === '' && selectionNode.children.length === 0) {
        e.preventDefault();
        e.stopPropagation();
        selectionNode.innerHTML = '';
        var oFormatTag = util.createElement(util.isFormatElement(core._variable.currentNodes[0]) ? core._variable.currentNodes[0] : options.defaultTag);
        oFormatTag.innerHTML = '<br>';
        selectionNode.appendChild(oFormatTag);
        core.setRange(oFormatTag, 0, oFormatTag, 0);
        event._applyTagEffects();
        core.history.push(false);
        return;
      }
      var formatEl = util.getFormatElement(selectionNode, null);
      var rangeEl = util.getRangeFormatElement(selectionNode, null);
      if (!formatEl && range.collapsed && !util.isComponent(selectionNode) && !util.isList(selectionNode) && core._setDefaultFormat(util.isRangeFormatElement(rangeEl) ? 'DIV' : options.defaultTag) !== null) {
        selectionNode = core.getSelectionNode();
      }
      if (event._directionKeyCode.test(keyCode)) {
        event._applyTagEffects();
      }
      var textKey = !ctrl && !alt && !event._nonTextKeyCode.test(keyCode);
      if (textKey && selectionNode.nodeType === 3 && util.zeroWidthRegExp.test(selectionNode.textContent) && !(e.isComposing !== undefined ? e.isComposing : event._IEisComposing)) {
        var so = range.startOffset,
          eo = range.endOffset;
        var frontZeroWidthCnt = (selectionNode.textContent.substring(0, eo).match(event._frontZeroWidthReg) || '').length;
        so = range.startOffset - frontZeroWidthCnt;
        eo = range.endOffset - frontZeroWidthCnt;
        selectionNode.textContent = selectionNode.textContent.replace(util.zeroWidthRegExp, '');
        core.setRange(selectionNode, so < 0 ? 0 : so, selectionNode, eo < 0 ? 0 : eo);
      }
      core._charCount('');

      // user event
      if (typeof functions.onKeyUp === 'function' && functions.onKeyUp(e, core) === false) return;

      // history stack
      if (!ctrl && !alt && !event._historyIgnoreKeyCode.test(keyCode)) {
        core.history.push(true);
      }
    },
    onScroll_wysiwyg: function onScroll_wysiwyg(e) {
      core.controllersOff();
      if (core._isBalloon) event._hideToolbar();

      // user event
      if (typeof functions.onScroll === 'function') functions.onScroll(e, core);
    },
    onFocus_wysiwyg: function onFocus_wysiwyg(e) {
      if (core._antiBlur) return;
      core.hasFocus = true;
      _w.setTimeout(event._applyTagEffects);
      if (core._isInline) event._showToolbarInline();

      // user event
      if (typeof functions.onFocus === 'function') functions.onFocus(e, core);
    },
    onBlur_wysiwyg: function onBlur_wysiwyg(e) {
      if (core._antiBlur || core._variable.isCodeView) return;
      core.hasFocus = false;
      core.effectNode = null;
      core.controllersOff();
      if (core._isInline || core._isBalloon) event._hideToolbar();
      core._setKeyEffect([]);
      core._variable.currentNodes = [];
      core._variable.currentNodesMap = [];
      if (options.showPathLabel) context.element.navigation.textContent = '';

      // user event
      if (typeof functions.onBlur === 'function') functions.onBlur(e, core);
    },
    onMouseDown_resizingBar: function onMouseDown_resizingBar(e) {
      e.stopPropagation();
      core.submenuOff();
      core.controllersOff();
      core._variable.resizeClientY = e.clientY;
      context.element.resizeBackground.style.display = 'block';
      function closureFunc() {
        context.element.resizeBackground.style.display = 'none';
        _d.removeEventListener('mousemove', event._resize_editor);
        _d.removeEventListener('mouseup', closureFunc);
      }
      _d.addEventListener('mousemove', event._resize_editor);
      _d.addEventListener('mouseup', closureFunc);
    },
    _resize_editor: function _resize_editor(e) {
      var resizeInterval = context.element.editorArea.offsetHeight + (e.clientY - core._variable.resizeClientY);
      var h = resizeInterval < core._variable.minResizingSize ? core._variable.minResizingSize : resizeInterval;
      context.element.wysiwygFrame.style.height = context.element.code.style.height = h + 'px';
      core._variable.resizeClientY = e.clientY;
      if (util.isIE) core.__callResizeFunction(h, null);
    },
    onResize_window: function onResize_window() {
      if (util.isIE) core.resetResponsiveToolbar();
      if (context.element.toolbar.offsetWidth === 0) return;
      if (context.fileBrowser && context.fileBrowser.area.style.display === 'block') {
        context.fileBrowser.body.style.maxHeight = _w.innerHeight - context.fileBrowser.header.offsetHeight - 50 + 'px';
      }
      if (core.submenuActiveButton && core.submenu) {
        core._setMenuPosition(core.submenuActiveButton, core.submenu);
      }
      if (core._variable.isFullScreen) {
        core._variable.innerHeight_fullScreen += _w.innerHeight - context.element.toolbar.offsetHeight - core._variable.innerHeight_fullScreen;
        context.element.editorArea.style.height = core._variable.innerHeight_fullScreen + 'px';
        return;
      }
      if (core._variable.isCodeView && core._isInline) {
        event._showToolbarInline();
        return;
      }
      core._iframeAutoHeight();
      if (core._sticky) {
        context.element.toolbar.style.width = context.element.topArea.offsetWidth - 2 + 'px';
        event.onScroll_window();
      }
    },
    onScroll_window: function onScroll_window() {
      if (core._variable.isFullScreen || context.element.toolbar.offsetWidth === 0 || options.stickyToolbar < 0) return;
      var element = context.element;
      var editorHeight = element.editorArea.offsetHeight;
      var y = (this.scrollY || _d.documentElement.scrollTop) + options.stickyToolbar;
      var editorTop = event._getEditorOffsets(options.toolbarContainer).top - (core._isInline ? element.toolbar.offsetHeight : 0);
      var inlineOffset = core._isInline && y - editorTop > 0 ? y - editorTop - context.element.toolbar.offsetHeight : 0;
      if (y < editorTop) {
        event._offStickyToolbar();
      } else if (y + core._variable.minResizingSize >= editorHeight + editorTop) {
        if (!core._sticky) event._onStickyToolbar(inlineOffset);
        element.toolbar.style.top = inlineOffset + editorHeight + editorTop + options.stickyToolbar - y - core._variable.minResizingSize + 'px';
      } else if (y >= editorTop) {
        event._onStickyToolbar(inlineOffset);
      }
    },
    _getEditorOffsets: function _getEditorOffsets(container) {
      var offsetEl = container || context.element.topArea;
      var t = 0,
        l = 0,
        s = 0;
      while (offsetEl) {
        t += offsetEl.offsetTop;
        l += offsetEl.offsetLeft;
        s += offsetEl.scrollTop;
        offsetEl = offsetEl.offsetParent;
      }
      return {
        top: t,
        left: l,
        scroll: s
      };
    },
    _getPageBottomSpace: function _getPageBottomSpace() {
      return _d.documentElement.scrollHeight - (event._getEditorOffsets(null).top + context.element.topArea.offsetHeight);
    },
    _onStickyToolbar: function _onStickyToolbar(inlineOffset) {
      var element = context.element;
      if (!core._isInline && !options.toolbarContainer) {
        element._stickyDummy.style.height = element.toolbar.offsetHeight + 'px';
        element._stickyDummy.style.display = 'block';
      }
      element.toolbar.style.top = options.stickyToolbar + inlineOffset + 'px';
      element.toolbar.style.width = core._isInline ? core._inlineToolbarAttr.width : element.toolbar.offsetWidth + 'px';
      util.addClass(element.toolbar, 'se-toolbar-sticky');
      core._sticky = true;
    },
    _offStickyToolbar: function _offStickyToolbar() {
      var element = context.element;
      element._stickyDummy.style.display = 'none';
      element.toolbar.style.top = core._isInline ? core._inlineToolbarAttr.top : '';
      element.toolbar.style.width = core._isInline ? core._inlineToolbarAttr.width : '';
      element.editorArea.style.marginTop = '';
      util.removeClass(element.toolbar, 'se-toolbar-sticky');
      core._sticky = false;
    },
    _codeViewAutoHeight: function _codeViewAutoHeight() {
      if (core._variable.isFullScreen) return;
      context.element.code.style.height = context.element.code.scrollHeight + 'px';
    },
    // FireFox - table delete, Chrome - image, video, audio
    _hardDelete: function _hardDelete() {
      var range = core.getRange();
      var sc = range.startContainer;
      var ec = range.endContainer;

      // table
      var sCell = util.getRangeFormatElement(sc);
      var eCell = util.getRangeFormatElement(ec);
      var sIsCell = util.isCell(sCell);
      var eIsCell = util.isCell(eCell);
      var ancestor = range.commonAncestorContainer;
      if ((sIsCell && !sCell.previousElementSibling && !sCell.parentElement.previousElementSibling || eIsCell && !eCell.nextElementSibling && !eCell.parentElement.nextElementSibling) && sCell !== eCell) {
        if (!sIsCell) {
          util.removeItem(util.getParentElement(eCell, function (current) {
            return ancestor === current.parentNode;
          }));
        } else if (!eIsCell) {
          util.removeItem(util.getParentElement(sCell, function (current) {
            return ancestor === current.parentNode;
          }));
        } else {
          util.removeItem(util.getParentElement(sCell, function (current) {
            return ancestor === current.parentNode;
          }));
          core.nativeFocus();
          return true;
        }
      }

      // component
      var sComp = sc.nodeType === 1 ? util.getParentElement(sc, '.se-component') : null;
      var eComp = ec.nodeType === 1 ? util.getParentElement(ec, '.se-component') : null;
      if (sComp) util.removeItem(sComp);
      if (eComp) util.removeItem(eComp);
      return false;
    },
    onPaste_wysiwyg: function onPaste_wysiwyg(e) {
      var clipboardData = util.isIE ? _w.clipboardData : e.clipboardData;
      if (!clipboardData) return true;
      return event._dataTransferAction('paste', e, clipboardData);
    },
    _setClipboardComponent: function _setClipboardComponent(e, info, clipboardData) {
      e.preventDefault();
      e.stopPropagation();
      clipboardData.setData('text/html', info.component.outerHTML);
    },
    onCopy_wysiwyg: function onCopy_wysiwyg(e) {
      var clipboardData = util.isIE ? _w.clipboardData : e.clipboardData;

      // user event
      if (typeof functions.onCopy === 'function' && !functions.onCopy(e, clipboardData, core)) {
        e.preventDefault();
        e.stopPropagation();
        return false;
      }
      var info = core.currentFileComponentInfo;
      if (info && !util.isIE) {
        event._setClipboardComponent(e, info, clipboardData);
        util.addClass(info.component, 'se-component-copy');
        // copy effect
        _w.setTimeout(function () {
          util.removeClass(info.component, 'se-component-copy');
        }, 150);
      }
    },
    onSave_wysiwyg: function onSave_wysiwyg(content) {
      // user event
      if (typeof functions.onSave === 'function') {
        functions.onSave(content, core);
        return;
      }
    },
    onCut_wysiwyg: function onCut_wysiwyg(e) {
      var clipboardData = util.isIE ? _w.clipboardData : e.clipboardData;

      // user event
      if (typeof functions.onCut === 'function' && !functions.onCut(e, clipboardData, core)) {
        e.preventDefault();
        e.stopPropagation();
        return false;
      }
      var info = core.currentFileComponentInfo;
      if (info && !util.isIE) {
        event._setClipboardComponent(e, info, clipboardData);
        util.removeItem(info.component);
        core.controllersOff();
      }
      _w.setTimeout(function () {
        // history stack
        core.history.push(false);
      });
    },
    onDrop_wysiwyg: function onDrop_wysiwyg(e) {
      if (core.isReadOnly || util.isIE) {
        e.preventDefault();
        e.stopPropagation();
        return false;
      }
      var dataTransfer = e.dataTransfer;
      if (!dataTransfer) return true;
      core.removeNode();
      event._setDropLocationSelection(e);
      return event._dataTransferAction('drop', e, dataTransfer);
    },
    _setDropLocationSelection: function _setDropLocationSelection(e) {
      if (e.rangeParent) {
        core.setRange(e.rangeParent, e.rangeOffset, e.rangeParent, e.rangeOffset);
      } else if (core._wd.caretRangeFromPoint) {
        var r = core._wd.caretRangeFromPoint(e.clientX, e.clientY);
        core.setRange(r.startContainer, r.startOffset, r.endContainer, r.endOffset);
      } else {
        var _r3 = core.getRange();
        core.setRange(_r3.startContainer, _r3.startOffset, _r3.endContainer, _r3.endOffset);
      }
    },
    _dataTransferAction: function _dataTransferAction(type, e, data) {
      var plainText, cleanData;
      if (util.isIE) {
        plainText = data.getData('Text');
        var range = core.getRange();
        var tempDiv = util.createElement('DIV');
        var tempRange = {
          sc: range.startContainer,
          so: range.startOffset,
          ec: range.endContainer,
          eo: range.endOffset
        };
        tempDiv.setAttribute('contenteditable', true);
        tempDiv.style.cssText = 'position:absolute; top:0; left:0; width:1px; height:1px; overflow:hidden;';
        context.element.relative.appendChild(tempDiv);
        tempDiv.focus();
        _w.setTimeout(function () {
          cleanData = tempDiv.innerHTML;
          util.removeItem(tempDiv);
          core.setRange(tempRange.sc, tempRange.so, tempRange.ec, tempRange.eo);
          event._setClipboardData(type, e, plainText, cleanData, data);
        });
        return true;
      } else {
        plainText = data.getData('text/plain');
        cleanData = data.getData('text/html');
        if (event._setClipboardData(type, e, plainText, cleanData, data) === false) {
          e.preventDefault();
          e.stopPropagation();
          return false;
        }
      }
    },
    _setClipboardData: function _setClipboardData(type, e, plainText, cleanData, data) {
      // MS word, OneNode, Excel
      var MSData = /class=["']*Mso(Normal|List)/i.test(cleanData) || /content=["']*Word.Document/i.test(cleanData) || /content=["']*OneNote.File/i.test(cleanData) || /content=["']*Excel.Sheet/i.test(cleanData);
      var onlyText = !cleanData;
      if (!onlyText) {
        cleanData = cleanData.replace(/^<html>\r?\n?<body>\r?\n?\x3C!--StartFragment--\>|\x3C!--EndFragment-->\r?\n?<\/body\>\r?\n?<\/html>$/g, '');
        if (MSData) {
          cleanData = cleanData.replace(/\n/g, ' ');
          plainText = plainText.replace(/\n/g, ' ');
        } else {
          cleanData = (plainText === cleanData ? plainText : cleanData).replace(/\n/g, '<br>');
        }
        cleanData = core.cleanHTML(cleanData, core.pasteTagsWhitelistRegExp, core.pasteTagsBlacklistRegExp);
      } else {
        cleanData = util._HTMLConvertor(plainText).replace(/\n/g, '<br>');
      }
      var maxCharCount = core._charCount(core._charTypeHTML ? cleanData : plainText);
      // user event - paste
      if (type === 'paste' && typeof functions.onPaste === 'function') {
        var value = functions.onPaste(e, cleanData, maxCharCount, core);
        if (!value) return false;
        if (typeof value === 'string') cleanData = value;
      }
      // user event - drop
      if (type === 'drop' && typeof functions.onDrop === 'function') {
        var _value = functions.onDrop(e, cleanData, maxCharCount, core);
        if (!_value) return false;
        if (typeof _value === 'string') cleanData = _value;
      }

      // files
      var files = data.files;
      if (files.length > 0 && !MSData) {
        if (/^image/.test(files[0].type) && core.plugins.image) {
          functions.insertImage(files);
        }
        return false;
      }
      if (!maxCharCount) {
        return false;
      }
      if (cleanData) {
        functions.insertHTML(cleanData, true, false);
        return false;
      }
    },
    onMouseMove_wysiwyg: function onMouseMove_wysiwyg(e) {
      if (core.isDisabled || core.isReadOnly) return false;
      var component = util.getParentElement(e.target, util.isComponent);
      var lineBreakerStyle = core._lineBreaker.style;
      if (component && !core.currentControllerName) {
        var ctxEl = context.element;
        var scrollTop = 0;
        var el = ctxEl.wysiwyg;
        do {
          scrollTop += el.scrollTop;
          el = el.parentElement;
        } while (el && !/^(BODY|HTML)$/i.test(el.nodeName));
        var wScroll = ctxEl.wysiwyg.scrollTop;
        var offsets = event._getEditorOffsets(null);
        var componentTop = util.getOffset(component, ctxEl.wysiwygFrame).top + wScroll;
        var y = e.pageY + scrollTop + (options.iframe && !options.toolbarContainer ? ctxEl.toolbar.offsetHeight : 0);
        var c = componentTop + (options.iframe ? scrollTop : offsets.top);
        var isList = util.isListCell(component.parentNode);
        var dir = '',
          top = '';
        if ((isList ? !component.previousSibling : !util.isFormatElement(component.previousElementSibling)) && y < c + 20) {
          top = componentTop;
          dir = 't';
        } else if ((isList ? !component.nextSibling : !util.isFormatElement(component.nextElementSibling)) && y > c + component.offsetHeight - 20) {
          top = componentTop + component.offsetHeight;
          dir = 'b';
        } else {
          lineBreakerStyle.display = 'none';
          return;
        }
        core._variable._lineBreakComp = component;
        core._variable._lineBreakDir = dir;
        lineBreakerStyle.top = top - wScroll + 'px';
        core._lineBreakerButton.style.left = util.getOffset(component).left + component.offsetWidth / 2 - 15 + 'px';
        lineBreakerStyle.display = 'block';
      } // off line breaker
      else if (lineBreakerStyle.display !== 'none') {
        lineBreakerStyle.display = 'none';
      }
    },
    _onMouseDown_lineBreak: function _onMouseDown_lineBreak(e) {
      e.preventDefault();
    },
    _onLineBreak: function _onLineBreak(e) {
      e.preventDefault();
      var component = core._variable._lineBreakComp;
      var dir = !this ? core._variable._lineBreakDir : this;
      var isList = util.isListCell(component.parentNode);
      var format = util.createElement(isList ? 'BR' : util.isCell(component.parentNode) ? 'DIV' : options.defaultTag);
      if (!isList) format.innerHTML = '<br>';
      if (core._charTypeHTML && !core.checkCharCount(format.outerHTML, 'byte-html')) return;
      component.parentNode.insertBefore(format, dir === 't' ? component : component.nextSibling);
      core._lineBreaker.style.display = 'none';
      core._variable._lineBreakComp = null;
      var focusEl = isList ? format : format.firstChild;
      core.setRange(focusEl, 1, focusEl, 1);
      // history stack
      core.history.push(false);
    },
    _resizeObserver: null,
    _toolbarObserver: null,
    _addEvent: function _addEvent() {
      var eventWysiwyg = options.iframe ? core._ww : context.element.wysiwyg;
      if (!util.isIE) {
        this._resizeObserver = new _w.ResizeObserver(function (entries) {
          core.__callResizeFunction(-1, entries[0]);
        });
      }

      /** toolbar event */
      context.element.toolbar.addEventListener('mousedown', event._buttonsEventHandler, false);
      context.element._menuTray.addEventListener('mousedown', event._buttonsEventHandler, false);
      context.element.toolbar.addEventListener('click', event.onClick_toolbar, false);
      /** editor area */
      eventWysiwyg.addEventListener('mousedown', event.onMouseDown_wysiwyg, false);
      eventWysiwyg.addEventListener('click', event.onClick_wysiwyg, false);
      eventWysiwyg.addEventListener(util.isIE ? 'textinput' : 'input', event.onInput_wysiwyg, false);
      eventWysiwyg.addEventListener('keydown', event.onKeyDown_wysiwyg, false);
      eventWysiwyg.addEventListener('keyup', event.onKeyUp_wysiwyg, false);
      eventWysiwyg.addEventListener('paste', event.onPaste_wysiwyg, false);
      eventWysiwyg.addEventListener('copy', event.onCopy_wysiwyg, false);
      eventWysiwyg.addEventListener('cut', event.onCut_wysiwyg, false);
      eventWysiwyg.addEventListener('drop', event.onDrop_wysiwyg, false);
      eventWysiwyg.addEventListener('scroll', event.onScroll_wysiwyg, false);
      eventWysiwyg.addEventListener('focus', event.onFocus_wysiwyg, false);
      eventWysiwyg.addEventListener('blur', event.onBlur_wysiwyg, false);

      /** line breaker */
      event._lineBreakerBind = {
        a: event._onLineBreak.bind(''),
        t: event._onLineBreak.bind('t'),
        b: event._onLineBreak.bind('b')
      };
      eventWysiwyg.addEventListener('mousemove', event.onMouseMove_wysiwyg, false);
      core._lineBreakerButton.addEventListener('mousedown', event._onMouseDown_lineBreak, false);
      core._lineBreakerButton.addEventListener('click', event._lineBreakerBind.a, false);
      context.element.lineBreaker_t.addEventListener('mousedown', event._lineBreakerBind.t, false);
      context.element.lineBreaker_b.addEventListener('mousedown', event._lineBreakerBind.b, false);

      /** Events are registered only when there is a table plugin.  */
      if (core.plugins.table) {
        eventWysiwyg.addEventListener('touchstart', event.onMouseDown_wysiwyg, {
          passive: true,
          useCapture: false
        });
      }

      /** code view area auto line */
      if (options.height === 'auto' && !options.codeMirrorEditor) {
        context.element.code.addEventListener('keydown', event._codeViewAutoHeight, false);
        context.element.code.addEventListener('keyup', event._codeViewAutoHeight, false);
        context.element.code.addEventListener('paste', event._codeViewAutoHeight, false);
      }

      /** resizingBar */
      if (context.element.resizingBar) {
        if (/\d+/.test(options.height) && options.resizeEnable) {
          context.element.resizingBar.addEventListener('mousedown', event.onMouseDown_resizingBar, false);
        } else {
          util.addClass(context.element.resizingBar, 'se-resizing-none');
        }
      }

      /** set response toolbar */
      event._setResponsiveToolbar();

      /** responsive toolbar observer */
      if (!util.isIE) this._toolbarObserver = new _w.ResizeObserver(core.resetResponsiveToolbar);

      /** window event */
      _w.addEventListener('resize', event.onResize_window, false);
      if (options.stickyToolbar > -1) {
        _w.addEventListener('scroll', event.onScroll_window, false);
      }
    },
    _removeEvent: function _removeEvent() {
      var eventWysiwyg = options.iframe ? core._ww : context.element.wysiwyg;
      context.element.toolbar.removeEventListener('mousedown', event._buttonsEventHandler);
      context.element._menuTray.removeEventListener('mousedown', event._buttonsEventHandler);
      context.element.toolbar.removeEventListener('click', event.onClick_toolbar);
      eventWysiwyg.removeEventListener('mousedown', event.onMouseDown_wysiwyg);
      eventWysiwyg.removeEventListener('click', event.onClick_wysiwyg);
      eventWysiwyg.removeEventListener(util.isIE ? 'textinput' : 'input', event.onInput_wysiwyg);
      eventWysiwyg.removeEventListener('keydown', event.onKeyDown_wysiwyg);
      eventWysiwyg.removeEventListener('keyup', event.onKeyUp_wysiwyg);
      eventWysiwyg.removeEventListener('paste', event.onPaste_wysiwyg);
      eventWysiwyg.removeEventListener('copy', event.onCopy_wysiwyg);
      eventWysiwyg.removeEventListener('cut', event.onCut_wysiwyg);
      eventWysiwyg.removeEventListener('drop', event.onDrop_wysiwyg);
      eventWysiwyg.removeEventListener('scroll', event.onScroll_wysiwyg);
      eventWysiwyg.removeEventListener('mousemove', event.onMouseMove_wysiwyg);
      core._lineBreakerButton.removeEventListener('mousedown', event._onMouseDown_lineBreak);
      core._lineBreakerButton.removeEventListener('click', event._lineBreakerBind.a);
      context.element.lineBreaker_t.removeEventListener('mousedown', event._lineBreakerBind.t);
      context.element.lineBreaker_b.removeEventListener('mousedown', event._lineBreakerBind.b);
      event._lineBreakerBind = null;
      eventWysiwyg.removeEventListener('touchstart', event.onMouseDown_wysiwyg, {
        passive: true,
        useCapture: false
      });
      eventWysiwyg.removeEventListener('focus', event.onFocus_wysiwyg);
      eventWysiwyg.removeEventListener('blur', event.onBlur_wysiwyg);
      context.element.code.removeEventListener('keydown', event._codeViewAutoHeight);
      context.element.code.removeEventListener('keyup', event._codeViewAutoHeight);
      context.element.code.removeEventListener('paste', event._codeViewAutoHeight);
      if (context.element.resizingBar) {
        context.element.resizingBar.removeEventListener('mousedown', event.onMouseDown_resizingBar);
      }
      if (event._resizeObserver) {
        event._resizeObserver.unobserve(context.element.wysiwygFrame);
        event._resizeObserver = null;
      }
      if (event._toolbarObserver) {
        event._toolbarObserver.unobserve(context.element._toolbarShadow);
        event._toolbarObserver = null;
      }
      _w.removeEventListener('resize', event.onResize_window);
      _w.removeEventListener('scroll', event.onScroll_window);
    },
    _setResponsiveToolbar: function _setResponsiveToolbar() {
      if (_responsiveButtons.length === 0) {
        _responsiveButtons = null;
        return;
      }
      event._responsiveCurrentSize = 'default';
      var sizeArray = event._responsiveButtonSize = [];
      var buttonsObj = event._responsiveButtons = {
        default: _responsiveButtons[0]
      };
      for (var i = 1, len = _responsiveButtons.length, size, buttonGroup; i < len; i++) {
        buttonGroup = _responsiveButtons[i];
        size = buttonGroup[0] * 1;
        sizeArray.push(size);
        buttonsObj[size] = buttonGroup[1];
      }
      sizeArray.sort(function (a, b) {
        return a - b;
      }).unshift('default');
    }
  };

  /** functions */
  var functions = {
    /**
     * @description Core, Util object
     */
    core: core,
    util: util,
    /**
     * @description Event functions
     * @param {Object} e Event Object
     * @param {Object} core Core object
     */
    onload: null,
    onScroll: null,
    onMouseDown: null,
    onClick: null,
    onInput: null,
    onKeyDown: null,
    onKeyUp: null,
    onCopy: null,
    onCut: null,
    onFocus: null,
    onBlur: null,
    /**
     * @description Event functions
     * @param {String} contents Current contents
     * @param {Object} core Core object
     */
    onChange: null,
    /**
     * @description Event functions
     * @param {String} contents Current contents
     * @param {Object} core Core object
     */
    onSave: null,
    /**
     * @description Event functions (drop, paste)
     * When false is returned, the default behavior is stopped.
     * If the string is returned, the cleanData value is modified to the return value.
     * @param {Object} e Event object.
     * @param {String} cleanData HTML string modified for editor format.
     * @param {Boolean} maxChartCount option (true if max character is exceeded)
     * @param {Object} core Core object
     * @returns {Boolean|String}
     */
    onDrop: null,
    onPaste: null,
    /**
     * @description Called just before the inline toolbar is positioned and displayed on the screen.
     * @param {Element} toolbar Toolbar Element
     * @param {Object} context The editor's context object (editor.getContext())
     * @param {Object} core Core object
     */
    showInline: null,
    /**
     * @description Called just after the controller is positioned and displayed on the screen.
     * controller - editing elements displayed on the screen [image resizing, table editor, link editor..]]
     * @param {String} name The name of the plugin that called the controller
     * @param {Array} controllers Array of Controller elements
     * @param {Object} core Core object
     */
    showController: null,
    /**
     * @description An event when toggling between code view and wysiwyg view.
     * @param {Boolean} isCodeView Whether the current code view mode
     * @param {Object} core Core object
     */
    toggleCodeView: null,
    /**
     * @description An event when toggling full screen.
     * @param {Boolean} isFullScreen Whether the current full screen mode
     * @param {Object} core Core object
     */
    toggleFullScreen: null,
    /**
     * @description It replaces the default callback function of the image upload
     * @param {Object} response Response object
     * @param {Object} info Input information
     * - linkValue: Link url value
     * - linkNewWindow: Open in new window Check Value
     * - inputWidth: Value of width input
     * - inputHeight: Value of height input
     * - align: Align Check Value
     * - isUpdate: Update image if true, create image if false
     * - element: If isUpdate is true, the currently selected image.
     * @param {Object} core Core object
     */
    imageUploadHandler: null,
    /**
     * @description It replaces the default callback function of the video upload
     * @param xmlHttp xmlHttpRequest object
     * @param info Input information
     * - inputWidth: Value of width input
     * - inputHeight: Value of height input
     * - align: Align Check Value
     * - isUpdate: Update video if true, create video if false
     * - element: If isUpdate is true, the currently selected video.
     * @param core Core object
     */
    videoUploadHandler: null,
    /**
     * @description It replaces the default callback function of the audio upload
     * @param xmlHttp xmlHttpRequest object
     * @param info Input information
     * - isUpdate: Update audio if true, create audio if false
     * - element: If isUpdate is true, the currently selected audio.
     * @param core Core object
     */
    audioUploadHandler: null,
    /**
     * @description Called before the image is uploaded
     * If true is returned, the internal upload process runs normally.
     * If false is returned, no image upload is performed.
     * If new fileList are returned,  replaced the previous fileList
     * If undefined is returned, it waits until "uploadHandler" is executed.
     * @param {Array} files Files array
     * @param {Object} info info: {
     * - linkValue: Link url value
     * - linkNewWindow: Open in new window Check Value
     * - inputWidth: Value of width input
     * - inputHeight: Value of height input
     * - align: Align Check Value
     * - isUpdate: Update image if true, create image if false
     * - element: If isUpdate is true, the currently selected image.
     * }
     * @param {Object} core Core object
     * @param {Function} uploadHandler If undefined is returned, it waits until "uploadHandler" is executed.
     *                "uploadHandler" is an upload function with "core" and "info" bound.
     *                [upload files] : uploadHandler(files or [new File(...),])
     *                [error]        : uploadHandler("Error message")
     *                [Just finish]  : uploadHandler()
     *                [directly register] : uploadHandler(response) // Same format as "imageUploadUrl" response
     *                                   ex) {
     *                                      // "errorMessage": "insert error message",
     *                                      "result": [ { "url": "...", "name": "...", "size": "999" }, ]
     *                                   }
     * @returns {Boolean|Array|undefined}
     */
    onImageUploadBefore: null,
    /**
     * @description Called before the video is uploaded
     * If true is returned, the internal upload process runs normally.
     * If false is returned, no video(iframe, video) upload is performed.
     * If new fileList are returned,  replaced the previous fileList
     * If undefined is returned, it waits until "uploadHandler" is executed.
     * @param {Array} files Files array
     * @param {Object} info info: {
     * - inputWidth: Value of width input
     * - inputHeight: Value of height input
     * - align: Align Check Value
     * - isUpdate: Update video if true, create video if false
     * - element: If isUpdate is true, the currently selected video.
     * }
     * @param {Object} core Core object
     * @param {Function} uploadHandler If undefined is returned, it waits until "uploadHandler" is executed.
     *                "uploadHandler" is an upload function with "core" and "info" bound.
     *                [upload files] : uploadHandler(files or [new File(...),])
     *                [error]        : uploadHandler("Error message")
     *                [Just finish]  : uploadHandler()
     *                [directly register] : uploadHandler(response) // Same format as "videoUploadUrl" response
     *                                   ex) {
     *                                      // "errorMessage": "insert error message",
     *                                      "result": [ { "url": "...", "name": "...", "size": "999" }, ]
     *                                   }
     * @returns {Boolean|Array|undefined}
     */
    onVideoUploadBefore: null,
    /**
     * @description Called before the audio is uploaded
     * If true is returned, the internal upload process runs normally.
     * If false is returned, no audio upload is performed.
     * If new fileList are returned,  replaced the previous fileList
     * If undefined is returned, it waits until "uploadHandler" is executed.
     * @param {Array} files Files array
     * @param {Object} info info: {
     * - isUpdate: Update audio if true, create audio if false
     * - element: If isUpdate is true, the currently selected audio.
     * }
     * @param {Object} core Core object
     * @param {Function} uploadHandler If undefined is returned, it waits until "uploadHandler" is executed.
     *                "uploadHandler" is an upload function with "core" and "info" bound.
     *                [upload files] : uploadHandler(files or [new File(...),])
     *                [error]        : uploadHandler("Error message")
     *                [Just finish]  : uploadHandler()
     *                [directly register] : uploadHandler(response) // Same format as "audioUploadUrl" response
     *                                   ex) {
     *                                      // "errorMessage": "insert error message",
     *                                      "result": [ { "url": "...", "name": "...", "size": "999" }, ]
     *                                   }
     * @returns {Boolean|Array|undefined}
     */
    onAudioUploadBefore: null,
    /**
     * @description Called when the image is uploaded, updated, deleted
     * @param {Element} targetElement Target element
     * @param {Number} index Uploaded index
     * @param {String} state Upload status ('create', 'update', 'delete')
     * @param {Object} info Image info object
     * - index: data index
     * - name: file name
     * - size: file size
     * - select: select function
     * - delete: delete function
     * - element: target element
     * - src: src attribute of tag
     * @param {Number} remainingFilesCount Count of remaining files to upload (0 when added as a url)
     * @param {Object} core Core object
     */
    onImageUpload: null,
    /**
    * @description Called when the video(iframe, video) is is uploaded, updated, deleted
    * -- arguments is same "onImageUpload" --
    */
    onVideoUpload: null,
    /**
    * @description Called when the audio is is uploaded, updated, deleted
    * -- arguments is same "onImageUpload" --
    */
    onAudioUpload: null,
    /**
     * @description Called when the image is upload failed
     * @param {String} errorMessage Error message
     * @param {Object} result Response Object
     * @param {Object} core Core object
     * @returns {Boolean}
     */
    onImageUploadError: null,
    /**
     * @description Called when the video(iframe, video) upload failed
     * -- arguments is same "onImageUploadError" --
     */
    onVideoUploadError: null,
    /**
     * @description Called when the audio upload failed
     * -- arguments is same "onImageUploadError" --
     */
    onAudioUploadError: null,
    /**
     * @description Called when the editor is resized using the bottom bar
     */
    onResizeEditor: null,
    /**
     * @description Called after the "setToolbarButtons" invocation.
     * Can be used to tweak buttons properties (useful for custom buttons)
     * @param {Array} buttonList Button list 
     * @param {Object} core Core object
     */
    onSetToolbarButtons: null,
    /**
     * @description Reset the buttons on the toolbar. (Editor is not reloaded)
     * You cannot set a new plugin for the button.
     * @param {Array} buttonList Button list 
     */
    setToolbarButtons: function setToolbarButtons(buttonList) {
      core.submenuOff();
      core.containerOff();
      core.moreLayerOff();
      var newToolbar = lib_constructor._createToolBar(_d, buttonList, core.plugins, options);
      _responsiveButtons = newToolbar.responsiveButtons;
      event._setResponsiveToolbar();
      context.element.toolbar.replaceChild(newToolbar._buttonTray, context.element._buttonTray);
      var newContext = lib_context(context.element.originElement, core._getConstructed(context.element), options);
      context.element = newContext.element;
      context.tool = newContext.tool;
      if (options.iframe) context.element.wysiwyg = core._wd.body;
      core._recoverButtonStates();
      core._cachingButtons();
      core.history._resetCachingButton();
      core.effectNode = null;
      if (core.hasFocus) event._applyTagEffects();
      if (core.isReadOnly) util.setDisabledButtons(true, core.resizingDisabledButtons);
      if (typeof functions.onSetToolbarButtons === 'function') functions.onSetToolbarButtons(newToolbar._buttonTray.querySelectorAll('button'), core);
    },
    /**
     * @description Add or reset option property (Editor is reloaded)
     * @param {Object} _options Options
     */
    setOptions: function setOptions(_options) {
      event._removeEvent();
      core._resetComponents();
      util.removeClass(core._styleCommandMap.showBlocks, 'active');
      util.removeClass(core._styleCommandMap.codeView, 'active');
      core._variable.isCodeView = false;
      core._iframeAuto = null;
      core.plugins = _options.plugins || core.plugins;
      var mergeOptions = [options, _options].reduce(function (init, option) {
        var _loop2 = function _loop2() {
          if (!util.hasOwn(option, key)) return "continue";
          if (key === 'plugins' && option[key] && init[key]) {
            var i = init[key],
              o = option[key];
            i = i.length ? i : _w.Object.keys(i).map(function (name) {
              return i[name];
            });
            o = o.length ? o : _w.Object.keys(o).map(function (name) {
              return o[name];
            });
            init[key] = o.filter(function (val) {
              return i.indexOf(val) === -1;
            }).concat(i);
          } else {
            init[key] = option[key];
          }
        };
        for (var key in option) {
          var _ret2 = _loop2();
          if (_ret2 === "continue") continue;
        }
        return init;
      }, {});
      var el = context.element;
      var _initHTML = el.wysiwyg.innerHTML;

      // set option
      var cons = lib_constructor._setOptions(mergeOptions, context, options);
      if (cons.callButtons) {
        pluginCallButtons = cons.callButtons;
        core.initPlugins = {};
      }
      if (cons.plugins) {
        core.plugins = plugins = cons.plugins;
      }

      // reset context
      if (el._menuTray.children.length === 0) this._menuTray = {};
      _responsiveButtons = cons.toolbar.responsiveButtons;
      core.options = options = mergeOptions;
      core.lang = lang = options.lang;
      if (options.iframe) {
        el.wysiwygFrame.addEventListener('load', function () {
          util._setIframeDocument(this, options);
          core._setOptionsInit(el, _initHTML);
        });
      }
      el.editorArea.appendChild(el.wysiwygFrame);
      if (!options.iframe) {
        core._setOptionsInit(el, _initHTML);
      }
    },
    /**
     * @description Set "options.defaultStyle" style.
     * Define the style of the edit area
     * It can also be defined with the "setOptions" method, but the "setDefaultStyle" method does not render the editor again.
     * @param {String} style Style string
     */
    setDefaultStyle: function setDefaultStyle(style) {
      var newStyles = options._editorStyles = util._setDefaultOptionStyle(options, style);
      var el = context.element;

      // top area
      el.topArea.style.cssText = newStyles.top;
      // code view
      el.code.style.cssText = options._editorStyles.frame;
      el.code.style.display = 'none';
      if (options.height === 'auto') {
        el.code.style.overflow = 'hidden';
      } else {
        el.code.style.overflow = '';
      }
      // wysiwyg frame
      if (!options.iframe) {
        el.wysiwygFrame.style.cssText = newStyles.frame + newStyles.editor;
      } else {
        el.wysiwygFrame.style.cssText = newStyles.frame;
        el.wysiwyg.style.cssText = newStyles.editor;
      }
    },
    /**
     * @description Open a notice area
     * @param {String} message Notice message
     */
    noticeOpen: function noticeOpen(message) {
      core.notice.open.call(core, message);
    },
    /**
     * @description Close a notice area
     */
    noticeClose: function noticeClose() {
      core.notice.close.call(core);
    },
    /**
     * @description Copying the contents of the editor to the original textarea and execute onSave callback
     * * not working during enabled codeView mode
     */
    save: function save() {
      var contents = core.getContents(false);
      context.element.originElement.value = contents;
      event.onSave_wysiwyg(contents, core);
    },
    /**
     * @description Gets the suneditor's context object. Contains settings, plugins, and cached element objects
     * @returns {Object}
     */
    getContext: function getContext() {
      return context;
    },
    /**
     * @description Gets the contents of the suneditor
     * * not working during enabled codeView mode
     * @param {Boolean} onlyContents - Return only the contents of the body without headers when the "fullPage" option is true
     * @returns {String}
     */
    getContents: function getContents(onlyContents) {
      return core.getContents(onlyContents);
    },
    /**
     * @description Gets only the text of the suneditor contents
     * * not working during enabled codeView mode
     * @returns {String}
     */
    getText: function getText() {
      return context.element.wysiwyg.textContent;
    },
    /**
     * @description Get the editor's number of characters or binary data size.
     * You can use the "charCounterType" option format.
     * @param {String|null} charCounterType options - charCounterType ('char', 'byte', 'byte-html')
     * If argument is no value, the currently set "charCounterType" option is used.
     * @returns {Number}
     */
    getCharCount: function getCharCount(charCounterType) {
      charCounterType = typeof charCounterType === 'string' ? charCounterType : options.charCounterType;
      return core.getCharLength(core._charTypeHTML ? context.element.wysiwyg.innerHTML : context.element.wysiwyg.textContent, charCounterType);
    },
    /**
     * @description Gets uploaded images informations
     * - index: data index
     * - name: file name
     * - size: file size
     * - select: select function
     * - delete: delete function
     * - element: target element
     * - src: src attribute of tag
     * @returns {Array}
     */
    getImagesInfo: function getImagesInfo() {
      return context.image ? context.image._infoList : [];
    },
    /**
     * @description Gets uploaded files(plugin using fileManager) information list.
     * image: [img], video: [video, iframe], audio: [audio]
     * When the argument value is 'image', it is the same function as "getImagesInfo".
     * - index: data index
     * - name: file name
     * - size: file size
     * - select: select function
     * - delete: delete function
     * - element: target element
     * - src: src attribute of tag
     * @param {String} pluginName Plugin name (image, video, audio)
     * @returns {Array}
     */
    getFilesInfo: function getFilesInfo(pluginName) {
      return context[pluginName] ? context[pluginName]._infoList : [];
    },
    /**
     * @description Upload images using image plugin
     * @param {FileList} files FileList
     */
    insertImage: function insertImage(files) {
      if (!core.plugins.image || !files) return;
      if (!core.initPlugins.image) core.callPlugin('image', core.plugins.image.submitAction.bind(core, files), null);else core.plugins.image.submitAction.call(core, files);
      core.focus();
    },
    /**
     * @description Inserts an HTML element or HTML string or plain string at the current cursor position
     * @param {Element|String} html HTML Element or HTML string or plain string
     * @param {Boolean} notCleaningData If true, inserts the HTML string without refining it with core.cleanHTML.
     * @param {Boolean} checkCharCount If true, if "options.maxCharCount" is exceeded when "element" is added, null is returned without addition.
     * @param {Boolean} rangeSelection If true, range select the inserted node.
     */
    insertHTML: function insertHTML(html, notCleaningData, checkCharCount, rangeSelection) {
      if (!context.element.wysiwygFrame.contains(core.getSelection().focusNode)) core.focus();
      if (typeof html === 'string') {
        if (!notCleaningData) html = core.cleanHTML(html, null, null);
        try {
          if (util.isListCell(util.getFormatElement(core.getSelectionNode(), null))) {
            var _dom = _d.createRange().createContextualFragment(html);
            var _domTree = _dom.childNodes;
            if (core._isFormatData(_domTree)) html = core._convertListCell(_domTree);
          }
          var dom = _d.createRange().createContextualFragment(html);
          var domTree = dom.childNodes;
          if (checkCharCount) {
            var type = core._charTypeHTML ? 'outerHTML' : 'textContent';
            var checkHTML = '';
            for (var i = 0, len = domTree.length; i < len; i++) {
              checkHTML += domTree[i][type];
            }
            if (!core.checkCharCount(checkHTML, null)) return;
          }
          var c, a, t, prev, firstCon;
          while (c = domTree[0]) {
            if (prev && prev.nodeType === 3 && a && a.nodeType === 1 && util.isBreak(c)) {
              prev = c;
              util.removeItem(c);
              continue;
            }
            t = core.insertNode(c, a, false);
            a = t.container || t;
            if (!firstCon) firstCon = t;
            prev = c;
          }
          if (prev.nodeType === 3 && a.nodeType === 1) a = prev;
          var offset = a.nodeType === 3 ? t.endOffset || a.textContent.length : a.childNodes.length;
          if (rangeSelection) core.setRange(firstCon.container || firstCon, firstCon.startOffset || 0, a, offset);else core.setRange(a, offset, a, offset);
        } catch (error) {
          if (core.isDisabled || core.isReadOnly) return;
          console.warn('[SUNEDITOR.insertHTML.fail] ' + error);
          core.execCommand('insertHTML', false, html);
        }
      } else {
        if (util.isComponent(html)) {
          core.insertComponent(html, false, checkCharCount, false);
        } else {
          var afterNode = null;
          if (util.isFormatElement(html) || util.isMedia(html)) {
            afterNode = util.getFormatElement(core.getSelectionNode(), null);
          }
          core.insertNode(html, afterNode, checkCharCount);
        }
      }
      core.effectNode = null;
      core.focus();

      // history stack
      core.history.push(false);
    },
    /**
     * @description Change the contents of the suneditor
     * @param {String|undefined} contents Contents to Input
     */
    setContents: function setContents(contents) {
      core.setContents(contents);
    },
    /**
     * @description Add contents to the suneditor
     * @param {String} contents Contents to Input
     */
    appendContents: function appendContents(contents) {
      var convertValue = core.convertContentsForEditor(contents);
      if (!core._variable.isCodeView) {
        var temp = util.createElement('DIV');
        temp.innerHTML = convertValue;
        var wysiwyg = context.element.wysiwyg;
        var children = temp.children;
        for (var i = 0, len = children.length; i < len; i++) {
          if (children[i]) {
            wysiwyg.appendChild(children[i]);
          }
        }
      } else {
        core._setCodeView(core._getCodeView() + '\n' + core.convertHTMLForCodeView(convertValue, false));
      }

      // history stack
      core.history.push(false);
    },
    /**
     * @description Switch to or off "ReadOnly" mode.
     * @param {Boolean} value "readOnly" boolean value.
     */
    readOnly: function readOnly(value) {
      core.isReadOnly = value;
      util.setDisabledButtons(!!value, core.resizingDisabledButtons);
      if (value) {
        /** off menus */
        core.controllersOff();
        if (core.submenuActiveButton && core.submenuActiveButton.disabled) core.submenuOff();
        if (core._moreLayerActiveButton && core._moreLayerActiveButton.disabled) core.moreLayerOff();
        if (core.containerActiveButton && core.containerActiveButton.disabled) core.containerOff();
        if (core.modalForm) core.plugins.dialog.close.call(core);
        context.element.code.setAttribute("readOnly", "true");
        util.addClass(context.element.wysiwygFrame, 'se-read-only');
      } else {
        context.element.code.removeAttribute("readOnly");
        util.removeClass(context.element.wysiwygFrame, 'se-read-only');
      }
      if (options.codeMirrorEditor) options.codeMirrorEditor.setOption('readOnly', !!value);
    },
    /**
     * @description Disable the suneditor
     */
    disable: function disable() {
      this.toolbar.disable();
      this.wysiwyg.disable();
    },
    /**
     * @description Provided for backward compatibility and will be removed in 3.0.0 version
     */
    disabled: function disabled() {
      this.disable();
    },
    /**
     * @description Enable the suneditor
     */
    enable: function enable() {
      this.toolbar.enable();
      this.wysiwyg.enable();
    },
    /**
     * @description Provided for backward compatibility and will be removed in 3.0.0 version
     */
    enabled: function enabled() {
      this.enable();
    },
    /**
     * @description Show the suneditor
     */
    show: function show() {
      var topAreaStyle = context.element.topArea.style;
      if (topAreaStyle.display === 'none') topAreaStyle.display = options.display;
    },
    /**
     * @description Hide the suneditor
     */
    hide: function hide() {
      context.element.topArea.style.display = 'none';
    },
    /**
     * @description Destroy the suneditor
     */
    destroy: function destroy() {
      /** off menus */
      core.submenuOff();
      core.containerOff();
      core.controllersOff();
      if (core.notice) core.notice.close.call(core);
      if (core.modalForm) core.plugins.dialog.close.call(core);

      /** remove history */
      core.history._destroy();

      /** remove event listeners */
      event._removeEvent();

      /** remove element */
      util.removeItem(context.element.toolbar);
      util.removeItem(context.element.topArea);

      /** remove object reference */
      for (var k in core.functions) {
        if (util.hasOwn(core, k)) delete core.functions[k];
      }
      for (var _k2 in core) {
        if (util.hasOwn(core, _k2)) delete core[_k2];
      }
      for (var _k3 in event) {
        if (util.hasOwn(event, _k3)) delete event[_k3];
      }
      for (var _k4 in context) {
        if (util.hasOwn(context, _k4)) delete context[_k4];
      }
      for (var _k5 in pluginCallButtons) {
        if (util.hasOwn(pluginCallButtons, _k5)) delete pluginCallButtons[_k5];
      }

      /** remove user object */
      for (var _k6 in this) {
        if (util.hasOwn(this, _k6)) delete this[_k6];
      }
    },
    /**
     * @description Toolbar methods
     */
    toolbar: {
      /**
       * @description Disable the toolbar
       */
      disable: function disable() {
        /** off menus */
        core.submenuOff();
        core.moreLayerOff();
        core.containerOff();
        context.tool.cover.style.display = 'block';
      },
      /**
       * @description Provided for backward compatibility and will be removed in 3.0.0 version
       */
      disabled: function disabled() {
        this.disable();
      },
      /**
       * @description Enable the toolbar
       */
      enable: function enable() {
        context.tool.cover.style.display = 'none';
      },
      /**
       * @description Provided for backward compatibility and will be removed in 3.0.0 version
       */
      enabled: function enabled() {
        this.enable();
      },
      /**
       * @description Show the toolbar
       */
      show: function show() {
        if (core._isInline) {
          event._showToolbarInline();
        } else {
          context.element.toolbar.style.display = '';
          context.element._stickyDummy.style.display = '';
        }
      },
      /**
       * @description Hide the toolbar
       */
      hide: function hide() {
        if (core._isInline) {
          event._hideToolbar();
        } else {
          context.element.toolbar.style.display = 'none';
          context.element._stickyDummy.style.display = 'none';
        }
      }
    },
    /**
     * @description Wysiwyg methods
     */
    wysiwyg: {
      /**
       * @description Disable the wysiwyg area
       */
      disable: function disable() {
        /** off menus */
        core.controllersOff();
        if (core.modalForm) core.plugins.dialog.close.call(core);
        context.element.wysiwyg.setAttribute('contenteditable', false);
        core.isDisabled = true;
        if (options.codeMirrorEditor) {
          options.codeMirrorEditor.setOption('readOnly', true);
        } else {
          context.element.code.setAttribute('disabled', 'disabled');
        }
      },
      /**
       * @description Enable the wysiwyg area
       */
      enable: function enable() {
        context.element.wysiwyg.setAttribute('contenteditable', true);
        core.isDisabled = false;
        if (options.codeMirrorEditor) {
          options.codeMirrorEditor.setOption('readOnly', false);
        } else {
          context.element.code.removeAttribute('disabled');
        }
      }
    }
  };

  /************ Core init ************/
  // functions
  core.functions = functions;
  core.options = options;

  // Create to sibling node
  var contextEl = context.element;
  var originEl = contextEl.originElement;
  var topEl = contextEl.topArea;
  originEl.style.display = 'none';
  topEl.style.display = 'block';

  // init
  if (options.iframe) {
    contextEl.wysiwygFrame.addEventListener('load', function () {
      util._setIframeDocument(this, options);
      core._editorInit(false, options.value);
      options.value = null;
    });
  }

  // insert editor element
  if (typeof originEl.nextElementSibling === 'object') {
    originEl.parentNode.insertBefore(topEl, originEl.nextElementSibling);
  } else {
    originEl.parentNode.appendChild(topEl);
  }
  contextEl.editorArea.appendChild(contextEl.wysiwygFrame);
  contextEl = originEl = topEl = null;

  // init
  if (!options.iframe) {
    core._editorInit(false, options.value);
    options.value = null;
  }
  return functions;
});
// CONCATENATED MODULE: ./node_modules/suneditor/src/suneditor.js
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2017 JiHong Lee.
 * MIT license.
 */






/* harmony default export */ var suneditor = __webpack_exports__["default"] = ({
  /**
   * @description Returns the create function with preset options.
   * If the options overlap, the options of the 'create' function take precedence.
   * @param {Json} options Initialization options
   * @returns {Object}
   */
  init: function init(init_options) {
    return {
      create: function (idOrElement, options) {
        return this.create(idOrElement, options, init_options);
      }.bind(this)
    };
  },
  /**
   * @description Create the suneditor
   * @param {String|Element} idOrElement textarea Id or textarea element
   * @param {JSON|Object} options user options
   * @returns {Object}
   */
  create: function create(idOrElement, options, _init_options) {
    lib_util._propertiesInit();
    if (typeof options !== 'object') options = {};
    if (_init_options) {
      options = [_init_options, options].reduce(function (init, option) {
        var _loop = function _loop() {
          if (!lib_util.hasOwn(option, key)) return "continue";
          if (key === 'plugins' && option[key] && init[key]) {
            var i = init[key],
              o = option[key];
            i = i.length ? i : Object.keys(i).map(function (name) {
              return i[name];
            });
            o = o.length ? o : Object.keys(o).map(function (name) {
              return o[name];
            });
            init[key] = o.filter(function (val) {
              return i.indexOf(val) === -1;
            }).concat(i);
          } else {
            init[key] = option[key];
          }
        };
        for (var key in option) {
          var _ret = _loop();
          if (_ret === "continue") continue;
        }
        return init;
      }, {});
    }
    var element = typeof idOrElement === 'string' ? document.getElementById(idOrElement) : idOrElement;
    if (!element) {
      if (typeof idOrElement === 'string') {
        throw Error('[SUNEDITOR.create.fail] The element for that id was not found (ID:"' + idOrElement + '")');
      }
      throw Error('[SUNEDITOR.create.fail] suneditor requires textarea\'s element or id value');
    }
    var cons = lib_constructor.init(element, options);
    if (cons.constructed._top.id && document.getElementById(cons.constructed._top.id)) {
      throw Error('[SUNEDITOR.create.fail] The ID of the suneditor you are trying to create already exists (ID:"' + cons.constructed._top.id + '")');
    }
    return lib_core(lib_context(element, cons.constructed, cons.options), cons.pluginCallButtons, cons.plugins, cons.options.lang, options, cons._responsiveButtons);
  }
});

/***/ }),

/***/ 533:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2017 JiHong Lee.
 * MIT license.
 */


(function (global, factory) {
  if ( true && typeof module.exports === 'object') {
    module.exports = global.document ? factory(global, true) : function (w) {
      if (!w.document) {
        throw new Error('SUNEDITOR_MODULES a window with a document');
      }
      return factory(w);
    };
  } else {
    factory(global);
  }
})(typeof window !== 'undefined' ? window : this, function (window, noGlobal) {
  var dialog = {
    name: 'dialog',
    /**
     * @description Constructor
     * @param {Object} core Core object 
     */
    add: function add(core) {
      var context = core.context;
      context.dialog = {
        kind: '',
        updateModal: false,
        _closeSignal: false
      };

      /** dialog */
      var dialog_div = core.util.createElement('DIV');
      dialog_div.className = 'se-dialog sun-editor-common';
      var dialog_back = core.util.createElement('DIV');
      dialog_back.className = 'se-dialog-back';
      dialog_back.style.display = 'none';
      var dialog_area = core.util.createElement('DIV');
      dialog_area.className = 'se-dialog-inner';
      dialog_area.style.display = 'none';
      dialog_div.appendChild(dialog_back);
      dialog_div.appendChild(dialog_area);
      context.dialog.modalArea = dialog_div;
      context.dialog.back = dialog_back;
      context.dialog.modal = dialog_area;

      /** add event listeners */
      context.dialog.modal.addEventListener('mousedown', this._onMouseDown_dialog.bind(core));
      context.dialog.modal.addEventListener('click', this._onClick_dialog.bind(core));

      /** append html */
      context.element.relative.appendChild(dialog_div);

      /** empty memory */
      dialog_div = null, dialog_back = null, dialog_area = null;
    },
    /**
     * @description Event to control the behavior of closing the dialog
     * @param {MouseEvent} e Event object
     * @private
     */
    _onMouseDown_dialog: function _onMouseDown_dialog(e) {
      if (/se-dialog-inner/.test(e.target.className)) {
        this.context.dialog._closeSignal = true;
      } else {
        this.context.dialog._closeSignal = false;
      }
    },
    /**
     * @description Event to close the window when the outside area of the dialog or close button is click
     * @param {MouseEvent} e Event object
     * @private
     */
    _onClick_dialog: function _onClick_dialog(e) {
      if (/close/.test(e.target.getAttribute('data-command')) || this.context.dialog._closeSignal) {
        this.plugins.dialog.close.call(this);
      }
    },
    /**
     * @description Open a Dialog plugin
     * @param {String} kind Dialog plugin name
     * @param {Boolean} update Whether it will open for update ('image' === this.currentControllerName)
     */
    open: function open(kind, update) {
      if (this.modalForm) return false;
      if (this.plugins.dialog._bindClose) {
        this._d.removeEventListener('keydown', this.plugins.dialog._bindClose);
        this.plugins.dialog._bindClose = null;
      }
      this.plugins.dialog._bindClose = function (e) {
        if (!/27/.test(e.keyCode)) return;
        this.plugins.dialog.close.call(this);
      }.bind(this);
      this._d.addEventListener('keydown', this.plugins.dialog._bindClose);
      this.context.dialog.updateModal = update;
      if (this.options.popupDisplay === 'full') {
        this.context.dialog.modalArea.style.position = 'fixed';
      } else {
        this.context.dialog.modalArea.style.position = 'absolute';
      }
      this.context.dialog.kind = kind;
      this.modalForm = this.context[kind].modal;
      var focusElement = this.context[kind].focusElement;
      if (typeof this.plugins[kind].on === 'function') this.plugins[kind].on.call(this, update);
      this.context.dialog.modalArea.style.display = 'block';
      this.context.dialog.back.style.display = 'block';
      this.context.dialog.modal.style.display = 'block';
      this.modalForm.style.display = 'block';
      if (focusElement) focusElement.focus();
    },
    _bindClose: null,
    /**
     * @description Close a Dialog plugin
     * The plugin's "init" method is called.
     */
    close: function close() {
      if (this.plugins.dialog._bindClose) {
        this._d.removeEventListener('keydown', this.plugins.dialog._bindClose);
        this.plugins.dialog._bindClose = null;
      }
      var kind = this.context.dialog.kind;
      this.modalForm.style.display = 'none';
      this.context.dialog.back.style.display = 'none';
      this.context.dialog.modalArea.style.display = 'none';
      this.context.dialog.updateModal = false;
      if (typeof this.plugins[kind].init === 'function') this.plugins[kind].init.call(this);
      this.context.dialog.kind = '';
      this.modalForm = null;
      this.focus();
    }
  };
  if (typeof noGlobal === typeof undefined) {
    if (!window.SUNEDITOR_MODULES) {
      Object.defineProperty(window, 'SUNEDITOR_MODULES', {
        enumerable: true,
        writable: false,
        configurable: false,
        value: {}
      });
    }
    Object.defineProperty(window.SUNEDITOR_MODULES, 'dialog', {
      enumerable: true,
      writable: false,
      configurable: false,
      value: dialog
    });
  }
  return dialog;
});

/***/ }),

/***/ 707:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2017 JiHong Lee.
 * MIT license.
 */


(function (global, factory) {
  if ( true && typeof module.exports === 'object') {
    module.exports = global.document ? factory(global, true) : function (w) {
      if (!w.document) {
        throw new Error('SUNEDITOR_LANG a window with a document');
      }
      return factory(w);
    };
  } else {
    factory(global);
  }
})(typeof window !== 'undefined' ? window : this, function (window, noGlobal) {
  var lang = {
    code: 'en',
    toolbar: {
      default: 'Default',
      save: 'Save',
      font: 'Font',
      formats: 'Formats',
      fontSize: 'Size',
      bold: 'Bold',
      underline: 'Underline',
      italic: 'Italic',
      strike: 'Strike',
      subscript: 'Subscript',
      superscript: 'Superscript',
      removeFormat: 'Remove Format',
      fontColor: 'Font Color',
      hiliteColor: 'Highlight Color',
      indent: 'Indent',
      outdent: 'Outdent',
      align: 'Align',
      alignLeft: 'Align left',
      alignRight: 'Align right',
      alignCenter: 'Align center',
      alignJustify: 'Align justify',
      list: 'List',
      orderList: 'Ordered list',
      unorderList: 'Unordered list',
      horizontalRule: 'Horizontal line',
      hr_solid: 'Solid',
      hr_dotted: 'Dotted',
      hr_dashed: 'Dashed',
      table: 'Table',
      link: 'Link',
      math: 'Math',
      image: 'Image',
      video: 'Video',
      audio: 'Audio',
      fullScreen: 'Full screen',
      showBlocks: 'Show blocks',
      codeView: 'Code view',
      undo: 'Undo',
      redo: 'Redo',
      preview: 'Preview',
      print: 'print',
      tag_p: 'Paragraph',
      tag_div: 'Normal (DIV)',
      tag_h: 'Header',
      tag_blockquote: 'Quote',
      tag_pre: 'Code',
      template: 'Template',
      lineHeight: 'Line height',
      paragraphStyle: 'Paragraph style',
      textStyle: 'Text style',
      imageGallery: 'Image gallery',
      dir_ltr: 'Left to right',
      dir_rtl: 'Right to left',
      mention: 'Mention'
    },
    dialogBox: {
      linkBox: {
        title: 'Insert Link',
        url: 'URL to link',
        text: 'Text to display',
        newWindowCheck: 'Open in new window',
        downloadLinkCheck: 'Download link',
        bookmark: 'Bookmark'
      },
      mathBox: {
        title: 'Math',
        inputLabel: 'Mathematical Notation',
        fontSizeLabel: 'Font Size',
        previewLabel: 'Preview'
      },
      imageBox: {
        title: 'Insert image',
        file: 'Select from files',
        url: 'Image URL',
        altText: 'Alternative text'
      },
      videoBox: {
        title: 'Insert Video',
        file: 'Select from files',
        url: 'Media embed URL, YouTube/Vimeo'
      },
      audioBox: {
        title: 'Insert Audio',
        file: 'Select from files',
        url: 'Audio URL'
      },
      browser: {
        tags: 'Tags',
        search: 'Search'
      },
      caption: 'Insert description',
      close: 'Close',
      submitButton: 'Submit',
      revertButton: 'Revert',
      proportion: 'Constrain proportions',
      basic: 'Basic',
      left: 'Left',
      right: 'Right',
      center: 'Center',
      width: 'Width',
      height: 'Height',
      size: 'Size',
      ratio: 'Ratio'
    },
    controller: {
      edit: 'Edit',
      unlink: 'Unlink',
      remove: 'Remove',
      insertRowAbove: 'Insert row above',
      insertRowBelow: 'Insert row below',
      deleteRow: 'Delete row',
      insertColumnBefore: 'Insert column before',
      insertColumnAfter: 'Insert column after',
      deleteColumn: 'Delete column',
      fixedColumnWidth: 'Fixed column width',
      resize100: 'Resize 100%',
      resize75: 'Resize 75%',
      resize50: 'Resize 50%',
      resize25: 'Resize 25%',
      autoSize: 'Auto size',
      mirrorHorizontal: 'Mirror, Horizontal',
      mirrorVertical: 'Mirror, Vertical',
      rotateLeft: 'Rotate left',
      rotateRight: 'Rotate right',
      maxSize: 'Max size',
      minSize: 'Min size',
      tableHeader: 'Table header',
      mergeCells: 'Merge cells',
      splitCells: 'Split Cells',
      HorizontalSplit: 'Horizontal split',
      VerticalSplit: 'Vertical split'
    },
    menu: {
      spaced: 'Spaced',
      bordered: 'Bordered',
      neon: 'Neon',
      translucent: 'Translucent',
      shadow: 'Shadow',
      code: 'Code'
    }
  };
  if (typeof noGlobal === typeof undefined) {
    if (!window.SUNEDITOR_LANG) {
      Object.defineProperty(window, 'SUNEDITOR_LANG', {
        enumerable: true,
        writable: false,
        configurable: false,
        value: {}
      });
    }
    Object.defineProperty(window.SUNEDITOR_LANG, 'en', {
      enumerable: true,
      writable: true,
      configurable: true,
      value: lang
    });
  }
  return lang;
});

/***/ }),

/***/ 708:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, "blockquote", function() { return /* reexport */ blockquote; });
__webpack_require__.d(__webpack_exports__, "align", function() { return /* reexport */ align; });
__webpack_require__.d(__webpack_exports__, "font", function() { return /* reexport */ font; });
__webpack_require__.d(__webpack_exports__, "fontSize", function() { return /* reexport */ fontSize; });
__webpack_require__.d(__webpack_exports__, "fontColor", function() { return /* reexport */ fontColor; });
__webpack_require__.d(__webpack_exports__, "hiliteColor", function() { return /* reexport */ hiliteColor; });
__webpack_require__.d(__webpack_exports__, "horizontalRule", function() { return /* reexport */ horizontalRule; });
__webpack_require__.d(__webpack_exports__, "list", function() { return /* reexport */ list; });
__webpack_require__.d(__webpack_exports__, "table", function() { return /* reexport */ table; });
__webpack_require__.d(__webpack_exports__, "formatBlock", function() { return /* reexport */ formatBlock; });
__webpack_require__.d(__webpack_exports__, "lineHeight", function() { return /* reexport */ lineHeight; });
__webpack_require__.d(__webpack_exports__, "template", function() { return /* reexport */ template; });
__webpack_require__.d(__webpack_exports__, "paragraphStyle", function() { return /* reexport */ paragraphStyle; });
__webpack_require__.d(__webpack_exports__, "textStyle", function() { return /* reexport */ textStyle; });
__webpack_require__.d(__webpack_exports__, "link", function() { return /* reexport */ dialog_link; });
__webpack_require__.d(__webpack_exports__, "image", function() { return /* reexport */ dialog_image; });
__webpack_require__.d(__webpack_exports__, "video", function() { return /* reexport */ video; });
__webpack_require__.d(__webpack_exports__, "audio", function() { return /* reexport */ audio; });
__webpack_require__.d(__webpack_exports__, "math", function() { return /* reexport */ math; });
__webpack_require__.d(__webpack_exports__, "imageGallery", function() { return /* reexport */ imageGallery; });

// CONCATENATED MODULE: ./node_modules/suneditor/src/plugins/command/blockquote.js
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2017 JiHong Lee.
 * MIT license.
 */


/* harmony default export */ var blockquote = ({
  name: 'blockquote',
  display: 'command',
  add: function add(core, targetElement) {
    var context = core.context;
    context.blockquote = {
      targetButton: targetElement,
      tag: core.util.createElement('BLOCKQUOTE')
    };
  },
  /**
   * @Override core
   */
  active: function active(element) {
    if (!element) {
      this.util.removeClass(this.context.blockquote.targetButton, 'active');
    } else if (/blockquote/i.test(element.nodeName)) {
      this.util.addClass(this.context.blockquote.targetButton, 'active');
      return true;
    }
    return false;
  },
  /**
   * @Override core
   */
  action: function action() {
    var currentBlockquote = this.util.getParentElement(this.getSelectionNode(), 'blockquote');
    if (currentBlockquote) {
      this.detachRangeFormatElement(currentBlockquote, null, null, false, false);
    } else {
      this.applyRangeFormatElement(this.context.blockquote.tag.cloneNode(false));
    }
  }
});
// CONCATENATED MODULE: ./node_modules/suneditor/src/plugins/submenu/align.js
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2017 JiHong Lee.
 * MIT license.
 */


/* harmony default export */ var align = ({
  name: 'align',
  display: 'submenu',
  add: function add(core, targetElement) {
    var icons = core.icons;
    var context = core.context;
    context.align = {
      targetButton: targetElement,
      _itemMenu: null,
      _alignList: null,
      currentAlign: '',
      defaultDir: core.options.rtl ? 'right' : 'left',
      icons: {
        justify: icons.align_justify,
        left: icons.align_left,
        right: icons.align_right,
        center: icons.align_center
      }
    };

    /** set submenu */
    var listDiv = this.setSubmenu(core);
    var listUl = context.align._itemMenu = listDiv.querySelector('ul');

    /** add event listeners */
    listUl.addEventListener('click', this.pickup.bind(core));
    context.align._alignList = listUl.querySelectorAll('li button');

    /** append target button menu */
    core.initMenuTarget(this.name, targetElement, listDiv);

    /** empty memory */
    listDiv = null, listUl = null;
  },
  setSubmenu: function setSubmenu(core) {
    var lang = core.lang;
    var icons = core.icons;
    var listDiv = core.util.createElement('DIV');
    var alignItems = core.options.alignItems;
    var html = '';
    for (var i = 0, item, text; i < alignItems.length; i++) {
      item = alignItems[i];
      text = lang.toolbar['align' + item.charAt(0).toUpperCase() + item.slice(1)];
      html += '<li>' + '<button type="button" class="se-btn-list se-btn-align" data-value="' + item + '" title="' + text + '" aria-label="' + text + '">' + '<span class="se-list-icon">' + icons['align_' + item] + '</span>' + text + '</button>' + '</li>';
    }
    listDiv.className = 'se-submenu se-list-layer se-list-align';
    listDiv.innerHTML = '' + '<div class="se-list-inner">' + '<ul class="se-list-basic">' + html + '</ul>' + '</div>';
    return listDiv;
  },
  /**
   * @Override core
   */
  active: function active(element) {
    var alignContext = this.context.align;
    var targetButton = alignContext.targetButton;
    var target = targetButton.firstElementChild;
    if (!element) {
      this.util.changeElement(target, alignContext.icons[alignContext.defaultDir]);
      targetButton.removeAttribute('data-focus');
    } else if (this.util.isFormatElement(element)) {
      var textAlign = element.style.textAlign;
      if (textAlign) {
        this.util.changeElement(target, alignContext.icons[textAlign] || alignContext.icons[alignContext.defaultDir]);
        targetButton.setAttribute('data-focus', textAlign);
        return true;
      }
    }
    return false;
  },
  /**
   * @Override submenu
   */
  on: function on() {
    var alignContext = this.context.align;
    var alignList = alignContext._alignList;
    var currentAlign = alignContext.targetButton.getAttribute('data-focus') || alignContext.defaultDir;
    if (currentAlign !== alignContext.currentAlign) {
      for (var i = 0, len = alignList.length; i < len; i++) {
        if (currentAlign === alignList[i].getAttribute('data-value')) {
          this.util.addClass(alignList[i], 'active');
        } else {
          this.util.removeClass(alignList[i], 'active');
        }
      }
      alignContext.currentAlign = currentAlign;
    }
  },
  exchangeDir: function exchangeDir() {
    var dir = this.options.rtl ? 'right' : 'left';
    if (!this.context.align || this.context.align.defaultDir === dir) return;
    this.context.align.defaultDir = dir;
    var menu = this.context.align._itemMenu;
    var leftBtn = menu.querySelector('[data-value="left"]');
    var rightBtn = menu.querySelector('[data-value="right"]');
    if (leftBtn && rightBtn) {
      var lp = leftBtn.parentElement;
      var rp = rightBtn.parentElement;
      lp.appendChild(rightBtn);
      rp.appendChild(leftBtn);
    }
  },
  pickup: function pickup(e) {
    e.preventDefault();
    e.stopPropagation();
    var target = e.target;
    var value = null;
    while (!value && !/UL/i.test(target.tagName)) {
      value = target.getAttribute('data-value');
      target = target.parentNode;
    }
    if (!value) return;
    var defaultDir = this.context.align.defaultDir;
    var selectedFormsts = this.getSelectedElements();
    for (var i = 0, len = selectedFormsts.length; i < len; i++) {
      this.util.setStyle(selectedFormsts[i], 'textAlign', value === defaultDir ? '' : value);
    }
    this.effectNode = null;
    this.submenuOff();
    this.focus();

    // history stack
    this.history.push(false);
  }
});
// CONCATENATED MODULE: ./node_modules/suneditor/src/plugins/submenu/font.js
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2017 JiHong Lee.
 * MIT license.
 */


/* harmony default export */ var font = ({
  name: 'font',
  display: 'submenu',
  add: function add(core, targetElement) {
    var context = core.context;
    context.font = {
      targetText: targetElement.querySelector('.txt'),
      targetTooltip: targetElement.parentNode.querySelector('.se-tooltip-text'),
      _fontList: null,
      currentFont: ''
    };

    /** set submenu */
    var listDiv = this.setSubmenu(core);

    /** add event listeners */
    listDiv.querySelector('.se-list-inner').addEventListener('click', this.pickup.bind(core));
    context.font._fontList = listDiv.querySelectorAll('ul li button');

    /** append target button menu */
    core.initMenuTarget(this.name, targetElement, listDiv);

    /** empty memory */
    listDiv = null;
  },
  setSubmenu: function setSubmenu(core) {
    var lang = core.lang;
    var listDiv = core.util.createElement('DIV');
    listDiv.className = 'se-submenu se-list-layer se-list-font-family';
    var font, text, i, len;
    var fontList = core.options.font;
    var list = '<div class="se-list-inner">' + '<ul class="se-list-basic">' + '<li><button type="button" class="default_value se-btn-list" title="' + lang.toolbar.default + '" aria-label="' + lang.toolbar.default + '">(' + lang.toolbar.default + ')</button></li>';
    for (i = 0, len = fontList.length; i < len; i++) {
      font = fontList[i];
      text = font.split(',')[0];
      list += '<li><button type="button" class="se-btn-list" data-value="' + font + '" data-txt="' + text + '" title="' + text + '" aria-label="' + text + '" style="font-family:' + font + ';">' + text + '</button></li>';
    }
    list += '</ul></div>';
    listDiv.innerHTML = list;
    return listDiv;
  },
  /**
  * @Override core
  */
  active: function active(element) {
    var target = this.context.font.targetText;
    var tooltip = this.context.font.targetTooltip;
    if (!element) {
      var font = this.hasFocus ? this.wwComputedStyle.fontFamily : this.lang.toolbar.font;
      this.util.changeTxt(target, font);
      this.util.changeTxt(tooltip, this.hasFocus ? this.lang.toolbar.font + (font ? ' (' + font + ')' : '') : font);
    } else if (element.style && element.style.fontFamily.length > 0) {
      var selectFont = element.style.fontFamily.replace(/["']/g, '');
      this.util.changeTxt(target, selectFont);
      this.util.changeTxt(tooltip, this.lang.toolbar.font + ' (' + selectFont + ')');
      return true;
    }
    return false;
  },
  /**
  * @Override submenu
  */
  on: function on() {
    var fontContext = this.context.font;
    var fontList = fontContext._fontList;
    var currentFont = fontContext.targetText.textContent;
    if (currentFont !== fontContext.currentFont) {
      for (var i = 0, len = fontList.length; i < len; i++) {
        if (currentFont === fontList[i].getAttribute('data-value')) {
          this.util.addClass(fontList[i], 'active');
        } else {
          this.util.removeClass(fontList[i], 'active');
        }
      }
      fontContext.currentFont = currentFont;
    }
  },
  pickup: function pickup(e) {
    if (!/^BUTTON$/i.test(e.target.tagName)) return false;
    e.preventDefault();
    e.stopPropagation();
    var value = e.target.getAttribute('data-value');
    if (value) {
      var newNode = this.util.createElement('SPAN');
      newNode.style.fontFamily = value;
      this.nodeChange(newNode, ['font-family'], null, null);
    } else {
      this.nodeChange(null, ['font-family'], ['span'], true);
    }
    this.submenuOff();
  }
});
// CONCATENATED MODULE: ./node_modules/suneditor/src/plugins/submenu/fontSize.js
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2017 JiHong Lee.
 * MIT license.
 */


/* harmony default export */ var fontSize = ({
  name: 'fontSize',
  display: 'submenu',
  add: function add(core, targetElement) {
    var context = core.context;
    context.fontSize = {
      targetText: targetElement.querySelector('.txt'),
      _sizeList: null,
      currentSize: ''
    };

    /** set submenu */
    var listDiv = this.setSubmenu(core);
    var listUl = listDiv.querySelector('ul');

    /** add event listeners */
    listUl.addEventListener('click', this.pickup.bind(core));
    context.fontSize._sizeList = listUl.querySelectorAll('li button');

    /** append target button menu */
    core.initMenuTarget(this.name, targetElement, listDiv);

    /** empty memory */
    listDiv = null, listUl = null;
  },
  setSubmenu: function setSubmenu(core) {
    var option = core.options;
    var lang = core.lang;
    var listDiv = core.util.createElement('DIV');
    listDiv.className = 'se-submenu se-list-layer se-list-font-size';
    var sizeList = !option.fontSize ? [8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28, 36, 48, 72] : option.fontSize;
    var list = '<div class="se-list-inner">' + '<ul class="se-list-basic">' + '<li><button type="button" class="default_value se-btn-list" title="' + lang.toolbar.default + '" aria-label="' + lang.toolbar.default + '">(' + lang.toolbar.default + ')</button></li>';
    for (var i = 0, unit = option.fontSizeUnit, len = sizeList.length, size; i < len; i++) {
      size = sizeList[i];
      list += '<li><button type="button" class="se-btn-list" data-value="' + size + unit + '" title="' + size + unit + '" aria-label="' + size + unit + '" style="font-size:' + size + unit + ';">' + size + '</button></li>';
    }
    list += '</ul></div>';
    listDiv.innerHTML = list;
    return listDiv;
  },
  /**
  * @Override core
  */
  active: function active(element) {
    if (!element) {
      this.util.changeTxt(this.context.fontSize.targetText, this.hasFocus ? this.options.__defaultFontSize || this.wwComputedStyle.fontSize : this.lang.toolbar.fontSize);
    } else if (element.style && element.style.fontSize.length > 0) {
      this.util.changeTxt(this.context.fontSize.targetText, element.style.fontSize);
      return true;
    }
    return false;
  },
  /**
  * @Override submenu
  */
  on: function on() {
    var fontSizeContext = this.context.fontSize;
    var sizeList = fontSizeContext._sizeList;
    var currentSize = fontSizeContext.targetText.textContent;
    if (currentSize !== fontSizeContext.currentSize) {
      for (var i = 0, len = sizeList.length; i < len; i++) {
        if (currentSize === sizeList[i].getAttribute('data-value')) {
          this.util.addClass(sizeList[i], 'active');
        } else {
          this.util.removeClass(sizeList[i], 'active');
        }
      }
      fontSizeContext.currentSize = currentSize;
    }
  },
  pickup: function pickup(e) {
    if (!/^BUTTON$/i.test(e.target.tagName)) return false;
    e.preventDefault();
    e.stopPropagation();
    var value = e.target.getAttribute('data-value');
    if (value) {
      var newNode = this.util.createElement('SPAN');
      newNode.style.fontSize = value;
      this.nodeChange(newNode, ['font-size'], null, null);
    } else {
      this.nodeChange(null, ['font-size'], ['span'], true);
    }
    this.submenuOff();
  }
});
// CONCATENATED MODULE: ./node_modules/suneditor/src/plugins/modules/_colorPicker.js
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2018 JiHong Lee.
 * MIT license.
 */


/* harmony default export */ var _colorPicker = ({
  name: 'colorPicker',
  /**
   * @description Constructor
   * @param {Object} core Core object 
   */
  add: function add(core) {
    var context = core.context;
    context.colorPicker = {
      colorListHTML: '',
      _colorInput: '',
      _defaultColor: '#000',
      _styleProperty: 'color',
      _currentColor: '',
      _colorList: []
    };

    /** set submenu */
    context.colorPicker.colorListHTML = this.createColorList(core, this._makeColorList);
  },
  /**
   * @description Create color list
   * @param {Object} core Core object 
   * @param {Function} makeColor this._makeColorList
   * @returns {String} HTML string
   */
  createColorList: function createColorList(core, makeColor) {
    var option = core.options;
    var lang = core.lang;
    var colorList = !option.colorList || option.colorList.length === 0 ? ['#ff0000', '#ff5e00', '#ffe400', '#abf200', '#00d8ff', '#0055ff', '#6600ff', '#ff00dd', '#000000', '#ffd8d8', '#fae0d4', '#faf4c0', '#e4f7ba', '#d4f4fa', '#d9e5ff', '#e8d9ff', '#ffd9fa', '#f1f1f1', '#ffa7a7', '#ffc19e', '#faed7d', '#cef279', '#b2ebf4', '#b2ccff', '#d1b2ff', '#ffb2f5', '#bdbdbd', '#f15f5f', '#f29661', '#e5d85c', '#bce55c', '#5cd1e5', '#6699ff', '#a366ff', '#f261df', '#8c8c8c', '#980000', '#993800', '#998a00', '#6b9900', '#008299', '#003399', '#3d0099', '#990085', '#353535', '#670000', '#662500', '#665c00', '#476600', '#005766', '#002266', '#290066', '#660058', '#222222'] : option.colorList;
    var colorArr = [];
    var list = '<div class="se-list-inner">';
    for (var i = 0, len = colorList.length, color; i < len; i++) {
      color = colorList[i];
      if (!color) continue;
      if (typeof color === 'string') {
        colorArr.push(color);
        if (i < len - 1) continue;
      }
      if (colorArr.length > 0) {
        list += '<div class="se-selector-color">' + makeColor(colorArr) + '</div>';
        colorArr = [];
      }
      if (typeof color === 'object') {
        list += '<div class="se-selector-color">' + makeColor(color) + '</div>';
      }
    }
    list += '' + '<form class="se-form-group">' + '<input type="text" maxlength="9" class="_se_color_picker_input se-color-input"/>' + '<button type="submit" class="se-btn-primary _se_color_picker_submit" title="' + lang.dialogBox.submitButton + '" aria-label="' + lang.dialogBox.submitButton + '">' + core.icons.checked + '</button>' + '<button type="button" class="se-btn _se_color_picker_remove" title="' + lang.toolbar.removeFormat + '" aria-label="' + lang.toolbar.removeFormat + '">' + core.icons.erase + '</button>' + '</form>' + '</div>';
    return list;
  },
  /**
   * @description Internal function used by this.createColorList
   * @param {Array} colorList Color list
   * @private
   */
  _makeColorList: function _makeColorList(colorList) {
    var list = '';
    list += '<ul class="se-color-pallet">';
    for (var i = 0, len = colorList.length, color; i < len; i++) {
      color = colorList[i];
      if (typeof color === 'string') {
        list += '<li>' + '<button type="button" data-value="' + color + '" title="' + color + '" aria-label="' + color + '" style="background-color:' + color + ';"></button>' + '</li>';
      }
    }
    list += '</ul>';
    return list;
  },
  /**
   * @description Displays or resets the currently selected color at color list.
   * @param {Node} node Current Selected node
   * @param {String|null} color Color value
   */
  init: function init(node, color) {
    var colorPicker = this.plugins.colorPicker;
    var fillColor = color ? color : colorPicker.getColorInNode.call(this, node) || this.context.colorPicker._defaultColor;
    fillColor = colorPicker.isHexColor(fillColor) ? fillColor : colorPicker.rgb2hex(fillColor) || fillColor;
    var colorList = this.context.colorPicker._colorList;
    if (colorList) {
      for (var i = 0, len = colorList.length; i < len; i++) {
        if (fillColor.toLowerCase() === colorList[i].getAttribute('data-value').toLowerCase()) {
          this.util.addClass(colorList[i], 'active');
        } else {
          this.util.removeClass(colorList[i], 'active');
        }
      }
    }
    colorPicker.setInputText.call(this, colorPicker.colorName2hex.call(this, fillColor));
  },
  /**
   * @description Store color values
   * @param {String} hexColorStr Hax color value
   */
  setCurrentColor: function setCurrentColor(hexColorStr) {
    this.context.colorPicker._currentColor = hexColorStr;
    this.context.colorPicker._colorInput.style.borderColor = hexColorStr;
  },
  /**
   * @description Set color at input element
   * @param {String} hexColorStr Hax color value
   */
  setInputText: function setInputText(hexColorStr) {
    hexColorStr = /^#/.test(hexColorStr) ? hexColorStr : '#' + hexColorStr;
    this.context.colorPicker._colorInput.value = hexColorStr;
    this.plugins.colorPicker.setCurrentColor.call(this, hexColorStr);
  },
  /**
   * @description Gets color value at color property of node
   * @param {Node} node Selected node 
   * @returns {String}
   */
  getColorInNode: function getColorInNode(node) {
    var findColor = '';
    var styleProperty = this.context.colorPicker._styleProperty;
    while (node && !this.util.isWysiwygDiv(node) && findColor.length === 0) {
      if (node.nodeType === 1 && node.style[styleProperty]) findColor = node.style[styleProperty];
      node = node.parentNode;
    }
    return findColor;
  },
  /**
   * @description Function to check hex format color
   * @param {String} str Color value
   */
  isHexColor: function isHexColor(str) {
    return /^#[0-9a-f]{3}(?:[0-9a-f]{3})?$/i.test(str);
  },
  /**
   * @description Function to convert hex format to a rgb color
   * @param {String} rgb RGB color format
   * @returns {String}
   */
  rgb2hex: function rgb2hex(rgb) {
    var rgbMatch = rgb.match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i);
    return rgbMatch && rgbMatch.length === 4 ? "#" + ("0" + parseInt(rgbMatch[1], 10).toString(16)).slice(-2) + ("0" + parseInt(rgbMatch[2], 10).toString(16)).slice(-2) + ("0" + parseInt(rgbMatch[3], 10).toString(16)).slice(-2) : '';
  },
  /**
   * @description Converts color values of other formats to hex color values and returns.
   * @param {String} colorName Color value
   * @returns {String}
   */
  colorName2hex: function colorName2hex(colorName) {
    if (/^#/.test(colorName)) return colorName;
    var temp = this.util.createElement('div');
    temp.style.display = 'none';
    temp.style.color = colorName;
    var colors = this._w.getComputedStyle(this._d.body.appendChild(temp)).color.match(/\d+/g).map(function (a) {
      return parseInt(a, 10);
    });
    this.util.removeItem(temp);
    return colors.length >= 3 ? '#' + ((1 << 24) + (colors[0] << 16) + (colors[1] << 8) + colors[2]).toString(16).substr(1) : false;
  }
});
// CONCATENATED MODULE: ./node_modules/suneditor/src/plugins/submenu/fontColor.js
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2017 JiHong Lee.
 * MIT license.
 */



/* harmony default export */ var fontColor = ({
  name: 'fontColor',
  display: 'submenu',
  add: function add(core, targetElement) {
    core.addModule([_colorPicker]);
    var context = core.context;
    context.fontColor = {
      previewEl: null,
      colorInput: null,
      colorList: null
    };

    /** set submenu */
    var listDiv = this.setSubmenu(core);
    context.fontColor.colorInput = listDiv.querySelector('._se_color_picker_input');

    /** add event listeners */
    context.fontColor.colorInput.addEventListener('keyup', this.onChangeInput.bind(core));
    listDiv.querySelector('._se_color_picker_submit').addEventListener('click', this.submit.bind(core));
    listDiv.querySelector('._se_color_picker_remove').addEventListener('click', this.remove.bind(core));
    listDiv.addEventListener('click', this.pickup.bind(core));
    context.fontColor.colorList = listDiv.querySelectorAll('li button');

    /** append target button menu */
    core.initMenuTarget(this.name, targetElement, listDiv);

    /** empty memory */
    listDiv = null;
  },
  setSubmenu: function setSubmenu(core) {
    var colorArea = core.context.colorPicker.colorListHTML;
    var listDiv = core.util.createElement('DIV');
    listDiv.className = 'se-submenu se-list-layer';
    listDiv.innerHTML = colorArea;
    return listDiv;
  },
  /**
  * @Override submenu
  */
  on: function on() {
    var contextPicker = this.context.colorPicker;
    var contextFontColor = this.context.fontColor;
    contextPicker._colorInput = contextFontColor.colorInput;
    var color = this.wwComputedStyle.color;
    contextPicker._defaultColor = color ? this.plugins.colorPicker.isHexColor(color) ? color : this.plugins.colorPicker.rgb2hex(color) : "#333333";
    contextPicker._styleProperty = 'color';
    contextPicker._colorList = contextFontColor.colorList;
    this.plugins.colorPicker.init.call(this, this.getSelectionNode(), null);
  },
  /**
  * @Override _colorPicker
  */
  onChangeInput: function onChangeInput(e) {
    this.plugins.colorPicker.setCurrentColor.call(this, e.target.value);
  },
  submit: function submit() {
    this.plugins.fontColor.applyColor.call(this, this.context.colorPicker._currentColor);
  },
  pickup: function pickup(e) {
    e.preventDefault();
    e.stopPropagation();
    this.plugins.fontColor.applyColor.call(this, e.target.getAttribute('data-value'));
  },
  remove: function remove() {
    this.nodeChange(null, ['color'], ['span'], true);
    this.submenuOff();
  },
  applyColor: function applyColor(color) {
    if (!color) return;
    var newNode = this.util.createElement('SPAN');
    newNode.style.color = color;
    this.nodeChange(newNode, ['color'], null, null);
    this.submenuOff();
  }
});
// CONCATENATED MODULE: ./node_modules/suneditor/src/plugins/submenu/hiliteColor.js
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2017 JiHong Lee.
 * MIT license.
 */



/* harmony default export */ var hiliteColor = ({
  name: 'hiliteColor',
  display: 'submenu',
  add: function add(core, targetElement) {
    core.addModule([_colorPicker]);
    var context = core.context;
    context.hiliteColor = {
      previewEl: null,
      colorInput: null,
      colorList: null
    };

    /** set submenu */
    var listDiv = this.setSubmenu(core);
    context.hiliteColor.colorInput = listDiv.querySelector('._se_color_picker_input');

    /** add event listeners */
    context.hiliteColor.colorInput.addEventListener('keyup', this.onChangeInput.bind(core));
    listDiv.querySelector('._se_color_picker_submit').addEventListener('click', this.submit.bind(core));
    listDiv.querySelector('._se_color_picker_remove').addEventListener('click', this.remove.bind(core));
    listDiv.addEventListener('click', this.pickup.bind(core));
    context.hiliteColor.colorList = listDiv.querySelectorAll('li button');

    /** append target button menu */
    core.initMenuTarget(this.name, targetElement, listDiv);

    /** empty memory */
    listDiv = null;
  },
  setSubmenu: function setSubmenu(core) {
    var colorArea = core.context.colorPicker.colorListHTML;
    var listDiv = core.util.createElement('DIV');
    listDiv.className = 'se-submenu se-list-layer';
    listDiv.innerHTML = colorArea;
    return listDiv;
  },
  /**
  * @Override submenu
  */
  on: function on() {
    var contextPicker = this.context.colorPicker;
    var contextHiliteColor = this.context.hiliteColor;
    contextPicker._colorInput = contextHiliteColor.colorInput;
    var color = this.wwComputedStyle.backgroundColor;
    contextPicker._defaultColor = color ? this.plugins.colorPicker.isHexColor(color) ? color : this.plugins.colorPicker.rgb2hex(color) : "#ffffff";
    contextPicker._styleProperty = 'backgroundColor';
    contextPicker._colorList = contextHiliteColor.colorList;
    this.plugins.colorPicker.init.call(this, this.getSelectionNode(), null);
  },
  /**
  * @Override _colorPicker
  */
  onChangeInput: function onChangeInput(e) {
    this.plugins.colorPicker.setCurrentColor.call(this, e.target.value);
  },
  submit: function submit() {
    this.plugins.hiliteColor.applyColor.call(this, this.context.colorPicker._currentColor);
  },
  pickup: function pickup(e) {
    e.preventDefault();
    e.stopPropagation();
    this.plugins.hiliteColor.applyColor.call(this, e.target.getAttribute('data-value'));
  },
  remove: function remove() {
    this.nodeChange(null, ['background-color'], ['span'], true);
    this.submenuOff();
  },
  applyColor: function applyColor(color) {
    if (!color) return;
    var newNode = this.util.createElement('SPAN');
    newNode.style.backgroundColor = color;
    this.nodeChange(newNode, ['background-color'], null, null);
    this.submenuOff();
  }
});
// CONCATENATED MODULE: ./node_modules/suneditor/src/plugins/submenu/horizontalRule.js
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2017 JiHong Lee.
 * MIT license.
 */


/* harmony default export */ var horizontalRule = ({
  name: 'horizontalRule',
  display: 'submenu',
  add: function add(core, targetElement) {
    core.context.horizontalRule = {
      currentHR: null
    };

    /** set submenu */
    var listDiv = this.setSubmenu(core);

    /** add event listeners */
    listDiv.querySelector('ul').addEventListener('click', this.horizontalRulePick.bind(core));

    /** append target button menu */
    core.initMenuTarget(this.name, targetElement, listDiv);

    /** empty memory */
    listDiv = null;
  },
  setSubmenu: function setSubmenu(core) {
    var lang = core.lang;
    var listDiv = core.util.createElement('DIV');
    var items = core.options.hrItems || [{
      name: lang.toolbar.hr_solid,
      class: '__se__solid'
    }, {
      name: lang.toolbar.hr_dashed,
      class: '__se__dashed'
    }, {
      name: lang.toolbar.hr_dotted,
      class: '__se__dotted'
    }];
    var list = '';
    for (var i = 0, len = items.length; i < len; i++) {
      list += '<li>' + '<button type="button" class="se-btn-list btn_line" data-command="horizontalRule" data-value="' + items[i].class + '" title="' + items[i].name + '" aria-label="' + items[i].name + '">' + '<hr' + (items[i].class ? ' class="' + items[i].class + '"' : '') + (items[i].style ? ' style="' + items[i].style + '"' : '') + '/>' + '</button>' + '</li>';
    }
    listDiv.className = 'se-submenu se-list-layer se-list-line';
    listDiv.innerHTML = '' + '<div class="se-list-inner">' + '<ul class="se-list-basic">' + list + '</ul>' + '</div>';
    return listDiv;
  },
  active: function active(element) {
    if (!element) {
      if (this.util.hasClass(this.context.horizontalRule.currentHR, 'on')) {
        this.controllersOff();
      }
    } else if (/HR/i.test(element.nodeName)) {
      this.context.horizontalRule.currentHR = element;
      if (!this.util.hasClass(element, 'on')) {
        this.util.addClass(element, 'on');
        this.controllersOn('hr', this.util.removeClass.bind(this.util, element, 'on'));
      }
      return true;
    }
    return false;
  },
  appendHr: function appendHr(hrTemp) {
    this.focus();
    return this.insertComponent(hrTemp.cloneNode(false), false, true, false);
  },
  horizontalRulePick: function horizontalRulePick(e) {
    e.preventDefault();
    e.stopPropagation();
    var target = e.target;
    var command = target.getAttribute('data-command');
    while (!command && !/UL/i.test(target.tagName)) {
      target = target.parentNode;
      command = target.getAttribute('data-command');
    }
    if (!command) return;
    var oNode = this.plugins.horizontalRule.appendHr.call(this, target.firstElementChild);
    if (oNode) {
      this.setRange(oNode, 0, oNode, 0);
      this.submenuOff();
    }
  }
});
// CONCATENATED MODULE: ./node_modules/suneditor/src/plugins/submenu/list.js
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2017 JiHong Lee.
 * MIT license.
 */


/* harmony default export */ var list = ({
  name: 'list',
  display: 'submenu',
  add: function add(core, targetElement) {
    var context = core.context;
    context.list = {
      targetButton: targetElement,
      _list: null,
      currentList: '',
      icons: {
        bullets: core.icons.list_bullets,
        number: core.icons.list_number
      }
    };

    /** set submenu */
    var listDiv = this.setSubmenu(core);
    var listUl = listDiv.querySelector('ul');

    /** add event listeners */
    listUl.addEventListener('click', this.pickup.bind(core));
    context.list._list = listUl.querySelectorAll('li button');

    /** append target button menu */
    core.initMenuTarget(this.name, targetElement, listDiv);

    /** empty memory */
    listDiv = null, listUl = null;
  },
  setSubmenu: function setSubmenu(core) {
    var lang = core.lang;
    var listDiv = core.util.createElement('DIV');
    listDiv.className = 'se-submenu se-list-layer';
    listDiv.innerHTML = '' + '<div class="se-list-inner">' + '<ul class="se-list-basic">' + '<li><button type="button" class="se-btn-list se-tooltip" data-command="OL" title="' + lang.toolbar.orderList + '" aria-label="' + lang.toolbar.orderList + '">' + core.icons.list_number + '</button></li>' + '<li><button type="button" class="se-btn-list se-tooltip" data-command="UL" title="' + lang.toolbar.unorderList + '" aria-label="' + lang.toolbar.unorderList + '">' + core.icons.list_bullets + '</button></li>' + '</ul>' + '</div>';
    return listDiv;
  },
  /**
  * @Override core
  */
  active: function active(element) {
    var button = this.context.list.targetButton;
    var icon = button.firstElementChild;
    var util = this.util;
    if (util.isList(element)) {
      var nodeName = element.nodeName;
      button.setAttribute('data-focus', nodeName);
      util.addClass(button, 'active');
      if (/UL/i.test(nodeName)) {
        util.changeElement(icon, this.context.list.icons.bullets);
      } else {
        util.changeElement(icon, this.context.list.icons.number);
      }
      return true;
    } else {
      button.removeAttribute('data-focus');
      util.changeElement(icon, this.context.list.icons.number);
      util.removeClass(button, 'active');
    }
    return false;
  },
  /**
  * @Override submenu
  */
  on: function on() {
    var listContext = this.context.list;
    var list = listContext._list;
    var currentList = listContext.targetButton.getAttribute('data-focus') || '';
    if (currentList !== listContext.currentList) {
      for (var i = 0, len = list.length; i < len; i++) {
        if (currentList === list[i].getAttribute('data-command')) {
          this.util.addClass(list[i], 'active');
        } else {
          this.util.removeClass(list[i], 'active');
        }
      }
      listContext.currentList = currentList;
    }
  },
  editList: function editList(command, selectedCells, detach) {
    var range = this.getRange();
    var selectedFormats = !selectedCells ? this.getSelectedElementsAndComponents(false) : selectedCells;
    if (selectedFormats.length === 0) {
      if (selectedCells) return;
      range = this.getRange_addLine(range, null);
      selectedFormats = this.getSelectedElementsAndComponents(false);
      if (selectedFormats.length === 0) return;
    }
    var util = this.util;
    util.sortByDepth(selectedFormats, true);

    // merge
    var firstSel = selectedFormats[0];
    var lastSel = selectedFormats[selectedFormats.length - 1];
    var topEl = (util.isListCell(firstSel) || util.isComponent(firstSel)) && !firstSel.previousElementSibling ? firstSel.parentNode.previousElementSibling : firstSel.previousElementSibling;
    var bottomEl = (util.isListCell(lastSel) || util.isComponent(lastSel)) && !lastSel.nextElementSibling ? lastSel.parentNode.nextElementSibling : lastSel.nextElementSibling;
    var originRange = {
      sc: range.startContainer,
      so: range.startContainer === range.endContainer && util.onlyZeroWidthSpace(range.startContainer) && range.startOffset === 0 && range.endOffset === 1 ? range.endOffset : range.startOffset,
      ec: range.endContainer,
      eo: range.endOffset
    };
    var isRemove = true;
    var _loop = function _loop(i) {
      if (!util.isList(util.getRangeFormatElement(selectedFormats[i], function (current) {
        return this.getRangeFormatElement(current) && current !== selectedFormats[i];
      }.bind(util)))) {
        isRemove = false;
        return "break";
      }
    };
    for (var i = 0, len = selectedFormats.length; i < len; i++) {
      var _ret = _loop(i);
      if (_ret === "break") break;
    }
    if (isRemove && (!topEl || firstSel.tagName !== topEl.tagName || command !== topEl.tagName.toUpperCase()) && (!bottomEl || lastSel.tagName !== bottomEl.tagName || command !== bottomEl.tagName.toUpperCase())) {
      if (detach) {
        for (var _i = 0, _len = selectedFormats.length; _i < _len; _i++) {
          for (var j = _i - 1; j >= 0; j--) {
            if (selectedFormats[j].contains(selectedFormats[_i])) {
              selectedFormats.splice(_i, 1);
              _i--;
              _len--;
              break;
            }
          }
        }
      }
      var currentFormat = util.getRangeFormatElement(firstSel);
      var cancel = currentFormat && currentFormat.tagName === command;
      var rangeArr, tempList;
      var passComponent = function (current) {
        return !this.isComponent(current);
      }.bind(util);
      if (!cancel) tempList = util.createElement(command);
      for (var _i2 = 0, _len2 = selectedFormats.length, r, o; _i2 < _len2; _i2++) {
        o = util.getRangeFormatElement(selectedFormats[_i2], passComponent);
        if (!o || !util.isList(o)) continue;
        if (!r) {
          r = o;
          rangeArr = {
            r: r,
            f: [util.getParentElement(selectedFormats[_i2], 'LI')]
          };
        } else {
          if (r !== o) {
            if (detach && util.isListCell(o.parentNode)) {
              this.plugins.list._detachNested.call(this, rangeArr.f);
            } else {
              this.detachRangeFormatElement(rangeArr.f[0].parentNode, rangeArr.f, tempList, false, true);
            }
            o = selectedFormats[_i2].parentNode;
            if (!cancel) tempList = util.createElement(command);
            r = o;
            rangeArr = {
              r: r,
              f: [util.getParentElement(selectedFormats[_i2], 'LI')]
            };
          } else {
            rangeArr.f.push(util.getParentElement(selectedFormats[_i2], 'LI'));
          }
        }
        if (_i2 === _len2 - 1) {
          if (detach && util.isListCell(o.parentNode)) {
            this.plugins.list._detachNested.call(this, rangeArr.f);
          } else {
            this.detachRangeFormatElement(rangeArr.f[0].parentNode, rangeArr.f, tempList, false, true);
          }
        }
      }
    } else {
      var topElParent = topEl ? topEl.parentNode : topEl;
      var bottomElParent = bottomEl ? bottomEl.parentNode : bottomEl;
      topEl = topElParent && !util.isWysiwygDiv(topElParent) && topElParent.nodeName === command ? topElParent : topEl;
      bottomEl = bottomElParent && !util.isWysiwygDiv(bottomElParent) && bottomElParent.nodeName === command ? bottomElParent : bottomEl;
      var mergeTop = topEl && topEl.tagName === command;
      var mergeBottom = bottomEl && bottomEl.tagName === command;
      var list = mergeTop ? topEl : util.createElement(command);
      var firstList = null;
      var lastList = null;
      var topNumber = null;
      var bottomNumber = null;
      var _passComponent = function (current) {
        return !this.isComponent(current) && !this.isList(current);
      }.bind(util);
      for (var _i3 = 0, _len3 = selectedFormats.length, newCell, fTag, isCell, next, originParent, nextParent, parentTag, siblingTag, rangeTag; _i3 < _len3; _i3++) {
        fTag = selectedFormats[_i3];
        if (fTag.childNodes.length === 0 && !util._isIgnoreNodeChange(fTag)) {
          util.removeItem(fTag);
          continue;
        }
        next = selectedFormats[_i3 + 1];
        originParent = fTag.parentNode;
        nextParent = next ? next.parentNode : null;
        isCell = util.isListCell(fTag);
        rangeTag = util.isRangeFormatElement(originParent) ? originParent : null;
        parentTag = isCell && !util.isWysiwygDiv(originParent) ? originParent.parentNode : originParent;
        siblingTag = isCell && !util.isWysiwygDiv(originParent) ? !next || util.isListCell(parentTag) ? originParent : originParent.nextSibling : fTag.nextSibling;
        newCell = util.createElement('LI');
        util.copyFormatAttributes(newCell, fTag);
        if (_i3 === 0 && originRange.sc === fTag) {
          originRange.sc = newCell;
        }
        if (_i3 === _len3 - 1 && originRange.ec === fTag) {
          originRange.ec = newCell;
        }
        if (util.isComponent(fTag)) {
          var isHR = /^HR$/i.test(fTag.nodeName);
          if (!isHR) newCell.innerHTML = '<br>';
          newCell.innerHTML += fTag.outerHTML;
          if (isHR) newCell.innerHTML += '<br>';
        } else {
          var fChildren = fTag.childNodes;
          while (fChildren[0]) {
            newCell.appendChild(fChildren[0]);
          }
        }
        list.appendChild(newCell);
        if (!next) lastList = list;
        if (!next || parentTag !== nextParent || util.isRangeFormatElement(siblingTag)) {
          if (!firstList) firstList = list;
          if ((!mergeTop || !next || parentTag !== nextParent) && !(next && util.isList(nextParent) && nextParent === originParent)) {
            if (list.parentNode !== parentTag) parentTag.insertBefore(list, siblingTag);
          }
        }
        util.removeItem(fTag);
        if (mergeTop && topNumber === null) topNumber = list.children.length - 1;
        if (next && (util.getRangeFormatElement(nextParent, _passComponent) !== util.getRangeFormatElement(originParent, _passComponent) || util.isList(nextParent) && util.isList(originParent) && util.getElementDepth(nextParent) !== util.getElementDepth(originParent))) {
          list = util.createElement(command);
        }
        if (rangeTag && rangeTag.children.length === 0) util.removeItem(rangeTag);
      }
      if (topNumber) {
        firstList = firstList.children[topNumber];
      }
      if (mergeBottom) {
        bottomNumber = list.children.length - 1;
        list.innerHTML += bottomEl.innerHTML;
        lastList = list.children[bottomNumber];
        util.removeItem(bottomEl);
      }
    }
    this.effectNode = null;
    return originRange;
  },
  _detachNested: function _detachNested(cells) {
    var first = cells[0];
    var last = cells[cells.length - 1];
    var next = last.nextElementSibling;
    var originList = first.parentNode;
    var sibling = originList.parentNode.nextElementSibling;
    var parentNode = originList.parentNode.parentNode;
    for (var c = 0, cLen = cells.length; c < cLen; c++) {
      parentNode.insertBefore(cells[c], sibling);
    }
    if (next && originList.children.length > 0) {
      var newList = originList.cloneNode(false);
      var children = originList.childNodes;
      var index = this.util.getPositionIndex(next);
      while (children[index]) {
        newList.appendChild(children[index]);
      }
      last.appendChild(newList);
    }
    if (originList.children.length === 0) this.util.removeItem(originList);
    this.util.mergeSameTags(parentNode);
    var edge = this.util.getEdgeChildNodes(first, last);
    return {
      cc: first.parentNode,
      sc: edge.sc,
      ec: edge.ec
    };
  },
  editInsideList: function editInsideList(remove, selectedCells) {
    selectedCells = !selectedCells ? this.getSelectedElements().filter(function (el) {
      return this.isListCell(el);
    }.bind(this.util)) : selectedCells;
    var cellsLen = selectedCells.length;
    if (cellsLen === 0 || !remove && !this.util.isListCell(selectedCells[0].previousElementSibling) && !this.util.isListCell(selectedCells[cellsLen - 1].nextElementSibling)) {
      return {
        sc: selectedCells[0],
        so: 0,
        ec: selectedCells[cellsLen - 1],
        eo: 1
      };
    }
    var originList = selectedCells[0].parentNode;
    var lastCell = selectedCells[cellsLen - 1];
    var range = null;
    if (remove) {
      if (originList !== lastCell.parentNode && this.util.isList(lastCell.parentNode.parentNode) && lastCell.nextElementSibling) {
        lastCell = lastCell.nextElementSibling;
        while (lastCell) {
          selectedCells.push(lastCell);
          lastCell = lastCell.nextElementSibling;
        }
      }
      range = this.plugins.list.editList.call(this, originList.nodeName.toUpperCase(), selectedCells, true);
    } else {
      var innerList = this.util.createElement(originList.nodeName);
      var prev = selectedCells[0].previousElementSibling;
      var next = lastCell.nextElementSibling;
      var nodePath = {
        s: null,
        e: null,
        sl: originList,
        el: originList
      };
      for (var i = 0, len = cellsLen, c; i < len; i++) {
        c = selectedCells[i];
        if (c.parentNode !== originList) {
          this.plugins.list._insiedList.call(this, originList, innerList, prev, next, nodePath);
          originList = c.parentNode;
          innerList = this.util.createElement(originList.nodeName);
        }
        prev = c.previousElementSibling;
        next = c.nextElementSibling;
        innerList.appendChild(c);
      }
      this.plugins.list._insiedList.call(this, originList, innerList, prev, next, nodePath);
      var sc = this.util.getNodeFromPath(nodePath.s, nodePath.sl);
      var ec = this.util.getNodeFromPath(nodePath.e, nodePath.el);
      range = {
        sc: sc,
        so: 0,
        ec: ec,
        eo: ec.textContent.length
      };
    }
    return range;
  },
  _insiedList: function _insiedList(originList, innerList, prev, next, nodePath) {
    var insertPrev = false;
    if (prev && innerList.tagName === prev.tagName) {
      var children = innerList.children;
      while (children[0]) {
        prev.appendChild(children[0]);
      }
      innerList = prev;
      insertPrev = true;
    }
    if (next && innerList.tagName === next.tagName) {
      var _children = next.children;
      while (_children[0]) {
        innerList.appendChild(_children[0]);
      }
      var temp = next.nextElementSibling;
      next.parentNode.removeChild(next);
      next = temp;
    }
    if (!insertPrev) {
      if (this.util.isListCell(prev)) {
        originList = prev;
        next = null;
      }
      originList.insertBefore(innerList, next);
      if (!nodePath.s) {
        nodePath.s = this.util.getNodePath(innerList.firstElementChild.firstChild, originList, null);
        nodePath.sl = originList;
      }
      var slPath = originList.contains(nodePath.sl) ? this.util.getNodePath(nodePath.sl, originList) : null;
      nodePath.e = this.util.getNodePath(innerList.lastElementChild.firstChild, originList, null);
      nodePath.el = originList;
      this.util.mergeSameTags(originList, [nodePath.s, nodePath.e, slPath], false);
      this.util.mergeNestedTags(originList);
      if (slPath) nodePath.sl = this.util.getNodeFromPath(slPath, originList);
    }
    return innerList;
  },
  pickup: function pickup(e) {
    e.preventDefault();
    e.stopPropagation();
    var target = e.target;
    var command = '';
    while (!command && !/^UL$/i.test(target.tagName)) {
      command = target.getAttribute('data-command');
      target = target.parentNode;
    }
    if (!command) return;
    var range = this.plugins.list.editList.call(this, command, null, false);
    if (range) this.setRange(range.sc, range.so, range.ec, range.eo);
    this.submenuOff();

    // history stack
    this.history.push(false);
  }
});
// CONCATENATED MODULE: ./node_modules/suneditor/src/plugins/submenu/table.js
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2017 JiHong Lee.
 * MIT license.
 */


/* harmony default export */ var table = ({
  name: 'table',
  display: 'submenu',
  add: function add(core, targetElement) {
    var context = core.context;
    var contextTable = context.table = {
      _element: null,
      _tdElement: null,
      _trElement: null,
      _trElements: null,
      _tableXY: [],
      _maxWidth: true,
      _fixedColumn: false,
      _rtl: core.options.rtl,
      cellControllerTop: core.options.tableCellControllerPosition === 'top',
      resizeText: null,
      headerButton: null,
      mergeButton: null,
      splitButton: null,
      splitMenu: null,
      maxText: core.lang.controller.maxSize,
      minText: core.lang.controller.minSize,
      _physical_cellCnt: 0,
      _logical_cellCnt: 0,
      _rowCnt: 0,
      _rowIndex: 0,
      _physical_cellIndex: 0,
      _logical_cellIndex: 0,
      _current_colSpan: 0,
      _current_rowSpan: 0,
      icons: {
        expansion: core.icons.expansion,
        reduction: core.icons.reduction
      }
    };

    /** set submenu */
    var listDiv = this.setSubmenu(core);
    var tablePicker = listDiv.querySelector('.se-controller-table-picker');
    contextTable.tableHighlight = listDiv.querySelector('.se-table-size-highlighted');
    contextTable.tableUnHighlight = listDiv.querySelector('.se-table-size-unhighlighted');
    contextTable.tableDisplay = listDiv.querySelector('.se-table-size-display');
    if (core.options.rtl) contextTable.tableHighlight.style.left = 10 * 18 - 13 + 'px';

    /** set table controller */
    var tableController = this.setController_table(core);
    contextTable.tableController = tableController;
    contextTable.resizeButton = tableController.querySelector('._se_table_resize');
    contextTable.resizeText = tableController.querySelector('._se_table_resize > span > span');
    contextTable.columnFixedButton = tableController.querySelector('._se_table_fixed_column');
    contextTable.headerButton = tableController.querySelector('._se_table_header');

    /** set resizing */
    var resizeDiv = this.setController_tableEditor(core, contextTable.cellControllerTop);
    contextTable.resizeDiv = resizeDiv;
    contextTable.splitMenu = resizeDiv.querySelector('.se-btn-group-sub');
    contextTable.mergeButton = resizeDiv.querySelector('._se_table_merge_button');
    contextTable.splitButton = resizeDiv.querySelector('._se_table_split_button');
    contextTable.insertRowAboveButton = resizeDiv.querySelector('._se_table_insert_row_a');
    contextTable.insertRowBelowButton = resizeDiv.querySelector('._se_table_insert_row_b');

    /** add event listeners */
    tablePicker.addEventListener('mousemove', this.onMouseMove_tablePicker.bind(core, contextTable));
    tablePicker.addEventListener('click', this.appendTable.bind(core));
    resizeDiv.addEventListener('click', this.onClick_tableController.bind(core));
    tableController.addEventListener('click', this.onClick_tableController.bind(core));

    /** append target button menu */
    core.initMenuTarget(this.name, targetElement, listDiv);

    /** append controller */
    context.element.relative.appendChild(resizeDiv);
    context.element.relative.appendChild(tableController);

    /** empty memory */
    listDiv = null, tablePicker = null, resizeDiv = null, tableController = null, contextTable = null;
  },
  setSubmenu: function setSubmenu(core) {
    var listDiv = core.util.createElement('DIV');
    listDiv.className = 'se-submenu se-selector-table';
    listDiv.innerHTML = '' + '<div class="se-table-size">' + '<div class="se-table-size-picker se-controller-table-picker"></div>' + '<div class="se-table-size-highlighted"></div>' + '<div class="se-table-size-unhighlighted"></div>' + '</div>' + '<div class="se-table-size-display">1 x 1</div>';
    return listDiv;
  },
  setController_table: function setController_table(core) {
    var lang = core.lang;
    var icons = core.icons;
    var tableResize = core.util.createElement('DIV');
    tableResize.className = 'se-controller se-controller-table';
    tableResize.innerHTML = '' + '<div>' + '<div class="se-btn-group">' + '<button type="button" data-command="resize" class="se-btn se-tooltip _se_table_resize">' + icons.expansion + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.maxSize + '</span></span>' + '</button>' + '<button type="button" data-command="layout" class="se-btn se-tooltip _se_table_fixed_column">' + icons.fixed_column_width + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.fixedColumnWidth + '</span></span>' + '</button>' + '<button type="button" data-command="header" class="se-btn se-tooltip _se_table_header">' + icons.table_header + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.tableHeader + '</span></span>' + '</button>' + '<button type="button" data-command="remove" class="se-btn se-tooltip">' + icons.delete + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.remove + '</span></span>' + '</button>' + '</div>' + '</div>';
    return tableResize;
  },
  setController_tableEditor: function setController_tableEditor(core, cellControllerTop) {
    var lang = core.lang;
    var icons = core.icons;
    var tableResize = core.util.createElement('DIV');
    tableResize.className = 'se-controller se-controller-table-cell';
    tableResize.innerHTML = (cellControllerTop ? '' : '<div class="se-arrow se-arrow-up"></div>') + '<div class="se-btn-group">' + '<button type="button" data-command="insert" data-value="row" data-option="up" class="se-btn se-tooltip _se_table_insert_row_a">' + icons.insert_row_above + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.insertRowAbove + '</span></span>' + '</button>' + '<button type="button" data-command="insert" data-value="row" data-option="down" class="se-btn se-tooltip _se_table_insert_row_b">' + icons.insert_row_below + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.insertRowBelow + '</span></span>' + '</button>' + '<button type="button" data-command="delete" data-value="row" class="se-btn se-tooltip">' + icons.delete_row + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.deleteRow + '</span></span>' + '</button>' + '<button type="button" data-command="merge" class="_se_table_merge_button se-btn se-tooltip" disabled>' + icons.merge_cell + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.mergeCells + '</span></span>' + '</button>' + '</div>' + '<div class="se-btn-group" style="padding-top: 0;">' + '<button type="button" data-command="insert" data-value="cell" data-option="left" class="se-btn se-tooltip">' + icons.insert_column_left + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.insertColumnBefore + '</span></span>' + '</button>' + '<button type="button" data-command="insert" data-value="cell" data-option="right" class="se-btn se-tooltip">' + icons.insert_column_right + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.insertColumnAfter + '</span></span>' + '</button>' + '<button type="button" data-command="delete" data-value="cell" class="se-btn se-tooltip">' + icons.delete_column + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.deleteColumn + '</span></span>' + '</button>' + '<button type="button" data-command="onsplit" class="_se_table_split_button se-btn se-tooltip">' + icons.split_cell + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.splitCells + '</span></span>' + '</button>' + '<div class="se-btn-group-sub sun-editor-common se-list-layer se-table-split">' + '<div class="se-list-inner">' + '<ul class="se-list-basic">' + '<li class="se-btn-list" data-command="split" data-value="vertical" style="line-height:32px;" title="' + lang.controller.VerticalSplit + '" aria-label="' + lang.controller.VerticalSplit + '">' + lang.controller.VerticalSplit + '</li>' + '<li class="se-btn-list" data-command="split" data-value="horizontal" style="line-height:32px;" title="' + lang.controller.HorizontalSplit + '" aria-label="' + lang.controller.HorizontalSplit + '">' + lang.controller.HorizontalSplit + '</li>' + '</ul>' + '</div>' + '</div>' + '</div>';
    return tableResize;
  },
  appendTable: function appendTable() {
    var oTable = this.util.createElement('TABLE');
    var createCells = this.plugins.table.createCells;
    var x = this.context.table._tableXY[0];
    var y = this.context.table._tableXY[1];
    var tableHTML = '<tbody>';
    while (y > 0) {
      tableHTML += '<tr>' + createCells.call(this, 'td', x) + '</tr>';
      --y;
    }
    tableHTML += '</tbody>';
    oTable.innerHTML = tableHTML;
    var changed = this.insertComponent(oTable, false, true, false);
    if (changed) {
      var firstTd = oTable.querySelector('td div');
      this.setRange(firstTd, 0, firstTd, 0);
      this.plugins.table.reset_table_picker.call(this);
    }
  },
  createCells: function createCells(nodeName, cnt, returnElement) {
    nodeName = nodeName.toLowerCase();
    if (!returnElement) {
      var cellsHTML = '';
      while (cnt > 0) {
        cellsHTML += '<' + nodeName + '><div><br></div></' + nodeName + '>';
        cnt--;
      }
      return cellsHTML;
    } else {
      var cell = this.util.createElement(nodeName);
      cell.innerHTML = '<div><br></div>';
      return cell;
    }
  },
  onMouseMove_tablePicker: function onMouseMove_tablePicker(contextTable, e) {
    e.stopPropagation();
    var x = this._w.Math.ceil(e.offsetX / 18);
    var y = this._w.Math.ceil(e.offsetY / 18);
    x = x < 1 ? 1 : x;
    y = y < 1 ? 1 : y;
    if (contextTable._rtl) {
      contextTable.tableHighlight.style.left = x * 18 - 13 + 'px';
      x = 11 - x;
    }
    contextTable.tableHighlight.style.width = x + 'em';
    contextTable.tableHighlight.style.height = y + 'em';

    // let x_u = x < 5 ? 5 : (x > 9 ? 10 : x + 1);
    // let y_u = y < 5 ? 5 : (y > 9 ? 10 : y + 1);
    // contextTable.tableUnHighlight.style.width = x_u + 'em';
    // contextTable.tableUnHighlight.style.height = y_u + 'em';

    this.util.changeTxt(contextTable.tableDisplay, x + ' x ' + y);
    contextTable._tableXY = [x, y];
  },
  reset_table_picker: function reset_table_picker() {
    if (!this.context.table.tableHighlight) return;
    var highlight = this.context.table.tableHighlight.style;
    var unHighlight = this.context.table.tableUnHighlight.style;
    highlight.width = '1em';
    highlight.height = '1em';
    unHighlight.width = '10em';
    unHighlight.height = '10em';
    this.util.changeTxt(this.context.table.tableDisplay, '1 x 1');
    this.submenuOff();
  },
  init: function init() {
    var contextTable = this.context.table;
    var tablePlugin = this.plugins.table;
    tablePlugin._removeEvents.call(this);
    if (tablePlugin._selectedTable) {
      var selectedCells = tablePlugin._selectedTable.querySelectorAll('.se-table-selected-cell');
      for (var i = 0, len = selectedCells.length; i < len; i++) {
        this.util.removeClass(selectedCells[i], 'se-table-selected-cell');
      }
    }
    tablePlugin._toggleEditor.call(this, true);
    contextTable._element = null;
    contextTable._tdElement = null;
    contextTable._trElement = null;
    contextTable._trElements = null;
    contextTable._tableXY = [];
    contextTable._maxWidth = true;
    contextTable._fixedColumn = false;
    contextTable._physical_cellCnt = 0;
    contextTable._logical_cellCnt = 0;
    contextTable._rowCnt = 0;
    contextTable._rowIndex = 0;
    contextTable._physical_cellIndex = 0;
    contextTable._logical_cellIndex = 0;
    contextTable._current_colSpan = 0;
    contextTable._current_rowSpan = 0;
    tablePlugin._shift = false;
    tablePlugin._selectedCells = null;
    tablePlugin._selectedTable = null;
    tablePlugin._ref = null;
    tablePlugin._fixedCell = null;
    tablePlugin._selectedCell = null;
    tablePlugin._fixedCellName = null;
  },
  /** table edit controller */
  call_controller_tableEdit: function call_controller_tableEdit(tdElement) {
    var tablePlugin = this.plugins.table;
    var contextTable = this.context.table;
    if (!this.getSelection().isCollapsed && !tablePlugin._selectedCell) {
      this.controllersOff();
      this.util.removeClass(tdElement, 'se-table-selected-cell');
      return;
    }
    var tableElement = contextTable._element || this.plugins.table._selectedTable || this.util.getParentElement(tdElement, 'TABLE');
    contextTable._maxWidth = this.util.hasClass(tableElement, 'se-table-size-100') || tableElement.style.width === '100%' || !tableElement.style.width && !this.util.hasClass(tableElement, 'se-table-size-auto');
    contextTable._fixedColumn = this.util.hasClass(tableElement, 'se-table-layout-fixed') || tableElement.style.tableLayout === 'fixed';
    tablePlugin.setTableStyle.call(this, contextTable._maxWidth ? 'width|column' : 'width');
    tablePlugin.setPositionControllerTop.call(this, tableElement);
    tablePlugin.setPositionControllerDiv.call(this, tdElement, tablePlugin._shift);
    if (!tablePlugin._shift) this.controllersOn(contextTable.resizeDiv, contextTable.tableController, tablePlugin.init.bind(this), tdElement, 'table');
  },
  setPositionControllerTop: function setPositionControllerTop(tableElement) {
    this.setControllerPosition(this.context.table.tableController, tableElement, 'top', {
      left: 0,
      top: 0
    });
  },
  setPositionControllerDiv: function setPositionControllerDiv(tdElement, reset) {
    var contextTable = this.context.table;
    var resizeDiv = contextTable.resizeDiv;
    this.plugins.table.setCellInfo.call(this, tdElement, reset);
    if (contextTable.cellControllerTop) {
      this.setControllerPosition(resizeDiv, contextTable._element, 'top', {
        left: contextTable.tableController.offsetWidth,
        top: 0
      });
    } else {
      this.setControllerPosition(resizeDiv, tdElement, 'bottom', {
        left: 0,
        top: 0
      });
    }
  },
  setCellInfo: function setCellInfo(tdElement, reset) {
    var contextTable = this.context.table;
    var table = contextTable._element = this.plugins.table._selectedTable || this.util.getParentElement(tdElement, 'TABLE');
    if (/THEAD/i.test(table.firstElementChild.nodeName)) {
      this.util.addClass(contextTable.headerButton, 'active');
    } else {
      this.util.removeClass(contextTable.headerButton, 'active');
    }
    if (reset || contextTable._physical_cellCnt === 0) {
      if (contextTable._tdElement !== tdElement) {
        contextTable._tdElement = tdElement;
        contextTable._trElement = tdElement.parentNode;
      }
      var rows = contextTable._trElements = table.rows;
      var cellIndex = tdElement.cellIndex;
      var cellCnt = 0;
      for (var i = 0, cells = rows[0].cells, len = rows[0].cells.length; i < len; i++) {
        cellCnt += cells[i].colSpan;
      }

      // row cnt, row index
      var rowIndex = contextTable._rowIndex = contextTable._trElement.rowIndex;
      contextTable._rowCnt = rows.length;

      // cell cnt, physical cell index
      contextTable._physical_cellCnt = contextTable._trElement.cells.length;
      contextTable._logical_cellCnt = cellCnt;
      contextTable._physical_cellIndex = cellIndex;

      // span
      contextTable._current_colSpan = contextTable._tdElement.colSpan - 1;
      contextTable._current_rowSpan - contextTable._trElement.cells[cellIndex].rowSpan - 1;

      // find logcal cell index
      var rowSpanArr = [];
      var spanIndex = [];
      for (var _i = 0, _cells, colSpan; _i <= rowIndex; _i++) {
        _cells = rows[_i].cells;
        colSpan = 0;
        for (var c = 0, cLen = _cells.length, cell, cs, rs, logcalIndex; c < cLen; c++) {
          cell = _cells[c];
          cs = cell.colSpan - 1;
          rs = cell.rowSpan - 1;
          logcalIndex = c + colSpan;
          if (spanIndex.length > 0) {
            for (var r = 0, arr; r < spanIndex.length; r++) {
              arr = spanIndex[r];
              if (arr.row > _i) continue;
              if (logcalIndex >= arr.index) {
                colSpan += arr.cs;
                logcalIndex += arr.cs;
                arr.rs -= 1;
                arr.row = _i + 1;
                if (arr.rs < 1) {
                  spanIndex.splice(r, 1);
                  r--;
                }
              } else if (c === cLen - 1) {
                arr.rs -= 1;
                arr.row = _i + 1;
                if (arr.rs < 1) {
                  spanIndex.splice(r, 1);
                  r--;
                }
              }
            }
          }

          // logcal cell index
          if (_i === rowIndex && c === cellIndex) {
            contextTable._logical_cellIndex = logcalIndex;
            break;
          }
          if (rs > 0) {
            rowSpanArr.push({
              index: logcalIndex,
              cs: cs + 1,
              rs: rs,
              row: -1
            });
          }
          colSpan += cs;
        }
        spanIndex = spanIndex.concat(rowSpanArr).sort(function (a, b) {
          return a.index - b.index;
        });
        rowSpanArr = [];
      }
      rowSpanArr = null;
      spanIndex = null;
    }
  },
  editTable: function editTable(type, option) {
    var tablePlugin = this.plugins.table;
    var contextTable = this.context.table;
    var table = contextTable._element;
    var isRow = type === 'row';
    if (isRow) {
      var tableAttr = contextTable._trElement.parentNode;
      if (/^THEAD$/i.test(tableAttr.nodeName)) {
        if (option === 'up') {
          return;
        } else if (!tableAttr.nextElementSibling || !/^TBODY$/i.test(tableAttr.nextElementSibling.nodeName)) {
          table.innerHTML += '<tbody><tr>' + tablePlugin.createCells.call(this, 'td', contextTable._logical_cellCnt, false) + '</tr></tbody>';
          return;
        }
      }
    }

    // multi
    if (tablePlugin._ref) {
      var positionCell = contextTable._tdElement;
      var selectedCells = tablePlugin._selectedCells;
      // multi - row
      if (isRow) {
        // remove row
        if (!option) {
          var row = selectedCells[0].parentNode;
          var removeCells = [selectedCells[0]];
          for (var i = 1, len = selectedCells.length, cell; i < len; i++) {
            cell = selectedCells[i];
            if (row !== cell.parentNode) {
              removeCells.push(cell);
              row = cell.parentNode;
            }
          }
          for (var _i2 = 0, _len = removeCells.length; _i2 < _len; _i2++) {
            tablePlugin.setCellInfo.call(this, removeCells[_i2], true);
            tablePlugin.editRow.call(this, option);
          }
        } else {
          // edit row
          tablePlugin.setCellInfo.call(this, option === 'up' ? selectedCells[0] : selectedCells[selectedCells.length - 1], true);
          tablePlugin.editRow.call(this, option, positionCell);
        }
      } else {
        // multi - cell
        var firstRow = selectedCells[0].parentNode;
        // remove cell
        if (!option) {
          var _removeCells = [selectedCells[0]];
          for (var _i3 = 1, _len2 = selectedCells.length, _cell; _i3 < _len2; _i3++) {
            _cell = selectedCells[_i3];
            if (firstRow === _cell.parentNode) {
              _removeCells.push(_cell);
            } else {
              break;
            }
          }
          for (var _i4 = 0, _len3 = _removeCells.length; _i4 < _len3; _i4++) {
            tablePlugin.setCellInfo.call(this, _removeCells[_i4], true);
            tablePlugin.editCell.call(this, option);
          }
        } else {
          // edit cell
          var rightCell = null;
          for (var _i5 = 0, _len4 = selectedCells.length - 1; _i5 < _len4; _i5++) {
            if (firstRow !== selectedCells[_i5 + 1].parentNode) {
              rightCell = selectedCells[_i5];
              break;
            }
          }
          tablePlugin.setCellInfo.call(this, option === 'left' ? selectedCells[0] : rightCell || selectedCells[0], true);
          tablePlugin.editCell.call(this, option, positionCell);
        }
      }
      if (!option) tablePlugin.init.call(this);
    } // one
    else {
      tablePlugin[isRow ? 'editRow' : 'editCell'].call(this, option);
    }

    // after remove
    if (!option) {
      var children = table.children;
      for (var _i6 = 0; _i6 < children.length; _i6++) {
        if (children[_i6].children.length === 0) {
          this.util.removeItem(children[_i6]);
          _i6--;
        }
      }
      if (table.children.length === 0) this.util.removeItem(table);
    }
  },
  editRow: function editRow(option, positionResetElement) {
    var contextTable = this.context.table;
    var remove = !option;
    var up = option === 'up';
    var originRowIndex = contextTable._rowIndex;
    var rowIndex = remove || up ? originRowIndex : originRowIndex + contextTable._current_rowSpan + 1;
    var sign = remove ? -1 : 1;
    var rows = contextTable._trElements;
    var cellCnt = contextTable._logical_cellCnt;
    for (var i = 0, len = originRowIndex + (remove ? -1 : 0), cell; i <= len; i++) {
      cell = rows[i].cells;
      if (cell.length === 0) return;
      for (var c = 0, cLen = cell.length, rs, cs; c < cLen; c++) {
        rs = cell[c].rowSpan;
        cs = cell[c].colSpan;
        if (rs < 2 && cs < 2) continue;
        if (rs + i > rowIndex && rowIndex > i) {
          cell[c].rowSpan = rs + sign;
          cellCnt -= cs;
        }
      }
    }
    if (remove) {
      var next = rows[originRowIndex + 1];
      if (next) {
        var spanCells = [];
        var cells = rows[originRowIndex].cells;
        var colSpan = 0;
        for (var _i7 = 0, _len5 = cells.length, _cell2, logcalIndex; _i7 < _len5; _i7++) {
          _cell2 = cells[_i7];
          logcalIndex = _i7 + colSpan;
          colSpan += _cell2.colSpan - 1;
          if (_cell2.rowSpan > 1) {
            _cell2.rowSpan -= 1;
            spanCells.push({
              cell: _cell2.cloneNode(false),
              index: logcalIndex
            });
          }
        }
        if (spanCells.length > 0) {
          var spanCell = spanCells.shift();
          cells = next.cells;
          colSpan = 0;
          for (var _i8 = 0, _len6 = cells.length, _cell3, _logcalIndex; _i8 < _len6; _i8++) {
            _cell3 = cells[_i8];
            _logcalIndex = _i8 + colSpan;
            colSpan += _cell3.colSpan - 1;
            if (_logcalIndex >= spanCell.index) {
              _i8--, colSpan--;
              colSpan += spanCell.cell.colSpan - 1;
              next.insertBefore(spanCell.cell, _cell3);
              spanCell = spanCells.shift();
              if (!spanCell) break;
            }
          }
          if (spanCell) {
            next.appendChild(spanCell.cell);
            for (var _i9 = 0, _len7 = spanCells.length; _i9 < _len7; _i9++) {
              next.appendChild(spanCells[_i9].cell);
            }
          }
        }
      }
      contextTable._element.deleteRow(rowIndex);
    } else {
      var newRow = contextTable._element.insertRow(rowIndex);
      newRow.innerHTML = this.plugins.table.createCells.call(this, 'td', cellCnt, false);
    }
    if (!remove) {
      this.plugins.table.setPositionControllerDiv.call(this, positionResetElement || contextTable._tdElement, true);
    } else {
      this.controllersOff();
    }
  },
  editCell: function editCell(option, positionResetElement) {
    var contextTable = this.context.table;
    var util = this.util;
    var remove = !option;
    var left = option === 'left';
    var colSpan = contextTable._current_colSpan;
    var cellIndex = remove || left ? contextTable._logical_cellIndex : contextTable._logical_cellIndex + colSpan + 1;
    var rows = contextTable._trElements;
    var rowSpanArr = [];
    var spanIndex = [];
    var passCell = 0;
    var removeCell = [];
    var removeSpanArr = [];
    for (var i = 0, len = contextTable._rowCnt, row, insertIndex, cells, newCell, applySpan, cellColSpan; i < len; i++) {
      row = rows[i];
      insertIndex = cellIndex;
      applySpan = false;
      cells = row.cells;
      cellColSpan = 0;
      for (var c = 0, cell, cLen = cells.length, rs, cs, removeIndex; c < cLen; c++) {
        cell = cells[c];
        if (!cell) break;
        rs = cell.rowSpan - 1;
        cs = cell.colSpan - 1;
        if (!remove) {
          if (c >= insertIndex) break;
          if (cs > 0) {
            if (passCell < 1 && cs + c >= insertIndex) {
              cell.colSpan += 1;
              insertIndex = null;
              passCell = rs + 1;
              break;
            }
            insertIndex -= cs;
          }
          if (!applySpan) {
            for (var r = 0, arr; r < spanIndex.length; r++) {
              arr = spanIndex[r];
              insertIndex -= arr.cs;
              arr.rs -= 1;
              if (arr.rs < 1) {
                spanIndex.splice(r, 1);
                r--;
              }
            }
            applySpan = true;
          }
        } else {
          removeIndex = c + cellColSpan;
          if (spanIndex.length > 0) {
            var lastCell = !cells[c + 1];
            for (var _r = 0, _arr; _r < spanIndex.length; _r++) {
              _arr = spanIndex[_r];
              if (_arr.row > i) continue;
              if (removeIndex >= _arr.index) {
                cellColSpan += _arr.cs;
                removeIndex = c + cellColSpan;
                _arr.rs -= 1;
                _arr.row = i + 1;
                if (_arr.rs < 1) {
                  spanIndex.splice(_r, 1);
                  _r--;
                }
              } else if (lastCell) {
                _arr.rs -= 1;
                _arr.row = i + 1;
                if (_arr.rs < 1) {
                  spanIndex.splice(_r, 1);
                  _r--;
                }
              }
            }
          }
          if (rs > 0) {
            rowSpanArr.push({
              rs: rs,
              cs: cs + 1,
              index: removeIndex,
              row: -1
            });
          }
          if (removeIndex >= insertIndex && removeIndex + cs <= insertIndex + colSpan) {
            removeCell.push(cell);
          } else if (removeIndex <= insertIndex + colSpan && removeIndex + cs >= insertIndex) {
            cell.colSpan -= util.getOverlapRangeAtIndex(cellIndex, cellIndex + colSpan, removeIndex, removeIndex + cs);
          } else if (rs > 0 && (removeIndex < insertIndex || removeIndex + cs > insertIndex + colSpan)) {
            removeSpanArr.push({
              cell: cell,
              i: i,
              rs: i + rs
            });
          }
          cellColSpan += cs;
        }
      }
      spanIndex = spanIndex.concat(rowSpanArr).sort(function (a, b) {
        return a.index - b.index;
      });
      rowSpanArr = [];
      if (!remove) {
        if (passCell > 0) {
          passCell -= 1;
          continue;
        }
        if (insertIndex !== null && cells.length > 0) {
          newCell = this.plugins.table.createCells.call(this, cells[0].nodeName, 0, true);
          newCell = row.insertBefore(newCell, cells[insertIndex]);
        }
      }
    }
    if (remove) {
      var removeFirst, removeEnd;
      for (var _r2 = 0, rLen = removeCell.length, _row; _r2 < rLen; _r2++) {
        _row = removeCell[_r2].parentNode;
        util.removeItem(removeCell[_r2]);
        if (_row.cells.length === 0) {
          if (!removeFirst) removeFirst = util.getArrayIndex(rows, _row);
          removeEnd = util.getArrayIndex(rows, _row);
          util.removeItem(_row);
        }
      }
      for (var _c = 0, _cLen = removeSpanArr.length, rowSpanCell; _c < _cLen; _c++) {
        rowSpanCell = removeSpanArr[_c];
        rowSpanCell.cell.rowSpan = util.getOverlapRangeAtIndex(removeFirst, removeEnd, rowSpanCell.i, rowSpanCell.rs);
      }
      this.controllersOff();
    } else {
      this.plugins.table.setPositionControllerDiv.call(this, positionResetElement || contextTable._tdElement, true);
    }
  },
  _closeSplitMenu: null,
  openSplitMenu: function openSplitMenu() {
    this.util.addClass(this.context.table.splitButton, 'on');
    this.context.table.splitMenu.style.display = 'inline-table';
    this.plugins.table._closeSplitMenu = function () {
      this.util.removeClass(this.context.table.splitButton, 'on');
      this.context.table.splitMenu.style.display = 'none';
      this.removeDocEvent('click', this.plugins.table._closeSplitMenu);
      this.plugins.table._closeSplitMenu = null;
    }.bind(this);
    this.addDocEvent('click', this.plugins.table._closeSplitMenu);
  },
  splitCells: function splitCells(direction) {
    var util = this.util;
    var vertical = direction === 'vertical';
    var contextTable = this.context.table;
    var currentCell = contextTable._tdElement;
    var rows = contextTable._trElements;
    var currentRow = contextTable._trElement;
    var index = contextTable._logical_cellIndex;
    var rowIndex = contextTable._rowIndex;
    var newCell = this.plugins.table.createCells.call(this, currentCell.nodeName, 0, true);

    // vertical
    if (vertical) {
      var currentColSpan = currentCell.colSpan;
      newCell.rowSpan = currentCell.rowSpan;

      // colspan > 1
      if (currentColSpan > 1) {
        newCell.colSpan = this._w.Math.floor(currentColSpan / 2);
        currentCell.colSpan = currentColSpan - newCell.colSpan;
        currentRow.insertBefore(newCell, currentCell.nextElementSibling);
      } else {
        // colspan - 1
        var rowSpanArr = [];
        var spanIndex = [];
        for (var i = 0, len = contextTable._rowCnt, cells, colSpan; i < len; i++) {
          cells = rows[i].cells;
          colSpan = 0;
          for (var c = 0, cLen = cells.length, cell, cs, rs, logcalIndex; c < cLen; c++) {
            cell = cells[c];
            cs = cell.colSpan - 1;
            rs = cell.rowSpan - 1;
            logcalIndex = c + colSpan;
            if (spanIndex.length > 0) {
              for (var r = 0, arr; r < spanIndex.length; r++) {
                arr = spanIndex[r];
                if (arr.row > i) continue;
                if (logcalIndex >= arr.index) {
                  colSpan += arr.cs;
                  logcalIndex += arr.cs;
                  arr.rs -= 1;
                  arr.row = i + 1;
                  if (arr.rs < 1) {
                    spanIndex.splice(r, 1);
                    r--;
                  }
                } else if (c === cLen - 1) {
                  arr.rs -= 1;
                  arr.row = i + 1;
                  if (arr.rs < 1) {
                    spanIndex.splice(r, 1);
                    r--;
                  }
                }
              }
            }
            if (logcalIndex <= index && rs > 0) {
              rowSpanArr.push({
                index: logcalIndex,
                cs: cs + 1,
                rs: rs,
                row: -1
              });
            }
            if (cell !== currentCell && logcalIndex <= index && logcalIndex + cs >= index + currentColSpan - 1) {
              cell.colSpan += 1;
              break;
            }
            if (logcalIndex > index) break;
            colSpan += cs;
          }
          spanIndex = spanIndex.concat(rowSpanArr).sort(function (a, b) {
            return a.index - b.index;
          });
          rowSpanArr = [];
        }
        currentRow.insertBefore(newCell, currentCell.nextElementSibling);
      }
    } else {
      // horizontal
      var currentRowSpan = currentCell.rowSpan;
      newCell.colSpan = currentCell.colSpan;

      // rowspan > 1
      if (currentRowSpan > 1) {
        newCell.rowSpan = this._w.Math.floor(currentRowSpan / 2);
        var newRowSpan = currentRowSpan - newCell.rowSpan;
        var _rowSpanArr = [];
        var nextRowIndex = util.getArrayIndex(rows, currentRow) + newRowSpan;
        for (var _i10 = 0, _cells2, _colSpan; _i10 < nextRowIndex; _i10++) {
          _cells2 = rows[_i10].cells;
          _colSpan = 0;
          for (var _c2 = 0, _cLen2 = _cells2.length, _cell4, _cs, _logcalIndex2; _c2 < _cLen2; _c2++) {
            _logcalIndex2 = _c2 + _colSpan;
            if (_logcalIndex2 >= index) break;
            _cell4 = _cells2[_c2];
            _cs = _cell4.rowSpan - 1;
            if (_cs > 0 && _cs + _i10 >= nextRowIndex && _logcalIndex2 < index) {
              _rowSpanArr.push({
                index: _logcalIndex2,
                cs: _cell4.colSpan
              });
            }
            _colSpan += _cell4.colSpan - 1;
          }
        }
        var nextRow = rows[nextRowIndex];
        var nextCells = nextRow.cells;
        var _rs = _rowSpanArr.shift();
        for (var _c3 = 0, _cLen3 = nextCells.length, _colSpan2 = 0, _cell5, _cs2, _logcalIndex3, insertIndex; _c3 < _cLen3; _c3++) {
          _logcalIndex3 = _c3 + _colSpan2;
          _cell5 = nextCells[_c3];
          _cs2 = _cell5.colSpan - 1;
          insertIndex = _logcalIndex3 + _cs2 + 1;
          if (_rs && insertIndex >= _rs.index) {
            _colSpan2 += _rs.cs;
            insertIndex += _rs.cs;
            _rs = _rowSpanArr.shift();
          }
          if (insertIndex >= index || _c3 === _cLen3 - 1) {
            nextRow.insertBefore(newCell, _cell5.nextElementSibling);
            break;
          }
          _colSpan2 += _cs2;
        }
        currentCell.rowSpan = newRowSpan;
      } else {
        // rowspan - 1
        newCell.rowSpan = currentCell.rowSpan;
        var newRow = util.createElement('TR');
        newRow.appendChild(newCell);
        for (var _i11 = 0, _cells3; _i11 < rowIndex; _i11++) {
          _cells3 = rows[_i11].cells;
          if (_cells3.length === 0) return;
          for (var _c4 = 0, _cLen4 = _cells3.length; _c4 < _cLen4; _c4++) {
            if (_i11 + _cells3[_c4].rowSpan - 1 >= rowIndex) {
              _cells3[_c4].rowSpan += 1;
            }
          }
        }
        var physicalIndex = contextTable._physical_cellIndex;
        var _cells4 = currentRow.cells;
        for (var _c5 = 0, _cLen5 = _cells4.length; _c5 < _cLen5; _c5++) {
          if (_c5 === physicalIndex) continue;
          _cells4[_c5].rowSpan += 1;
        }
        currentRow.parentNode.insertBefore(newRow, currentRow.nextElementSibling);
      }
    }
    this.focusEdge(currentCell);
    this.plugins.table.setPositionControllerDiv.call(this, currentCell, true);
  },
  mergeCells: function mergeCells() {
    var tablePlugin = this.plugins.table;
    var contextTable = this.context.table;
    var util = this.util;
    var ref = tablePlugin._ref;
    var selectedCells = tablePlugin._selectedCells;
    var mergeCell = selectedCells[0];
    var emptyRowFirst = null;
    var emptyRowLast = null;
    var cs = ref.ce - ref.cs + 1;
    var rs = ref.re - ref.rs + 1;
    var mergeHTML = '';
    var row = null;
    for (var i = 1, len = selectedCells.length, cell, ch; i < len; i++) {
      cell = selectedCells[i];
      if (row !== cell.parentNode) row = cell.parentNode;
      ch = cell.children;
      for (var c = 0, cLen = ch.length; c < cLen; c++) {
        if (util.isFormatElement(ch[c]) && util.onlyZeroWidthSpace(ch[c].textContent)) {
          util.removeItem(ch[c]);
        }
      }
      mergeHTML += cell.innerHTML;
      util.removeItem(cell);
      if (row.cells.length === 0) {
        if (!emptyRowFirst) emptyRowFirst = row;else emptyRowLast = row;
        rs -= 1;
      }
    }
    if (emptyRowFirst) {
      var rows = contextTable._trElements;
      var rowIndexFirst = util.getArrayIndex(rows, emptyRowFirst);
      var rowIndexLast = util.getArrayIndex(rows, emptyRowLast || emptyRowFirst);
      var removeRows = [];
      for (var _i12 = 0, cells; _i12 <= rowIndexLast; _i12++) {
        cells = rows[_i12].cells;
        if (cells.length === 0) {
          removeRows.push(rows[_i12]);
          continue;
        }
        for (var _c6 = 0, _cLen6 = cells.length, _cell6, _rs2; _c6 < _cLen6; _c6++) {
          _cell6 = cells[_c6];
          _rs2 = _cell6.rowSpan - 1;
          if (_rs2 > 0 && _i12 + _rs2 >= rowIndexFirst) {
            _cell6.rowSpan -= util.getOverlapRangeAtIndex(rowIndexFirst, rowIndexLast, _i12, _i12 + _rs2);
          }
        }
      }
      for (var _i13 = 0, _len8 = removeRows.length; _i13 < _len8; _i13++) {
        util.removeItem(removeRows[_i13]);
      }
    }
    mergeCell.innerHTML += mergeHTML;
    mergeCell.colSpan = cs;
    mergeCell.rowSpan = rs;
    this.controllersOff();
    tablePlugin.setActiveButton.call(this, true, false);
    tablePlugin.call_controller_tableEdit.call(this, mergeCell);
    util.addClass(mergeCell, 'se-table-selected-cell');
    this.focusEdge(mergeCell);
  },
  toggleHeader: function toggleHeader() {
    var util = this.util;
    var headerButton = this.context.table.headerButton;
    var active = util.hasClass(headerButton, 'active');
    var table = this.context.table._element;
    if (!active) {
      var header = util.createElement('THEAD');
      header.innerHTML = '<tr>' + this.plugins.table.createCells.call(this, 'th', this.context.table._logical_cellCnt, false) + '</tr>';
      table.insertBefore(header, table.firstElementChild);
    } else {
      util.removeItem(table.querySelector('thead'));
    }
    util.toggleClass(headerButton, 'active');
    if (/TH/i.test(this.context.table._tdElement.nodeName)) {
      this.controllersOff();
    } else {
      this.plugins.table.setPositionControllerDiv.call(this, this.context.table._tdElement, false);
    }
  },
  setTableStyle: function setTableStyle(styles) {
    var contextTable = this.context.table;
    var tableElement = contextTable._element;
    var icon, span, sizeIcon, text;
    if (styles.indexOf('width') > -1) {
      icon = contextTable.resizeButton.firstElementChild;
      span = contextTable.resizeText;
      if (!contextTable._maxWidth) {
        sizeIcon = contextTable.icons.expansion;
        text = contextTable.maxText;
        contextTable.columnFixedButton.style.display = 'none';
        this.util.removeClass(tableElement, 'se-table-size-100');
        this.util.addClass(tableElement, 'se-table-size-auto');
      } else {
        sizeIcon = contextTable.icons.reduction;
        text = contextTable.minText;
        contextTable.columnFixedButton.style.display = 'block';
        this.util.removeClass(tableElement, 'se-table-size-auto');
        this.util.addClass(tableElement, 'se-table-size-100');
      }
      this.util.changeElement(icon, sizeIcon);
      this.util.changeTxt(span, text);
    }
    if (styles.indexOf('column') > -1) {
      if (!contextTable._fixedColumn) {
        this.util.removeClass(tableElement, 'se-table-layout-fixed');
        this.util.addClass(tableElement, 'se-table-layout-auto');
        this.util.removeClass(contextTable.columnFixedButton, 'active');
      } else {
        this.util.removeClass(tableElement, 'se-table-layout-auto');
        this.util.addClass(tableElement, 'se-table-layout-fixed');
        this.util.addClass(contextTable.columnFixedButton, 'active');
      }
    }
  },
  setActiveButton: function setActiveButton(fixedCell, selectedCell) {
    var contextTable = this.context.table;
    if (/^TH$/i.test(fixedCell.nodeName)) {
      contextTable.insertRowAboveButton.setAttribute('disabled', true);
      contextTable.insertRowBelowButton.setAttribute('disabled', true);
    } else {
      contextTable.insertRowAboveButton.removeAttribute('disabled');
      contextTable.insertRowBelowButton.removeAttribute('disabled');
    }
    if (!selectedCell || fixedCell === selectedCell) {
      contextTable.splitButton.removeAttribute('disabled');
      contextTable.mergeButton.setAttribute('disabled', true);
    } else {
      contextTable.splitButton.setAttribute('disabled', true);
      contextTable.mergeButton.removeAttribute('disabled');
    }
  },
  // multi selecte
  _bindOnSelect: null,
  _bindOffSelect: null,
  _bindOffShift: null,
  _selectedCells: null,
  _shift: false,
  _fixedCell: null,
  _fixedCellName: null,
  _selectedCell: null,
  _selectedTable: null,
  _ref: null,
  _toggleEditor: function _toggleEditor(enabled) {
    this.context.element.wysiwyg.setAttribute('contenteditable', enabled);
    if (enabled) this.util.removeClass(this.context.element.wysiwyg, 'se-disabled');else this.util.addClass(this.context.element.wysiwyg, 'se-disabled');
  },
  _offCellMultiSelect: function _offCellMultiSelect(e) {
    e.stopPropagation();
    var tablePlugin = this.plugins.table;
    if (!tablePlugin._shift) {
      tablePlugin._removeEvents.call(this);
      tablePlugin._toggleEditor.call(this, true);
    } else if (tablePlugin._initBind) {
      this._wd.removeEventListener('touchmove', tablePlugin._initBind);
      tablePlugin._initBind = null;
    }
    if (!tablePlugin._fixedCell || !tablePlugin._selectedTable) return;
    tablePlugin.setActiveButton.call(this, tablePlugin._fixedCell, tablePlugin._selectedCell);
    tablePlugin.call_controller_tableEdit.call(this, tablePlugin._selectedCell || tablePlugin._fixedCell);
    tablePlugin._selectedCells = tablePlugin._selectedTable.querySelectorAll('.se-table-selected-cell');
    if (tablePlugin._selectedCell && tablePlugin._fixedCell) this.focusEdge(tablePlugin._selectedCell);
    if (!tablePlugin._shift) {
      tablePlugin._fixedCell = null;
      tablePlugin._selectedCell = null;
      tablePlugin._fixedCellName = null;
    }
  },
  _onCellMultiSelect: function _onCellMultiSelect(e) {
    this._antiBlur = true;
    var tablePlugin = this.plugins.table;
    var target = this.util.getParentElement(e.target, this.util.isCell);
    if (tablePlugin._shift) {
      if (target === tablePlugin._fixedCell) tablePlugin._toggleEditor.call(this, true);else tablePlugin._toggleEditor.call(this, false);
    } else if (!tablePlugin._ref) {
      if (target === tablePlugin._fixedCell) return;else tablePlugin._toggleEditor.call(this, false);
    }
    if (!target || target === tablePlugin._selectedCell || tablePlugin._fixedCellName !== target.nodeName || tablePlugin._selectedTable !== this.util.getParentElement(target, 'TABLE')) {
      return;
    }
    tablePlugin._selectedCell = target;
    tablePlugin._setMultiCells.call(this, tablePlugin._fixedCell, target);
  },
  _setMultiCells: function _setMultiCells(startCell, endCell) {
    var tablePlugin = this.plugins.table;
    var rows = tablePlugin._selectedTable.rows;
    var util = this.util;
    var selectedCells = tablePlugin._selectedTable.querySelectorAll('.se-table-selected-cell');
    for (var i = 0, len = selectedCells.length; i < len; i++) {
      util.removeClass(selectedCells[i], 'se-table-selected-cell');
    }
    if (startCell === endCell) {
      util.addClass(startCell, 'se-table-selected-cell');
      if (!tablePlugin._shift) return;
    }
    var findSelectedCell = true;
    var spanIndex = [];
    var rowSpanArr = [];
    var ref = tablePlugin._ref = {
      _i: 0,
      cs: null,
      ce: null,
      rs: null,
      re: null
    };
    for (var _i14 = 0, _len9 = rows.length, cells, colSpan; _i14 < _len9; _i14++) {
      cells = rows[_i14].cells;
      colSpan = 0;
      for (var c = 0, cLen = cells.length, cell, logcalIndex, cs, rs; c < cLen; c++) {
        cell = cells[c];
        cs = cell.colSpan - 1;
        rs = cell.rowSpan - 1;
        logcalIndex = c + colSpan;
        if (spanIndex.length > 0) {
          for (var r = 0, arr; r < spanIndex.length; r++) {
            arr = spanIndex[r];
            if (arr.row > _i14) continue;
            if (logcalIndex >= arr.index) {
              colSpan += arr.cs;
              logcalIndex += arr.cs;
              arr.rs -= 1;
              arr.row = _i14 + 1;
              if (arr.rs < 1) {
                spanIndex.splice(r, 1);
                r--;
              }
            } else if (c === cLen - 1) {
              arr.rs -= 1;
              arr.row = _i14 + 1;
              if (arr.rs < 1) {
                spanIndex.splice(r, 1);
                r--;
              }
            }
          }
        }
        if (findSelectedCell) {
          if (cell === startCell || cell === endCell) {
            ref.cs = ref.cs !== null && ref.cs < logcalIndex ? ref.cs : logcalIndex;
            ref.ce = ref.ce !== null && ref.ce > logcalIndex + cs ? ref.ce : logcalIndex + cs;
            ref.rs = ref.rs !== null && ref.rs < _i14 ? ref.rs : _i14;
            ref.re = ref.re !== null && ref.re > _i14 + rs ? ref.re : _i14 + rs;
            ref._i += 1;
          }
          if (ref._i === 2) {
            findSelectedCell = false;
            spanIndex = [];
            rowSpanArr = [];
            _i14 = -1;
            break;
          }
        } else if (util.getOverlapRangeAtIndex(ref.cs, ref.ce, logcalIndex, logcalIndex + cs) && util.getOverlapRangeAtIndex(ref.rs, ref.re, _i14, _i14 + rs)) {
          var newCs = ref.cs < logcalIndex ? ref.cs : logcalIndex;
          var newCe = ref.ce > logcalIndex + cs ? ref.ce : logcalIndex + cs;
          var newRs = ref.rs < _i14 ? ref.rs : _i14;
          var newRe = ref.re > _i14 + rs ? ref.re : _i14 + rs;
          if (ref.cs !== newCs || ref.ce !== newCe || ref.rs !== newRs || ref.re !== newRe) {
            ref.cs = newCs;
            ref.ce = newCe;
            ref.rs = newRs;
            ref.re = newRe;
            _i14 = -1;
            spanIndex = [];
            rowSpanArr = [];
            break;
          }
          util.addClass(cell, 'se-table-selected-cell');
        }
        if (rs > 0) {
          rowSpanArr.push({
            index: logcalIndex,
            cs: cs + 1,
            rs: rs,
            row: -1
          });
        }
        colSpan += cell.colSpan - 1;
      }
      spanIndex = spanIndex.concat(rowSpanArr).sort(function (a, b) {
        return a.index - b.index;
      });
      rowSpanArr = [];
    }
  },
  _removeEvents: function _removeEvents() {
    var tablePlugin = this.plugins.table;
    if (tablePlugin._initBind) {
      this._wd.removeEventListener('touchmove', tablePlugin._initBind);
      tablePlugin._initBind = null;
    }
    if (tablePlugin._bindOnSelect) {
      this._wd.removeEventListener('mousedown', tablePlugin._bindOnSelect);
      this._wd.removeEventListener('mousemove', tablePlugin._bindOnSelect);
      tablePlugin._bindOnSelect = null;
    }
    if (tablePlugin._bindOffSelect) {
      this._wd.removeEventListener('mouseup', tablePlugin._bindOffSelect);
      tablePlugin._bindOffSelect = null;
    }
    if (tablePlugin._bindOffShift) {
      this._wd.removeEventListener('keyup', tablePlugin._bindOffShift);
      tablePlugin._bindOffShift = null;
    }
  },
  _initBind: null,
  onTableCellMultiSelect: function onTableCellMultiSelect(tdElement, shift) {
    var tablePlugin = this.plugins.table;
    tablePlugin._removeEvents.call(this);
    this.controllersOff();
    tablePlugin._shift = shift;
    tablePlugin._fixedCell = tdElement;
    tablePlugin._fixedCellName = tdElement.nodeName;
    tablePlugin._selectedTable = this.util.getParentElement(tdElement, 'TABLE');
    var selectedCells = tablePlugin._selectedTable.querySelectorAll('.se-table-selected-cell');
    for (var i = 0, len = selectedCells.length; i < len; i++) {
      this.util.removeClass(selectedCells[i], 'se-table-selected-cell');
    }
    this.util.addClass(tdElement, 'se-table-selected-cell');
    tablePlugin._bindOnSelect = tablePlugin._onCellMultiSelect.bind(this);
    tablePlugin._bindOffSelect = tablePlugin._offCellMultiSelect.bind(this);
    if (!shift) {
      this._wd.addEventListener('mousemove', tablePlugin._bindOnSelect, false);
    } else {
      tablePlugin._bindOffShift = function () {
        this.controllersOn(this.context.table.resizeDiv, this.context.table.tableController, this.plugins.table.init.bind(this), tdElement, 'table');
        if (!tablePlugin._ref) this.controllersOff();
      }.bind(this);
      this._wd.addEventListener('keyup', tablePlugin._bindOffShift, false);
      this._wd.addEventListener('mousedown', tablePlugin._bindOnSelect, false);
    }
    this._wd.addEventListener('mouseup', tablePlugin._bindOffSelect, false);
    tablePlugin._initBind = tablePlugin.init.bind(this);
    this._wd.addEventListener('touchmove', tablePlugin._initBind, false);
  },
  onClick_tableController: function onClick_tableController(e) {
    e.stopPropagation();
    var target = e.target.getAttribute('data-command') ? e.target : e.target.parentNode;
    if (target.getAttribute('disabled')) return;
    var command = target.getAttribute('data-command');
    var value = target.getAttribute('data-value');
    var option = target.getAttribute('data-option');
    var tablePlugin = this.plugins.table;
    if (typeof tablePlugin._closeSplitMenu === 'function') {
      tablePlugin._closeSplitMenu();
      if (command === 'onsplit') return;
    }
    if (!command) return;
    e.preventDefault();
    var contextTable = this.context.table;
    switch (command) {
      case 'insert':
      case 'delete':
        tablePlugin.editTable.call(this, value, option);
        break;
      case 'header':
        tablePlugin.toggleHeader.call(this);
        break;
      case 'onsplit':
        tablePlugin.openSplitMenu.call(this);
        break;
      case 'split':
        tablePlugin.splitCells.call(this, value);
        break;
      case 'merge':
        tablePlugin.mergeCells.call(this);
        break;
      case 'resize':
        contextTable._maxWidth = !contextTable._maxWidth;
        tablePlugin.setTableStyle.call(this, 'width');
        tablePlugin.setPositionControllerTop.call(this, contextTable._element);
        tablePlugin.setPositionControllerDiv.call(this, contextTable._tdElement, tablePlugin._shift);
        break;
      case 'layout':
        contextTable._fixedColumn = !contextTable._fixedColumn;
        tablePlugin.setTableStyle.call(this, 'column');
        tablePlugin.setPositionControllerTop.call(this, contextTable._element);
        tablePlugin.setPositionControllerDiv.call(this, contextTable._tdElement, tablePlugin._shift);
        break;
      case 'remove':
        var emptyDiv = contextTable._element.parentNode;
        this.util.removeItem(contextTable._element);
        this.controllersOff();
        if (emptyDiv !== this.context.element.wysiwyg) this.util.removeItemAllParents(emptyDiv, function (current) {
          return current.childNodes.length === 0;
        }, null);
        this.focus();
    }

    // history stack
    this.history.push(false);
  }
});
// CONCATENATED MODULE: ./node_modules/suneditor/src/plugins/submenu/formatBlock.js
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2017 JiHong Lee.
 * MIT license.
 */


/* harmony default export */ var formatBlock = ({
  name: 'formatBlock',
  display: 'submenu',
  add: function add(core, targetElement) {
    var context = core.context;
    context.formatBlock = {
      targetText: targetElement.querySelector('.txt'),
      targetTooltip: targetElement.parentNode.querySelector('.se-tooltip-text'),
      _formatList: null,
      currentFormat: ''
    };

    /** set submenu */
    var listDiv = this.setSubmenu(core);

    /** add event listeners */
    listDiv.querySelector('ul').addEventListener('click', this.pickUp.bind(core));
    context.formatBlock._formatList = listDiv.querySelectorAll('li button');

    /** append target button menu */
    core.initMenuTarget(this.name, targetElement, listDiv);

    /** empty memory */
    listDiv = null;
  },
  setSubmenu: function setSubmenu(core) {
    var option = core.options;
    var lang_toolbar = core.lang.toolbar;
    var listDiv = core.util.createElement('DIV');
    listDiv.className = 'se-submenu se-list-layer se-list-format';
    var defaultFormats = ['p', 'div', 'blockquote', 'pre', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6'];
    var formatList = !option.formats || option.formats.length === 0 ? defaultFormats : option.formats;
    var list = '<div class="se-list-inner"><ul class="se-list-basic">';
    for (var i = 0, len = formatList.length, format, tagName, command, name, h, attrs, className; i < len; i++) {
      format = formatList[i];
      if (typeof format === 'string' && defaultFormats.indexOf(format) > -1) {
        tagName = format.toLowerCase();
        command = tagName === 'blockquote' ? 'range' : tagName === 'pre' ? 'free' : 'replace';
        h = /^h/.test(tagName) ? tagName.match(/\d+/)[0] : '';
        name = lang_toolbar['tag_' + (h ? 'h' : tagName)] + h;
        className = '';
        attrs = '';
      } else {
        tagName = format.tag.toLowerCase();
        command = format.command;
        name = format.name || tagName;
        className = format.class;
        attrs = className ? ' class="' + className + '"' : '';
      }
      list += '<li>' + '<button type="button" class="se-btn-list" data-command="' + command + '" data-value="' + tagName + '" data-class="' + className + '" title="' + name + '" aria-label="' + name + '">' + '<' + tagName + attrs + '>' + name + '</' + tagName + '>' + '</button></li>';
    }
    list += '</ul></div>';
    listDiv.innerHTML = list;
    return listDiv;
  },
  /**
  * @Override core
  */
  active: function active(element) {
    var formatTitle = this.lang.toolbar.formats;
    var target = this.context.formatBlock.targetText;
    if (!element) {
      this.util.changeTxt(target, formatTitle);
    } else if (this.util.isFormatElement(element)) {
      var formatContext = this.context.formatBlock;
      var formatList = formatContext._formatList;
      var nodeName = element.nodeName.toLowerCase();
      var className = (element.className.match(/(\s|^)__se__format__[^\s]+/) || [''])[0].trim();
      for (var i = 0, len = formatList.length, f; i < len; i++) {
        f = formatList[i];
        if (nodeName === f.getAttribute('data-value') && className === f.getAttribute('data-class')) {
          formatTitle = f.title;
          break;
        }
      }
      this.util.changeTxt(target, formatTitle);
      target.setAttribute('data-value', nodeName);
      target.setAttribute('data-class', className);
      return true;
    }
    return false;
  },
  /**
  * @Override submenu
  */
  on: function on() {
    var formatContext = this.context.formatBlock;
    var formatList = formatContext._formatList;
    var target = formatContext.targetText;
    var currentFormat = (target.getAttribute('data-value') || '') + (target.getAttribute('data-class') || '');
    if (currentFormat !== formatContext.currentFormat) {
      for (var i = 0, len = formatList.length, f; i < len; i++) {
        f = formatList[i];
        if (currentFormat === f.getAttribute('data-value') + f.getAttribute('data-class')) {
          this.util.addClass(f, 'active');
        } else {
          this.util.removeClass(f, 'active');
        }
      }
      formatContext.currentFormat = currentFormat;
    }
  },
  pickUp: function pickUp(e) {
    e.preventDefault();
    e.stopPropagation();
    var target = e.target;
    var command = null,
      value = null,
      tag = null,
      className = '';
    while (!command && !/UL/i.test(target.tagName)) {
      command = target.getAttribute('data-command');
      value = target.getAttribute('data-value');
      className = target.getAttribute('data-class');
      if (command) {
        tag = target.firstChild;
        break;
      }
      target = target.parentNode;
    }
    if (!command) return;

    // blockquote
    if (command === 'range') {
      var rangeElement = tag.cloneNode(false);
      this.applyRangeFormatElement(rangeElement);
    }
    // free, replace
    else {
      var range = this.getRange();
      var selectedFormsts = this.getSelectedElementsAndComponents(false);
      if (selectedFormsts.length === 0) {
        range = this.getRange_addLine(range, null);
        selectedFormsts = this.getSelectedElementsAndComponents(false);
        if (selectedFormsts.length === 0) return;
      }
      var startOffset = range.startOffset;
      var endOffset = range.endOffset;
      var util = this.util;
      var first = selectedFormsts[0];
      var last = selectedFormsts[selectedFormsts.length - 1];
      var firstPath = util.getNodePath(range.startContainer, first, null, null);
      var lastPath = util.getNodePath(range.endContainer, last, null, null);

      // remove selected list
      var rlist = this.detachList(selectedFormsts, false);
      if (rlist.sc) first = rlist.sc;
      if (rlist.ec) last = rlist.ec;

      // change format tag
      this.setRange(util.getNodeFromPath(firstPath, first), startOffset, util.getNodeFromPath(lastPath, last), endOffset);
      var modifiedFormsts = this.getSelectedElementsAndComponents(false);

      // free format
      if (command === 'free') {
        var len = modifiedFormsts.length - 1;
        var parentNode = modifiedFormsts[len].parentNode;
        var freeElement = tag.cloneNode(false);
        var focusElement = freeElement;
        for (var i = len, f, html, before, next, inner, isComp, _first = true; i >= 0; i--) {
          f = modifiedFormsts[i];
          if (f === (!modifiedFormsts[i + 1] ? null : modifiedFormsts[i + 1].parentNode)) continue;
          isComp = util.isComponent(f);
          html = isComp ? '' : f.innerHTML.replace(/(?!>)\s+(?=<)|\n/g, ' ');
          before = util.getParentElement(f, function (current) {
            return current.parentNode === parentNode;
          });
          if (parentNode !== f.parentNode || isComp) {
            if (util.isFormatElement(parentNode)) {
              parentNode.parentNode.insertBefore(freeElement, parentNode.nextSibling);
              parentNode = parentNode.parentNode;
            } else {
              parentNode.insertBefore(freeElement, before ? before.nextSibling : null);
              parentNode = f.parentNode;
            }
            next = freeElement.nextSibling;
            if (next && freeElement.nodeName === next.nodeName && util.isSameAttributes(freeElement, next)) {
              freeElement.innerHTML += '<BR>' + next.innerHTML;
              util.removeItem(next);
            }
            freeElement = tag.cloneNode(false);
            _first = true;
          }
          inner = freeElement.innerHTML;
          freeElement.innerHTML = (_first || !html || !inner || /<br>$/i.test(html) ? html : html + '<BR>') + inner;
          if (i === 0) {
            parentNode.insertBefore(freeElement, f);
            next = f.nextSibling;
            if (next && freeElement.nodeName === next.nodeName && util.isSameAttributes(freeElement, next)) {
              freeElement.innerHTML += '<BR>' + next.innerHTML;
              util.removeItem(next);
            }
            var prev = freeElement.previousSibling;
            if (prev && freeElement.nodeName === prev.nodeName && util.isSameAttributes(freeElement, prev)) {
              prev.innerHTML += '<BR>' + freeElement.innerHTML;
              util.removeItem(freeElement);
            }
          }
          if (!isComp) util.removeItem(f);
          if (!!html) _first = false;
        }
        this.setRange(focusElement, 0, focusElement, 0);
      }
      // replace format
      else {
        for (var _i = 0, _len = modifiedFormsts.length, node, newFormat; _i < _len; _i++) {
          node = modifiedFormsts[_i];
          if ((node.nodeName.toLowerCase() !== value.toLowerCase() || (node.className.match(/(\s|^)__se__format__[^\s]+/) || [''])[0].trim() !== className) && !util.isComponent(node)) {
            newFormat = tag.cloneNode(false);
            util.copyFormatAttributes(newFormat, node);
            newFormat.innerHTML = node.innerHTML;
            node.parentNode.replaceChild(newFormat, node);
          }
          if (_i === 0) first = newFormat || node;
          if (_i === _len - 1) last = newFormat || node;
          newFormat = null;
        }
        this.setRange(util.getNodeFromPath(firstPath, first), startOffset, util.getNodeFromPath(lastPath, last), endOffset);
      }

      // history stack
      this.history.push(false);
    }
    this.submenuOff();
  }
});
// CONCATENATED MODULE: ./node_modules/suneditor/src/plugins/submenu/lineHeight.js
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 20197 JiHong Lee.
 * MIT license.
 */


/* harmony default export */ var lineHeight = ({
  name: 'lineHeight',
  display: 'submenu',
  add: function add(core, targetElement) {
    var context = core.context;
    context.lineHeight = {
      _sizeList: null,
      currentSize: -1
    };

    /** set submenu */
    var listDiv = this.setSubmenu(core);
    var listUl = listDiv.querySelector('ul');

    /** add event listeners */
    listUl.addEventListener('click', this.pickup.bind(core));
    context.lineHeight._sizeList = listUl.querySelectorAll('li button');

    /** append target button menu */
    core.initMenuTarget(this.name, targetElement, listDiv);

    /** empty memory */
    listDiv = null, listUl = null;
  },
  setSubmenu: function setSubmenu(core) {
    var option = core.options;
    var lang = core.lang;
    var listDiv = core.util.createElement('DIV');
    listDiv.className = 'se-submenu se-list-layer';
    var sizeList = !option.lineHeights ? [{
      text: '1',
      value: 1
    }, {
      text: '1.15',
      value: 1.15
    }, {
      text: '1.5',
      value: 1.5
    }, {
      text: '2',
      value: 2
    }] : option.lineHeights;
    var list = '<div class="se-list-inner">' + '<ul class="se-list-basic">' + '<li><button type="button" class="default_value se-btn-list" title="' + lang.toolbar.default + '" aria-label="' + lang.toolbar.default + '">(' + lang.toolbar.default + ')</button></li>';
    for (var i = 0, len = sizeList.length, size; i < len; i++) {
      size = sizeList[i];
      list += '<li><button type="button" class="se-btn-list" data-value="' + size.value + '" title="' + size.text + '" aria-label="' + size.text + '">' + size.text + '</button></li>';
    }
    list += '</ul></div>';
    listDiv.innerHTML = list;
    return listDiv;
  },
  /**
  * @Override submenu
  */
  on: function on() {
    var lineHeightContext = this.context.lineHeight;
    var sizeList = lineHeightContext._sizeList;
    var format = this.util.getFormatElement(this.getSelectionNode());
    var currentSize = !format ? '' : format.style.lineHeight + '';
    if (currentSize !== lineHeightContext.currentSize) {
      for (var i = 0, len = sizeList.length; i < len; i++) {
        if (currentSize === sizeList[i].getAttribute('data-value')) {
          this.util.addClass(sizeList[i], 'active');
        } else {
          this.util.removeClass(sizeList[i], 'active');
        }
      }
      lineHeightContext.currentSize = currentSize;
    }
  },
  pickup: function pickup(e) {
    if (!/^BUTTON$/i.test(e.target.tagName)) return false;
    e.preventDefault();
    e.stopPropagation();
    var value = e.target.getAttribute('data-value') || '';
    var formats = this.getSelectedElements();
    for (var i = 0, len = formats.length; i < len; i++) {
      formats[i].style.lineHeight = value;
    }
    this.submenuOff();

    // history stack
    this.history.push(false);
  }
});
// CONCATENATED MODULE: ./node_modules/suneditor/src/plugins/submenu/template.js
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2017 JiHong Lee.
 * MIT license.
 */


/* harmony default export */ var template = ({
  name: 'template',
  display: 'submenu',
  add: function add(core, targetElement) {
    var context = core.context;
    context.template = {
      selectedIndex: -1
    };

    /** set submenu */
    var templateDiv = this.setSubmenu(core);

    /** add event listeners */
    templateDiv.querySelector('ul').addEventListener('click', this.pickup.bind(core));

    /** append target button menu */
    core.initMenuTarget(this.name, targetElement, templateDiv);

    /** empty memory */
    templateDiv = null;
  },
  setSubmenu: function setSubmenu(core) {
    var templateList = core.options.templates;
    if (!templateList || templateList.length === 0) {
      throw Error('[SUNEDITOR.plugins.template.fail] To use the "template" plugin, please define the "templates" option.');
    }
    var listDiv = core.util.createElement('DIV');
    listDiv.className = 'se-list-layer';
    var list = '<div class="se-submenu se-list-inner">' + '<ul class="se-list-basic">';
    for (var i = 0, len = templateList.length, t; i < len; i++) {
      t = templateList[i];
      list += '<li><button type="button" class="se-btn-list" data-value="' + i + '" title="' + t.name + '" aria-label="' + t.name + '">' + t.name + '</button></li>';
    }
    list += '</ul></div>';
    listDiv.innerHTML = list;
    return listDiv;
  },
  pickup: function pickup(e) {
    if (!/^BUTTON$/i.test(e.target.tagName)) return false;
    e.preventDefault();
    e.stopPropagation();
    this.context.template.selectedIndex = e.target.getAttribute('data-value') * 1;
    var temp = this.options.templates[this.context.template.selectedIndex];
    if (temp.html) {
      this.setContents(temp.html);
    } else {
      this.submenuOff();
      throw Error('[SUNEDITOR.template.fail] cause : "templates[i].html not found"');
    }
    this.submenuOff();
  }
});
// CONCATENATED MODULE: ./node_modules/suneditor/src/plugins/submenu/paragraphStyle.js
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2017 JiHong Lee.
 * MIT license.
 */


/* harmony default export */ var paragraphStyle = ({
  name: 'paragraphStyle',
  display: 'submenu',
  add: function add(core, targetElement) {
    var context = core.context;
    context.paragraphStyle = {
      _classList: null
    };

    /** set submenu */
    var listDiv = this.setSubmenu(core);

    /** add event listeners */
    listDiv.querySelector('ul').addEventListener('click', this.pickUp.bind(core));
    context.paragraphStyle._classList = listDiv.querySelectorAll('li button');

    /** append target button menu */
    core.initMenuTarget(this.name, targetElement, listDiv);

    /** empty memory */
    listDiv = null;
  },
  setSubmenu: function setSubmenu(core) {
    var option = core.options;
    var listDiv = core.util.createElement('DIV');
    listDiv.className = 'se-submenu se-list-layer se-list-format';
    var menuLang = core.lang.menu;
    var defaultList = {
      spaced: {
        name: menuLang.spaced,
        class: '__se__p-spaced',
        _class: ''
      },
      bordered: {
        name: menuLang.bordered,
        class: '__se__p-bordered',
        _class: ''
      },
      neon: {
        name: menuLang.neon,
        class: '__se__p-neon',
        _class: ''
      }
    };
    var paragraphStyles = !option.paragraphStyles || option.paragraphStyles.length === 0 ? ['spaced', 'bordered', 'neon'] : option.paragraphStyles;
    var list = '<div class="se-list-inner"><ul class="se-list-basic">';
    for (var i = 0, len = paragraphStyles.length, p, name, attrs, _class; i < len; i++) {
      p = paragraphStyles[i];
      if (typeof p === 'string') {
        var defaultStyle = defaultList[p.toLowerCase()];
        if (!defaultStyle) continue;
        p = defaultStyle;
      }
      name = p.name;
      attrs = p.class ? ' class="' + p.class + '"' : '';
      _class = p._class;
      list += '<li>' + '<button type="button" class="se-btn-list' + (_class ? ' ' + _class : '') + '" data-value="' + p.class + '" title="' + name + '" aria-label="' + name + '">' + '<div' + attrs + '>' + name + '</div>' + '</button></li>';
    }
    list += '</ul></div>';
    listDiv.innerHTML = list;
    return listDiv;
  },
  /**
  * @Override submenu
  */
  on: function on() {
    var paragraphContext = this.context.paragraphStyle;
    var paragraphList = paragraphContext._classList;
    var currentFormat = this.util.getFormatElement(this.getSelectionNode());
    for (var i = 0, len = paragraphList.length; i < len; i++) {
      if (this.util.hasClass(currentFormat, paragraphList[i].getAttribute('data-value'))) {
        this.util.addClass(paragraphList[i], 'active');
      } else {
        this.util.removeClass(paragraphList[i], 'active');
      }
    }
  },
  pickUp: function pickUp(e) {
    e.preventDefault();
    e.stopPropagation();
    var target = e.target;
    var value = null;
    while (!/^UL$/i.test(target.tagName)) {
      value = target.getAttribute('data-value');
      if (value) break;
      target = target.parentNode;
    }
    if (!value) return;
    var selectedFormsts = this.getSelectedElements();
    if (selectedFormsts.length === 0) {
      this.getRange_addLine(this.getRange(), null);
      selectedFormsts = this.getSelectedElements();
      if (selectedFormsts.length === 0) return;
    }

    // change format class
    var toggleClass = this.util.hasClass(target, 'active') ? this.util.removeClass.bind(this.util) : this.util.addClass.bind(this.util);
    for (var i = 0, len = selectedFormsts.length; i < len; i++) {
      toggleClass(selectedFormsts[i], value);
    }
    this.submenuOff();

    // history stack
    this.history.push(false);
  }
});
// CONCATENATED MODULE: ./node_modules/suneditor/src/plugins/submenu/textStyle.js
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2017 JiHong Lee.
 * MIT license.
 */


/* harmony default export */ var textStyle = ({
  name: 'textStyle',
  display: 'submenu',
  add: function add(core, targetElement) {
    var context = core.context;
    context.textStyle = {
      _styleList: null
    };

    /** set submenu */
    var listDiv = this.setSubmenu(core);
    var listUl = listDiv.querySelector('ul');

    /** add event listeners */
    listUl.addEventListener('click', this.pickup.bind(core));
    context.textStyle._styleList = listDiv.querySelectorAll('li button');

    /** append target button menu */
    core.initMenuTarget(this.name, targetElement, listDiv);

    /** empty memory */
    listDiv = null, listUl = null;
  },
  setSubmenu: function setSubmenu(core) {
    var option = core.options;
    var listDiv = core.util.createElement('DIV');
    listDiv.className = 'se-submenu se-list-layer se-list-format';
    var defaultList = {
      code: {
        name: core.lang.menu.code,
        class: '__se__t-code',
        tag: 'code'
      },
      translucent: {
        name: core.lang.menu.translucent,
        style: 'opacity: 0.5;',
        tag: 'span'
      },
      shadow: {
        name: core.lang.menu.shadow,
        class: '__se__t-shadow',
        tag: 'span'
      }
    };
    var styleList = !option.textStyles ? core._w.Object.keys(defaultList) : option.textStyles;
    var list = '<div class="se-list-inner"><ul class="se-list-basic">';
    for (var i = 0, len = styleList.length, t, tag, name, attrs, command, value, _class; i < len; i++) {
      t = styleList[i];
      attrs = '', value = '', command = [];
      if (typeof t === 'string') {
        var defaultStyle = defaultList[t.toLowerCase()];
        if (!defaultStyle) continue;
        t = defaultStyle;
      }
      name = t.name;
      tag = t.tag || 'span';
      _class = t._class;
      if (t.style) {
        attrs += ' style="' + t.style + '"';
        value += t.style.replace(/:[^;]+(;|$)\s*/g, ',');
        command.push('style');
      }
      if (t.class) {
        attrs += ' class="' + t.class + '"';
        value += '.' + t.class.trim().replace(/\s+/g, ',.');
        command.push('class');
      }
      value = value.replace(/,$/, '');
      list += '<li>' + '<button type="button" class="se-btn-list' + (_class ? ' ' + _class : '') + '" data-command="' + tag + '" data-value="' + value + '" title="' + name + '" aria-label="' + name + '">' + '<' + tag + attrs + '>' + name + '</' + tag + '>' + '</button></li>';
    }
    list += '</ul></div>';
    listDiv.innerHTML = list;
    return listDiv;
  },
  /**
  * @Override submenu
  */
  on: function on() {
    var util = this.util;
    var textStyleContext = this.context.textStyle;
    var styleButtonList = textStyleContext._styleList;
    var selectionNode = this.getSelectionNode();
    for (var i = 0, len = styleButtonList.length, btn, data, active; i < len; i++) {
      btn = styleButtonList[i];
      data = btn.getAttribute('data-value').split(',');
      for (var v = 0, node, value; v < data.length; v++) {
        node = selectionNode;
        active = false;
        while (node && !util.isFormatElement(node) && !util.isComponent(node)) {
          if (node.nodeName.toLowerCase() === btn.getAttribute('data-command').toLowerCase()) {
            value = data[v];
            if (/^\./.test(value) ? util.hasClass(node, value.replace(/^\./, '')) : !!node.style[value]) {
              active = true;
              break;
            }
          }
          node = node.parentNode;
        }
        if (!active) break;
      }
      active ? util.addClass(btn, 'active') : util.removeClass(btn, 'active');
    }
  },
  pickup: function pickup(e) {
    e.preventDefault();
    e.stopPropagation();
    var target = e.target;
    var command = null,
      tag = null;
    while (!command && !/UL/i.test(target.tagName)) {
      command = target.getAttribute('data-command');
      if (command) {
        tag = target.firstChild;
        break;
      }
      target = target.parentNode;
    }
    if (!command) return;
    var checkStyles = tag.style.cssText.replace(/:.+(;|$)/g, ',').split(',');
    checkStyles.pop();
    var classes = tag.classList;
    for (var i = 0, len = classes.length; i < len; i++) {
      checkStyles.push('.' + classes[i]);
    }
    var newNode = this.util.hasClass(target, 'active') ? null : tag.cloneNode(false);
    var removeNodes = newNode ? null : [tag.nodeName];
    this.nodeChange(newNode, checkStyles, removeNodes, true);
    this.submenuOff();
  }
});
// EXTERNAL MODULE: ./node_modules/suneditor/src/plugins/modules/dialog.js
var dialog = __webpack_require__(533);
var dialog_default = /*#__PURE__*/__webpack_require__.n(dialog);

// CONCATENATED MODULE: ./node_modules/suneditor/src/plugins/modules/_selectMenu.js
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2018 JiHong Lee.
 * MIT license.
 */


/* harmony default export */ var _selectMenu = ({
  name: 'selectMenu',
  add: function add(core) {
    core.context.selectMenu = {
      caller: {},
      callerContext: null
    };
  },
  setForm: function setForm() {
    return '<div class="se-select-list"></div>';
  },
  createList: function createList(listContext, items, html) {
    listContext.form.innerHTML = '<ul>' + html + '</ul>';
    listContext.items = items;
    listContext.menus = listContext.form.querySelectorAll('li');
  },
  initEvent: function initEvent(pluginName, forms) {
    var form = forms.querySelector('.se-select-list');
    var context = this.context.selectMenu.caller[pluginName] = {
      form: form,
      items: [],
      menus: [],
      index: -1,
      item: null,
      clickMethod: null,
      callerName: pluginName
    };
    form.addEventListener('mousedown', this.plugins.selectMenu.onMousedown_list);
    form.addEventListener('mousemove', this.plugins.selectMenu.onMouseMove_list.bind(this, context));
    form.addEventListener('click', this.plugins.selectMenu.onClick_list.bind(this, context));
  },
  onMousedown_list: function onMousedown_list(e) {
    e.preventDefault();
    e.stopPropagation();
  },
  onMouseMove_list: function onMouseMove_list(context, e) {
    this.util.addClass(context.form, '__se_select-menu-mouse-move');
    var index = e.target.getAttribute('data-index');
    if (!index) return;
    context.index = index * 1;
  },
  onClick_list: function onClick_list(context, e) {
    var index = e.target.getAttribute('data-index');
    if (!index) return;
    context.clickMethod.call(this, context.items[index]);
  },
  moveItem: function moveItem(listContext, num) {
    this.util.removeClass(listContext.form, '__se_select-menu-mouse-move');
    num = listContext.index + num;
    var menus = listContext.menus;
    var len = menus.length;
    var selectIndex = listContext.index = num >= len ? 0 : num < 0 ? len - 1 : num;
    for (var i = 0; i < len; i++) {
      if (i === selectIndex) {
        this.util.addClass(menus[i], 'active');
      } else {
        this.util.removeClass(menus[i], 'active');
      }
    }
    listContext.item = listContext.items[selectIndex];
  },
  getItem: function getItem(listContext, index) {
    index = !index || index < 0 ? listContext.index : index;
    return listContext.items[index];
  },
  on: function on(callerName, clickMethod) {
    var listContext = this.context.selectMenu.caller[callerName];
    this.context.selectMenu.callerContext = listContext;
    listContext.clickMethod = clickMethod;
    listContext.callerName = callerName;
  },
  open: function open(listContext, positionHandler) {
    var form = listContext.form;
    form.style.visibility = 'hidden';
    form.style.display = 'block';
    positionHandler(form);
    form.style.visibility = '';
  },
  close: function close(listContext) {
    listContext.form.style.display = 'none';
    listContext.items = [];
    listContext.menus = [];
    listContext.index = -1;
    listContext.item = null;
  },
  init: function init(listContext) {
    if (!listContext) return;
    listContext.items = [];
    listContext.menus = [];
    listContext.index = -1;
    listContext.item = null;
    listContext.callerName = '';
    this.context.selectMenu.callerContext = null;
  }
});
// CONCATENATED MODULE: ./node_modules/suneditor/src/plugins/modules/_anchor.js
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2017 JiHong Lee.
 * MIT license.
 */



/* harmony default export */ var _anchor = ({
  name: 'anchor',
  add: function add(core) {
    core.addModule([_selectMenu]);
    core.context.anchor = {
      caller: {},
      forms: this.setDialogForm(core),
      host: (core._w.location.origin + core._w.location.pathname).replace(/\/$/, ''),
      callerContext: null
    };
  },
  /** dialog */
  setDialogForm: function setDialogForm(core) {
    var lang = core.lang;
    var relList = core.options.linkRel;
    var defaultRel = (core.options.linkRelDefault.default || '').split(' ');
    var icons = core.icons;
    var forms = core.util.createElement('DIV');
    var html = '<div class="se-dialog-body">' + '<div class="se-dialog-form">' + '<label>' + lang.dialogBox.linkBox.url + '</label>' + '<div class="se-dialog-form-files">' + '<input class="se-input-form se-input-url" type="text" placeholder="' + (core.options.protocol || '') + '" />' + '<button type="button" class="se-btn se-dialog-files-edge-button _se_bookmark_button" title="' + lang.dialogBox.linkBox.bookmark + '" aria-label="' + lang.dialogBox.linkBox.bookmark + '">' + icons.bookmark + '</button>' + core.plugins.selectMenu.setForm() + '</div>' + '<div class="se-anchor-preview-form">' + '<span class="se-svg se-anchor-preview-icon _se_anchor_bookmark_icon">' + icons.bookmark + '</span>' + '<span class="se-svg se-anchor-preview-icon _se_anchor_download_icon">' + icons.download + '</span>' + '<pre class="se-link-preview"></pre>' + '</div>' + '</div>' + '<div class="se-dialog-form">' + '<label>' + lang.dialogBox.linkBox.text + '</label><input class="se-input-form _se_anchor_text" type="text" />' + '</div>' + '<div class="se-dialog-form-footer">' + '<label><input type="checkbox" class="se-dialog-btn-check _se_anchor_check" />&nbsp;' + lang.dialogBox.linkBox.newWindowCheck + '</label>' + '<label><input type="checkbox" class="se-dialog-btn-check _se_anchor_download" />&nbsp;' + lang.dialogBox.linkBox.downloadLinkCheck + '</label>';
    if (relList.length > 0) {
      html += '<div class="se-anchor-rel"><button type="button" class="se-btn se-btn-select se-anchor-rel-btn">&lt;rel&gt;</button>' + '<div class="se-anchor-rel-wrapper"><pre class="se-link-preview se-anchor-rel-preview"></pre></div>' + '<div class="se-list-layer">' + '<div class="se-list-inner">' + '<ul class="se-list-basic se-list-checked">';
      for (var i = 0, len = relList.length, rel; i < len; i++) {
        rel = relList[i];
        html += '<li><button type="button" class="se-btn-list' + (defaultRel.indexOf(rel) > -1 ? ' se-checked' : '') + '" data-command="' + rel + '" title="' + rel + '" aria-label="' + rel + '"><span class="se-svg">' + icons.checked + '</span>' + rel + '</button></li>';
      }
      html += '</ul></div></div></div>';
    }
    html += '</div></div>';
    forms.innerHTML = html;
    return forms;
  },
  initEvent: function initEvent(pluginName, forms) {
    var anchorPlugin = this.plugins.anchor;
    var context = this.context.anchor.caller[pluginName] = {
      modal: forms,
      urlInput: null,
      linkDefaultRel: this.options.linkRelDefault,
      defaultRel: this.options.linkRelDefault.default || '',
      currentRel: [],
      linkAnchor: null,
      linkValue: '',
      _change: false,
      callerName: pluginName
    };
    if (typeof context.linkDefaultRel.default === 'string') context.linkDefaultRel.default = context.linkDefaultRel.default.trim();
    if (typeof context.linkDefaultRel.check_new_window === 'string') context.linkDefaultRel.check_new_window = context.linkDefaultRel.check_new_window.trim();
    if (typeof context.linkDefaultRel.check_bookmark === 'string') context.linkDefaultRel.check_bookmark = context.linkDefaultRel.check_bookmark.trim();
    context.urlInput = forms.querySelector('.se-input-url');
    context.anchorText = forms.querySelector('._se_anchor_text');
    context.newWindowCheck = forms.querySelector('._se_anchor_check');
    context.downloadCheck = forms.querySelector('._se_anchor_download');
    context.download = forms.querySelector('._se_anchor_download_icon');
    context.preview = forms.querySelector('.se-link-preview');
    context.bookmark = forms.querySelector('._se_anchor_bookmark_icon');
    context.bookmarkButton = forms.querySelector('._se_bookmark_button');
    this.plugins.selectMenu.initEvent.call(this, pluginName, forms);
    var listContext = this.context.selectMenu.caller[pluginName];

    /** rel */
    if (this.options.linkRel.length > 0) {
      context.relButton = forms.querySelector('.se-anchor-rel-btn');
      context.relList = forms.querySelector('.se-list-layer');
      context.relPreview = forms.querySelector('.se-anchor-rel-preview');
      context.relButton.addEventListener('click', anchorPlugin.onClick_relButton.bind(this, context));
      context.relList.addEventListener('click', anchorPlugin.onClick_relList.bind(this, context));
    }
    context.newWindowCheck.addEventListener('change', anchorPlugin.onChange_newWindowCheck.bind(this, context));
    context.downloadCheck.addEventListener('change', anchorPlugin.onChange_downloadCheck.bind(this, context));
    context.anchorText.addEventListener('input', anchorPlugin.onChangeAnchorText.bind(this, context));
    context.urlInput.addEventListener('input', anchorPlugin.onChangeUrlInput.bind(this, context));
    context.urlInput.addEventListener('keydown', anchorPlugin.onKeyDownUrlInput.bind(this, listContext));
    context.urlInput.addEventListener('focus', anchorPlugin.onFocusUrlInput.bind(this, context, listContext));
    context.urlInput.addEventListener('blur', anchorPlugin.onBlurUrlInput.bind(this, listContext));
    context.bookmarkButton.addEventListener('click', anchorPlugin.onClick_bookmarkButton.bind(this, context));
  },
  on: function on(contextAnchor, update) {
    var anchorPlugin = this.plugins.anchor;
    if (!update) {
      anchorPlugin.init.call(this, contextAnchor);
      contextAnchor.anchorText.value = this.getSelection().toString().trim();
      contextAnchor.newWindowCheck.checked = this.options.linkTargetNewWindow;
    } else if (contextAnchor.linkAnchor) {
      this.context.dialog.updateModal = true;
      var href = contextAnchor.linkAnchor.getAttribute('href');
      contextAnchor.linkValue = contextAnchor.preview.textContent = contextAnchor.urlInput.value = anchorPlugin.selfPathBookmark.call(this, href) ? href.substr(href.lastIndexOf('#')) : href;
      contextAnchor.anchorText.value = contextAnchor.linkAnchor.textContent || contextAnchor.linkAnchor.getAttribute('alt');
      contextAnchor.newWindowCheck.checked = /_blank/i.test(contextAnchor.linkAnchor.target) ? true : false;
      contextAnchor.downloadCheck.checked = contextAnchor.linkAnchor.download;
    }
    this.context.anchor.callerContext = contextAnchor;
    anchorPlugin.setRel.call(this, contextAnchor, update && contextAnchor.linkAnchor ? contextAnchor.linkAnchor.rel : contextAnchor.defaultRel);
    anchorPlugin.setLinkPreview.call(this, contextAnchor, contextAnchor.linkValue);
    this.plugins.selectMenu.on.call(this, contextAnchor.callerName, this.plugins.anchor.setHeaderBookmark);
  },
  selfPathBookmark: function selfPathBookmark(path) {
    var href = this._w.location.href.replace(/\/$/, '');
    return path.indexOf('#') === 0 || path.indexOf(href) === 0 && path.indexOf('#') === (href.indexOf("#") === -1 ? href.length : href.substr(0, href.indexOf("#")).length);
  },
  _closeRelMenu: null,
  toggleRelList: function toggleRelList(contextAnchor, show) {
    if (!show) {
      if (this.plugins.anchor._closeRelMenu) this.plugins.anchor._closeRelMenu();
    } else {
      var target = contextAnchor.relButton;
      var relList = contextAnchor.relList;
      this.util.addClass(target, 'active');
      relList.style.visibility = 'hidden';
      relList.style.display = 'block';
      if (!this.options.rtl) relList.style.left = target.offsetLeft + target.offsetWidth + 1 + 'px';else relList.style.left = target.offsetLeft - relList.offsetWidth - 1 + 'px';
      relList.style.top = target.offsetTop + target.offsetHeight / 2 - relList.offsetHeight / 2 + 'px';
      relList.style.visibility = '';
      this.plugins.anchor._closeRelMenu = function (context, target, e) {
        if (e && (context.relButton.contains(e.target) || context.relList.contains(e.target))) return;
        this.util.removeClass(target, 'active');
        context.relList.style.display = 'none';
        this.modalForm.removeEventListener('click', this.plugins.anchor._closeRelMenu);
        this.plugins.anchor._closeRelMenu = null;
      }.bind(this, contextAnchor, target);
      this.modalForm.addEventListener('click', this.plugins.anchor._closeRelMenu);
    }
  },
  onClick_relButton: function onClick_relButton(contextAnchor, e) {
    this.plugins.anchor.toggleRelList.call(this, contextAnchor, !this.util.hasClass(e.target, 'active'));
  },
  onClick_relList: function onClick_relList(contextAnchor, e) {
    var target = e.target;
    var cmd = target.getAttribute('data-command');
    if (!cmd) return;
    var current = contextAnchor.currentRel;
    var checked = this.util.toggleClass(target, 'se-checked');
    var index = current.indexOf(cmd);
    if (checked) {
      if (index === -1) current.push(cmd);
    } else {
      if (index > -1) current.splice(index, 1);
    }
    contextAnchor.relPreview.title = contextAnchor.relPreview.textContent = current.join(' ');
  },
  setRel: function setRel(contextAnchor, relAttr) {
    var relListEl = contextAnchor.relList;
    var rels = contextAnchor.currentRel = !relAttr ? [] : relAttr.split(' ');
    if (!relListEl) return;
    var checkedRel = relListEl.querySelectorAll('button');
    for (var i = 0, len = checkedRel.length, cmd; i < len; i++) {
      cmd = checkedRel[i].getAttribute('data-command');
      if (rels.indexOf(cmd) > -1) {
        this.util.addClass(checkedRel[i], 'se-checked');
      } else {
        this.util.removeClass(checkedRel[i], 'se-checked');
      }
    }
    contextAnchor.relPreview.title = contextAnchor.relPreview.textContent = rels.join(' ');
  },
  createHeaderList: function createHeaderList(contextAnchor, contextList, urlValue) {
    var headers = this.util.getListChildren(this.context.element.wysiwyg, function (current) {
      return /h[1-6]/i.test(current.nodeName);
    });
    if (headers.length === 0) return;
    var valueRegExp = new this._w.RegExp('^' + urlValue.replace(/^#/, ''), 'i');
    var list = [];
    var html = '';
    for (var i = 0, len = headers.length, h; i < len; i++) {
      h = headers[i];
      if (!valueRegExp.test(h.textContent)) continue;
      list.push(h);
      html += '<li class="se-select-item" data-index="' + i + '">' + h.textContent + '</li>';
    }
    if (list.length === 0) {
      this.plugins.selectMenu.close.call(this, contextList);
    } else {
      this.plugins.selectMenu.createList(contextList, list, html);
      this.plugins.selectMenu.open.call(this, contextList, this.plugins.anchor._setMenuListPosition.bind(this, contextAnchor));
    }
  },
  _setMenuListPosition: function _setMenuListPosition(contextAnchor, list) {
    list.style.top = contextAnchor.urlInput.offsetHeight + 1 + 'px';
  },
  onKeyDownUrlInput: function onKeyDownUrlInput(contextList, e) {
    var keyCode = e.keyCode;
    switch (keyCode) {
      case 38:
        // up
        e.preventDefault();
        e.stopPropagation();
        this.plugins.selectMenu.moveItem.call(this, contextList, -1);
        break;
      case 40:
        // down
        e.preventDefault();
        e.stopPropagation();
        this.plugins.selectMenu.moveItem.call(this, contextList, 1);
        break;
      case 13:
        // enter
        if (contextList.index > -1) {
          e.preventDefault();
          e.stopPropagation();
          this.plugins.anchor.setHeaderBookmark.call(this, this.plugins.selectMenu.getItem(contextList, null));
        }
        break;
    }
  },
  setHeaderBookmark: function setHeaderBookmark(header) {
    var contextAnchor = this.context.anchor.callerContext;
    var id = header.id || 'h_' + this._w.Math.random().toString().replace(/.+\./, '');
    header.id = id;
    contextAnchor.urlInput.value = '#' + id;
    if (!contextAnchor.anchorText.value.trim() || !contextAnchor._change) {
      contextAnchor.anchorText.value = header.textContent;
    }
    this.plugins.anchor.setLinkPreview.call(this, contextAnchor, contextAnchor.urlInput.value);
    this.plugins.selectMenu.close.call(this, this.context.selectMenu.callerContext);
    this.context.anchor.callerContext.urlInput.focus();
  },
  onChangeAnchorText: function onChangeAnchorText(contextAnchor, e) {
    contextAnchor._change = !!e.target.value.trim();
  },
  onChangeUrlInput: function onChangeUrlInput(contextAnchor, e) {
    var value = e.target.value.trim();
    this.plugins.anchor.setLinkPreview.call(this, contextAnchor, value);
    if (this.plugins.anchor.selfPathBookmark.call(this, value)) this.plugins.anchor.createHeaderList.call(this, contextAnchor, this.context.selectMenu.callerContext, value);else this.plugins.selectMenu.close.call(this, this.context.selectMenu.callerContext);
  },
  onFocusUrlInput: function onFocusUrlInput(contextAnchor, contextLink) {
    var value = contextAnchor.urlInput.value;
    if (this.plugins.anchor.selfPathBookmark.call(this, value)) this.plugins.anchor.createHeaderList.call(this, contextAnchor, contextLink, value);
  },
  onBlurUrlInput: function onBlurUrlInput(contextList) {
    this.plugins.selectMenu.close.call(this, contextList);
  },
  setLinkPreview: function setLinkPreview(context, value) {
    var preview = context.preview;
    var protocol = this.options.linkProtocol;
    var noPrefix = this.options.linkNoPrefix;
    var reservedProtocol = /^(mailto\:|tel\:|sms\:|https*\:\/\/|#)/.test(value);
    var sameProtocol = !protocol ? false : this._w.RegExp('^' + value.substr(0, protocol.length)).test(protocol);
    value = context.linkValue = preview.textContent = !value ? '' : noPrefix ? value : protocol && !reservedProtocol && !sameProtocol ? protocol + value : reservedProtocol ? value : /^www\./.test(value) ? 'http://' + value : this.context.anchor.host + (/^\//.test(value) ? '' : '/') + value;
    if (this.plugins.anchor.selfPathBookmark.call(this, value)) {
      context.bookmark.style.display = 'block';
      this.util.addClass(context.bookmarkButton, 'active');
    } else {
      context.bookmark.style.display = 'none';
      this.util.removeClass(context.bookmarkButton, 'active');
    }
    if (!this.plugins.anchor.selfPathBookmark.call(this, value) && context.downloadCheck.checked) {
      context.download.style.display = 'block';
    } else {
      context.download.style.display = 'none';
    }
  },
  setCtx: function setCtx(anchor, contextAnchor) {
    if (!anchor) return;
    contextAnchor.linkAnchor = anchor;
    contextAnchor.linkValue = anchor.href;
    contextAnchor.currentRel = anchor.rel.split(" ");
  },
  updateAnchor: function updateAnchor(anchor, url, alt, contextAnchor, notText) {
    // download
    if (!this.plugins.anchor.selfPathBookmark.call(this, url) && contextAnchor.downloadCheck.checked) {
      anchor.setAttribute('download', alt || url);
    } else {
      anchor.removeAttribute('download');
    }

    // new window
    if (contextAnchor.newWindowCheck.checked) anchor.target = '_blank';else anchor.removeAttribute('target');

    // rel
    var rel = contextAnchor.currentRel.join(' ');
    if (!rel) anchor.removeAttribute('rel');else anchor.rel = rel;

    // est url, alt
    anchor.href = url;
    anchor.setAttribute('alt', alt);
    if (notText) {
      if (anchor.children.length === 0) anchor.textContent = '';
    } else {
      anchor.textContent = alt;
    }
  },
  createAnchor: function createAnchor(contextAnchor, notText) {
    if (contextAnchor.linkValue.length === 0) return null;
    var url = contextAnchor.linkValue;
    var anchor = contextAnchor.anchorText;
    var anchorText = anchor.value.length === 0 ? url : anchor.value;
    var oA = contextAnchor.linkAnchor || this.util.createElement('A');
    this.plugins.anchor.updateAnchor.call(this, oA, url, anchorText, contextAnchor, notText);
    contextAnchor.linkValue = contextAnchor.preview.textContent = contextAnchor.urlInput.value = contextAnchor.anchorText.value = '';
    return oA;
  },
  onClick_bookmarkButton: function onClick_bookmarkButton(contextAnchor) {
    var url = contextAnchor.urlInput.value;
    if (this.plugins.anchor.selfPathBookmark.call(this, url)) {
      url = url.substr(1);
      contextAnchor.bookmark.style.display = 'none';
      this.util.removeClass(contextAnchor.bookmarkButton, 'active');
      this.plugins.selectMenu.close.call(this, this.context.selectMenu.callerContext);
    } else {
      url = '#' + url;
      contextAnchor.bookmark.style.display = 'block';
      this.util.addClass(contextAnchor.bookmarkButton, 'active');
      contextAnchor.downloadCheck.checked = false;
      contextAnchor.download.style.display = 'none';
      this.plugins.anchor.createHeaderList.call(this, contextAnchor, this.context.selectMenu.callerContext, url);
    }
    contextAnchor.urlInput.value = url;
    this.plugins.anchor.setLinkPreview.call(this, contextAnchor, url);
    contextAnchor.urlInput.focus();
  },
  onChange_newWindowCheck: function onChange_newWindowCheck(contextAnchor, e) {
    if (typeof contextAnchor.linkDefaultRel.check_new_window !== 'string') return;
    if (e.target.checked) {
      this.plugins.anchor.setRel.call(this, contextAnchor, this.plugins.anchor._relMerge.call(this, contextAnchor, contextAnchor.linkDefaultRel.check_new_window));
    } else {
      this.plugins.anchor.setRel.call(this, contextAnchor, this.plugins.anchor._relDelete.call(this, contextAnchor, contextAnchor.linkDefaultRel.check_new_window));
    }
  },
  onChange_downloadCheck: function onChange_downloadCheck(contextAnchor, e) {
    if (e.target.checked) {
      contextAnchor.download.style.display = 'block';
      contextAnchor.bookmark.style.display = 'none';
      this.util.removeClass(contextAnchor.bookmarkButton, 'active');
      contextAnchor.linkValue = contextAnchor.preview.textContent = contextAnchor.urlInput.value = contextAnchor.urlInput.value.replace(/^\#+/, '');
      if (typeof contextAnchor.linkDefaultRel.check_bookmark === 'string') {
        this.plugins.anchor.setRel.call(this, contextAnchor, this.plugins.anchor._relMerge.call(this, contextAnchor, contextAnchor.linkDefaultRel.check_bookmark));
      }
    } else {
      contextAnchor.download.style.display = 'none';
      if (typeof contextAnchor.linkDefaultRel.check_bookmark === 'string') {
        this.plugins.anchor.setRel.call(this, contextAnchor, this.plugins.anchor._relDelete.call(this, contextAnchor, contextAnchor.linkDefaultRel.check_bookmark));
      }
    }
  },
  _relMerge: function _relMerge(contextAnchor, relAttr) {
    var current = contextAnchor.currentRel;
    if (!relAttr) return current.join(' ');
    if (/^only\:/.test(relAttr)) {
      relAttr = relAttr.replace(/^only\:/, '').trim();
      contextAnchor.currentRel = relAttr.split(' ');
      return relAttr;
    }
    var rels = relAttr.split(' ');
    for (var i = 0, len = rels.length, index; i < len; i++) {
      index = current.indexOf(rels[i]);
      if (index === -1) current.push(rels[i]);
    }
    return current.join(' ');
  },
  _relDelete: function _relDelete(contextAnchor, relAttr) {
    if (!relAttr) return contextAnchor.currentRel.join(' ');
    if (/^only\:/.test(relAttr)) relAttr = relAttr.replace(/^only\:/, '').trim();
    var rels = contextAnchor.currentRel.join(' ').replace(this._w.RegExp(relAttr + '\\s*'), '');
    contextAnchor.currentRel = rels.split(' ');
    return rels;
  },
  init: function init(contextAnchor) {
    contextAnchor.linkAnchor = null;
    contextAnchor.linkValue = contextAnchor.preview.textContent = contextAnchor.urlInput.value = '';
    contextAnchor.anchorText.value = '';
    contextAnchor.newWindowCheck.checked = false;
    contextAnchor.downloadCheck.checked = false;
    contextAnchor._change = false;
    this.plugins.anchor.setRel.call(this, contextAnchor, contextAnchor.defaultRel);
    if (contextAnchor.relList) {
      this.plugins.anchor.toggleRelList.call(this, contextAnchor, false);
    }
    this.context.anchor.callerContext = null;
    this.plugins.selectMenu.init.call(this, this.context.selectMenu.callerContext);
  }
});
// CONCATENATED MODULE: ./node_modules/suneditor/src/plugins/dialog/link.js
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2017 JiHong Lee.
 * MIT license.
 */




/* harmony default export */ var dialog_link = ({
  name: 'link',
  display: 'dialog',
  add: function add(core) {
    core.addModule([dialog_default.a, _anchor]);
    var context = core.context;
    var contextLink = context.link = {
      focusElement: null,
      // @Override dialog // This element has focus when the dialog is opened.
      _linkAnchor: null,
      anchorCtx: null
    };

    /** link dialog */
    var link_dialog = this.setDialog(core);
    contextLink.modal = link_dialog;

    /** link controller */
    var link_controller = this.setController_LinkButton(core);
    contextLink.linkController = link_controller;
    link_dialog.querySelector('form').addEventListener('submit', this.submit.bind(core));
    link_controller.addEventListener('click', this.onClick_linkController.bind(core));

    /** append html */
    context.dialog.modal.appendChild(link_dialog);

    /** append controller */
    context.element.relative.appendChild(link_controller);

    /** link event */
    core.plugins.anchor.initEvent.call(core, 'link', link_dialog);
    contextLink.focusElement = context.anchor.caller.link.urlInput;

    /** empty memory */
    link_dialog = null, link_controller = null;
  },
  /** dialog */
  setDialog: function setDialog(core) {
    var lang = core.lang;
    var dialog = core.util.createElement('DIV');
    var icons = core.icons;
    dialog.className = 'se-dialog-content';
    dialog.style.display = 'none';
    var html = '' + '<form>' + '<div class="se-dialog-header">' + '<button type="button" data-command="close" class="se-btn se-dialog-close" title="' + lang.dialogBox.close + '" aria-label="' + lang.dialogBox.close + '">' + icons.cancel + '</button>' + '<span class="se-modal-title">' + lang.dialogBox.linkBox.title + '</span>' + '</div>' + core.context.anchor.forms.innerHTML + '<div class="se-dialog-footer">' + '<button type="submit" class="se-btn-primary" title="' + lang.dialogBox.submitButton + '" aria-label="' + lang.dialogBox.submitButton + '"><span>' + lang.dialogBox.submitButton + '</span></button>' + '</div>' + '</form>';
    dialog.innerHTML = html;
    return dialog;
  },
  /** modify controller button */
  setController_LinkButton: function setController_LinkButton(core) {
    var lang = core.lang;
    var icons = core.icons;
    var link_btn = core.util.createElement('DIV');
    link_btn.className = 'se-controller se-controller-link';
    link_btn.innerHTML = '' + '<div class="se-arrow se-arrow-up"></div>' + '<div class="link-content"><span><a target="_blank" href=""></a>&nbsp;</span>' + '<div class="se-btn-group">' + '<button type="button" data-command="update" tabindex="-1" class="se-btn se-tooltip">' + icons.edit + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.edit + '</span></span>' + '</button>' + '<button type="button" data-command="unlink" tabindex="-1" class="se-btn se-tooltip">' + icons.unlink + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.unlink + '</span></span>' + '</button>' + '<button type="button" data-command="delete" tabindex="-1" class="se-btn se-tooltip">' + icons.delete + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.remove + '</span></span>' + '</button>' + '</div>' + '</div>';
    return link_btn;
  },
  /**
   * @Override dialog
   */
  open: function open() {
    this.plugins.dialog.open.call(this, 'link', 'link' === this.currentControllerName);
  },
  submit: function submit(e) {
    this.showLoading();
    e.preventDefault();
    e.stopPropagation();
    try {
      var oA = this.plugins.anchor.createAnchor.call(this, this.context.anchor.caller.link, false);
      if (oA === null) return;
      if (!this.context.dialog.updateModal) {
        var selectedFormats = this.getSelectedElements();
        if (selectedFormats.length > 1) {
          var oFormat = this.util.createElement(selectedFormats[0].nodeName);
          oFormat.appendChild(oA);
          if (!this.insertNode(oFormat, null, true)) return;
        } else {
          if (!this.insertNode(oA, null, true)) return;
        }
        this.setRange(oA.childNodes[0], 0, oA.childNodes[0], oA.textContent.length);
      } else {
        // set range
        var textNode = this.context.link._linkAnchor.childNodes[0];
        this.setRange(textNode, 0, textNode, textNode.textContent.length);
      }
    } finally {
      this.plugins.dialog.close.call(this);
      this.closeLoading();
      // history stack
      this.history.push(false);
    }
    return false;
  },
  /**
   * @Override core
   */
  active: function active(element) {
    if (!element) {
      if (this.controllerArray.indexOf(this.context.link.linkController) > -1) {
        this.controllersOff();
      }
    } else if (this.util.isAnchor(element) && element.getAttribute('data-image-link') === null) {
      if (this.controllerArray.indexOf(this.context.link.linkController) < 0) {
        this.plugins.link.call_controller.call(this, element);
      }
      return true;
    }
    return false;
  },
  /**
   * @Override dialog
   */
  on: function on(update) {
    this.plugins.anchor.on.call(this, this.context.anchor.caller.link, update);
  },
  call_controller: function call_controller(selectionATag) {
    this.editLink = this.context.link._linkAnchor = this.context.anchor.caller.link.linkAnchor = selectionATag;
    var linkBtn = this.context.link.linkController;
    var link = linkBtn.querySelector('a');
    link.href = selectionATag.href;
    link.title = selectionATag.textContent;
    link.textContent = selectionATag.textContent;
    this.util.addClass(selectionATag, 'on');
    this.setControllerPosition(linkBtn, selectionATag, 'bottom', {
      left: 0,
      top: 0
    });
    this.controllersOn(linkBtn, selectionATag, 'link', this.util.removeClass.bind(this.util, this.context.link._linkAnchor, 'on'));
  },
  onClick_linkController: function onClick_linkController(e) {
    e.stopPropagation();
    var command = e.target.getAttribute('data-command') || e.target.parentNode.getAttribute('data-command');
    if (!command) return;
    e.preventDefault();
    if (/update/.test(command)) {
      this.plugins.dialog.open.call(this, 'link', true);
    } else if (/unlink/.test(command)) {
      var sc = this.util.getChildElement(this.context.link._linkAnchor, function (current) {
        return current.childNodes.length === 0 || current.nodeType === 3;
      }, false);
      var ec = this.util.getChildElement(this.context.link._linkAnchor, function (current) {
        return current.childNodes.length === 0 || current.nodeType === 3;
      }, true);
      this.setRange(sc, 0, ec, ec.textContent.length);
      this.nodeChange(null, null, ['A'], false);
    } else {
      /** delete */
      this.util.removeItem(this.context.link._linkAnchor);
      this.context.anchor.caller.link.linkAnchor = null;
      this.focus();

      // history stack
      this.history.push(false);
    }
    this.controllersOff();
  },
  /**
   * @Override dialog
   */
  init: function init() {
    this.context.link.linkController.style.display = 'none';
    this.plugins.anchor.init.call(this, this.context.anchor.caller.link);
  }
});
// EXTERNAL MODULE: ./node_modules/suneditor/src/plugins/modules/component.js
var component = __webpack_require__(1027);
var component_default = /*#__PURE__*/__webpack_require__.n(component);

// EXTERNAL MODULE: ./node_modules/suneditor/src/plugins/modules/resizing.js
var resizing = __webpack_require__(1443);
var resizing_default = /*#__PURE__*/__webpack_require__.n(resizing);

// EXTERNAL MODULE: ./node_modules/suneditor/src/plugins/modules/fileManager.js
var fileManager = __webpack_require__(1028);
var fileManager_default = /*#__PURE__*/__webpack_require__.n(fileManager);

// CONCATENATED MODULE: ./node_modules/suneditor/src/plugins/dialog/image.js
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2017 JiHong Lee.
 * MIT license.
 */







/* harmony default export */ var dialog_image = ({
  name: 'image',
  display: 'dialog',
  add: function add(core) {
    core.addModule([dialog_default.a, _anchor, component_default.a, resizing_default.a, fileManager_default.a]);
    var options = core.options;
    var context = core.context;
    var contextImage = context.image = {
      _infoList: [],
      // @Override fileManager
      _infoIndex: 0,
      // @Override fileManager
      _uploadFileLength: 0,
      // @Override fileManager
      focusElement: null,
      // @Override dialog // This element has focus when the dialog is opened.
      sizeUnit: options._imageSizeUnit,
      _linkElement: '',
      _altText: '',
      _align: 'none',
      _floatClassRegExp: '__se__float\\-[a-z]+',
      _v_src: {
        _linkValue: ''
      },
      svgDefaultSize: '30%',
      base64RenderIndex: 0,
      // @require @Override component
      _element: null,
      _cover: null,
      _container: null,
      // @Override resizing properties
      inputX: null,
      inputY: null,
      _element_w: 1,
      _element_h: 1,
      _element_l: 0,
      _element_t: 0,
      _defaultSizeX: 'auto',
      _defaultSizeY: 'auto',
      _origin_w: options.imageWidth === 'auto' ? '' : options.imageWidth,
      _origin_h: options.imageHeight === 'auto' ? '' : options.imageHeight,
      _proportionChecked: true,
      _resizing: options.imageResizing,
      _resizeDotHide: !options.imageHeightShow,
      _rotation: options.imageRotation,
      _alignHide: !options.imageAlignShow,
      _onlyPercentage: options.imageSizeOnlyPercentage,
      _ratio: false,
      _ratioX: 1,
      _ratioY: 1,
      _captionShow: true,
      _captionChecked: false,
      _caption: null,
      captionCheckEl: null
    };

    /** image dialog */
    var image_dialog = this.setDialog(core);
    contextImage.modal = image_dialog;
    contextImage.imgInputFile = image_dialog.querySelector('._se_image_file');
    contextImage.imgUrlFile = image_dialog.querySelector('._se_image_url');
    contextImage.focusElement = contextImage.imgInputFile || contextImage.imgUrlFile;
    contextImage.altText = image_dialog.querySelector('._se_image_alt');
    contextImage.captionCheckEl = image_dialog.querySelector('._se_image_check_caption');
    contextImage.previewSrc = image_dialog.querySelector('._se_tab_content_image .se-link-preview');

    /** add event listeners */
    image_dialog.querySelector('.se-dialog-tabs').addEventListener('click', this.openTab.bind(core));
    image_dialog.querySelector('form').addEventListener('submit', this.submit.bind(core));
    if (contextImage.imgInputFile) image_dialog.querySelector('.se-file-remove').addEventListener('click', this._removeSelectedFiles.bind(contextImage.imgInputFile, contextImage.imgUrlFile, contextImage.previewSrc));
    if (contextImage.imgUrlFile) contextImage.imgUrlFile.addEventListener('input', this._onLinkPreview.bind(contextImage.previewSrc, contextImage._v_src, options.linkProtocol));
    if (contextImage.imgInputFile && contextImage.imgUrlFile) contextImage.imgInputFile.addEventListener('change', this._fileInputChange.bind(contextImage));
    var imageGalleryButton = image_dialog.querySelector('.__se__gallery');
    if (imageGalleryButton) imageGalleryButton.addEventListener('click', this._openGallery.bind(core));
    contextImage.proportion = {};
    contextImage.inputX = {};
    contextImage.inputY = {};
    if (options.imageResizing) {
      contextImage.proportion = image_dialog.querySelector('._se_image_check_proportion');
      contextImage.inputX = image_dialog.querySelector('._se_image_size_x');
      contextImage.inputY = image_dialog.querySelector('._se_image_size_y');
      contextImage.inputX.value = options.imageWidth;
      contextImage.inputY.value = options.imageHeight;
      contextImage.inputX.addEventListener('keyup', this.setInputSize.bind(core, 'x'));
      contextImage.inputY.addEventListener('keyup', this.setInputSize.bind(core, 'y'));
      contextImage.inputX.addEventListener('change', this.setRatio.bind(core));
      contextImage.inputY.addEventListener('change', this.setRatio.bind(core));
      contextImage.proportion.addEventListener('change', this.setRatio.bind(core));
      image_dialog.querySelector('.se-dialog-btn-revert').addEventListener('click', this.sizeRevert.bind(core));
    }

    /** append html */
    context.dialog.modal.appendChild(image_dialog);

    /** link event */
    core.plugins.anchor.initEvent.call(core, 'image', image_dialog.querySelector('._se_tab_content_url'));
    contextImage.anchorCtx = core.context.anchor.caller.image;

    /** empty memory */
    image_dialog = null;
  },
  /** dialog */
  setDialog: function setDialog(core) {
    var option = core.options;
    var lang = core.lang;
    var dialog = core.util.createElement('DIV');
    dialog.className = 'se-dialog-content se-dialog-image';
    dialog.style.display = 'none';
    var html = '' + '<div class="se-dialog-header">' + '<button type="button" data-command="close" class="se-btn se-dialog-close" class="close" title="' + lang.dialogBox.close + '" aria-label="' + lang.dialogBox.close + '">' + core.icons.cancel + '</button>' + '<span class="se-modal-title">' + lang.dialogBox.imageBox.title + '</span>' + '</div>' + '<div class="se-dialog-tabs">' + '<button type="button" class="_se_tab_link active" data-tab-link="image">' + lang.toolbar.image + '</button>' + '<button type="button" class="_se_tab_link" data-tab-link="url">' + lang.toolbar.link + '</button>' + '</div>' + '<form method="post" enctype="multipart/form-data">' + '<div class="_se_tab_content _se_tab_content_image">' + '<div class="se-dialog-body"><div style="border-bottom: 1px dashed #ccc;">';
    if (option.imageFileInput) {
      html += '' + '<div class="se-dialog-form">' + '<label>' + lang.dialogBox.imageBox.file + '</label>' + '<div class="se-dialog-form-files">' + '<input class="se-input-form _se_image_file" type="file" accept="' + option.imageAccept + '"' + (option.imageMultipleFile ? ' multiple="multiple"' : '') + '/>' + '<button type="button" class="se-btn se-dialog-files-edge-button se-file-remove" title="' + lang.controller.remove + '" aria-label="' + lang.controller.remove + '">' + core.icons.cancel + '</button>' + '</div>' + '</div>';
    }
    if (option.imageUrlInput) {
      html += '' + '<div class="se-dialog-form">' + '<label>' + lang.dialogBox.imageBox.url + '</label>' + '<div class="se-dialog-form-files">' + '<input class="se-input-form se-input-url _se_image_url" type="text" />' + (option.imageGalleryUrl && core.plugins.imageGallery ? '<button type="button" class="se-btn se-dialog-files-edge-button __se__gallery" title="' + lang.toolbar.imageGallery + '" aria-label="' + lang.toolbar.imageGallery + '">' + core.icons.image_gallery + '</button>' : '') + '</div>' + '<pre class="se-link-preview"></pre>' + '</div>';
    }
    html += '</div>' + '<div class="se-dialog-form">' + '<label>' + lang.dialogBox.imageBox.altText + '</label><input class="se-input-form _se_image_alt" type="text" />' + '</div>';
    if (option.imageResizing) {
      var onlyPercentage = option.imageSizeOnlyPercentage;
      var onlyPercentDisplay = onlyPercentage ? ' style="display: none !important;"' : '';
      var heightDisplay = !option.imageHeightShow ? ' style="display: none !important;"' : '';
      html += '<div class="se-dialog-form">';
      if (onlyPercentage || !option.imageHeightShow) {
        html += '' + '<div class="se-dialog-size-text">' + '<label class="size-w">' + lang.dialogBox.size + '</label>' + '</div>';
      } else {
        html += '' + '<div class="se-dialog-size-text">' + '<label class="size-w">' + lang.dialogBox.width + '</label>' + '<label class="se-dialog-size-x">&nbsp;</label>' + '<label class="size-h">' + lang.dialogBox.height + '</label>' + '</div>';
      }
      html += '' + '<input class="se-input-control _se_image_size_x" placeholder="auto"' + (onlyPercentage ? ' type="number" min="1"' : 'type="text"') + (onlyPercentage ? ' max="100"' : '') + ' />' + '<label class="se-dialog-size-x"' + heightDisplay + '>' + (onlyPercentage ? '%' : 'x') + '</label>' + '<input type="text" class="se-input-control _se_image_size_y" placeholder="auto"' + onlyPercentDisplay + (onlyPercentage ? ' max="100"' : '') + heightDisplay + '/>' + '<label' + onlyPercentDisplay + heightDisplay + '><input type="checkbox" class="se-dialog-btn-check _se_image_check_proportion" checked/>&nbsp;' + lang.dialogBox.proportion + '</label>' + '<button type="button" title="' + lang.dialogBox.revertButton + '" aria-label="' + lang.dialogBox.revertButton + '" class="se-btn se-dialog-btn-revert" style="float: right;">' + core.icons.revert + '</button>' + '</div>';
    }
    html += '' + '<div class="se-dialog-form se-dialog-form-footer">' + '<label><input type="checkbox" class="se-dialog-btn-check _se_image_check_caption" />&nbsp;' + lang.dialogBox.caption + '</label>' + '</div>' + '</div>' + '</div>' + '<div class="_se_tab_content _se_tab_content_url" style="display: none">' + core.context.anchor.forms.innerHTML + '</div>' + '<div class="se-dialog-footer">' + '<div' + (option.imageAlignShow ? '' : ' style="display: none"') + '>' + '<label><input type="radio" name="suneditor_image_radio" class="se-dialog-btn-radio" value="none" checked>' + lang.dialogBox.basic + '</label>' + '<label><input type="radio" name="suneditor_image_radio" class="se-dialog-btn-radio" value="left">' + lang.dialogBox.left + '</label>' + '<label><input type="radio" name="suneditor_image_radio" class="se-dialog-btn-radio" value="center">' + lang.dialogBox.center + '</label>' + '<label><input type="radio" name="suneditor_image_radio" class="se-dialog-btn-radio" value="right">' + lang.dialogBox.right + '</label>' + '</div>' + '<button type="submit" class="se-btn-primary" title="' + lang.dialogBox.submitButton + '" aria-label="' + lang.dialogBox.submitButton + '"><span>' + lang.dialogBox.submitButton + '</span></button>' + '</div>' + '</form>';
    dialog.innerHTML = html;
    return dialog;
  },
  _fileInputChange: function _fileInputChange() {
    if (!this.imgInputFile.value) {
      this.imgUrlFile.removeAttribute('disabled');
      this.previewSrc.style.textDecoration = '';
    } else {
      this.imgUrlFile.setAttribute('disabled', true);
      this.previewSrc.style.textDecoration = 'line-through';
    }
  },
  _removeSelectedFiles: function _removeSelectedFiles(urlInput, previewSrc) {
    this.value = '';
    if (urlInput) {
      urlInput.removeAttribute('disabled');
      previewSrc.style.textDecoration = '';
    }
  },
  _openGallery: function _openGallery() {
    this.callPlugin('imageGallery', this.plugins.imageGallery.open.bind(this, this.plugins.image._setUrlInput.bind(this.context.image)), null);
  },
  _setUrlInput: function _setUrlInput(target) {
    this.altText.value = target.alt;
    this._v_src._linkValue = this.previewSrc.textContent = this.imgUrlFile.value = target.src;
    this.imgUrlFile.focus();
  },
  _onLinkPreview: function _onLinkPreview(context, protocol, e) {
    var value = e.target.value.trim();
    context._linkValue = this.textContent = !value ? '' : protocol && value.indexOf('://') === -1 && value.indexOf('#') !== 0 ? protocol + value : value.indexOf('://') === -1 ? '/' + value : value;
  },
  /**
   * @Override @Required fileManager
   */
  fileTags: ['img'],
  /**
   * @Override core, fileManager, resizing
   * @description It is called from core.selectComponent.
   * @param {Element} element Target element
   */
  select: function select(element) {
    this.plugins.image.onModifyMode.call(this, element, this.plugins.resizing.call_controller_resize.call(this, element, 'image'));
  },
  /**
   * @Override fileManager, resizing
   */
  destroy: function destroy(element) {
    var imageEl = element || this.context.image._element;
    var imageContainer = this.util.getParentElement(imageEl, this.util.isMediaComponent) || imageEl;
    var dataIndex = imageEl.getAttribute('data-index') * 1;
    var focusEl = imageContainer.previousElementSibling || imageContainer.nextElementSibling;
    var emptyDiv = imageContainer.parentNode;
    this.util.removeItem(imageContainer);
    this.plugins.image.init.call(this);
    this.controllersOff();
    if (emptyDiv !== this.context.element.wysiwyg) this.util.removeItemAllParents(emptyDiv, function (current) {
      return current.childNodes.length === 0;
    }, null);

    // focus
    this.focusEdge(focusEl);

    // event
    this.plugins.fileManager.deleteInfo.call(this, 'image', dataIndex, this.functions.onImageUpload);

    // history stack
    this.history.push(false);
  },
  /**
   * @Required @Override dialog
   */
  on: function on(update) {
    var contextImage = this.context.image;
    if (!update) {
      contextImage.inputX.value = contextImage._origin_w = this.options.imageWidth === contextImage._defaultSizeX ? '' : this.options.imageWidth;
      contextImage.inputY.value = contextImage._origin_h = this.options.imageHeight === contextImage._defaultSizeY ? '' : this.options.imageHeight;
      if (contextImage.imgInputFile && this.options.imageMultipleFile) contextImage.imgInputFile.setAttribute('multiple', 'multiple');
    } else {
      if (contextImage.imgInputFile && this.options.imageMultipleFile) contextImage.imgInputFile.removeAttribute('multiple');
    }
    this.plugins.anchor.on.call(this, contextImage.anchorCtx, update);
  },
  /**
   * @Required @Override dialog
   */
  open: function open() {
    this.plugins.dialog.open.call(this, 'image', 'image' === this.currentControllerName);
  },
  openTab: function openTab(e) {
    var modal = this.context.image.modal;
    var targetElement = e === 'init' ? modal.querySelector('._se_tab_link') : e.target;
    if (!/^BUTTON$/i.test(targetElement.tagName)) {
      return false;
    }

    // Declare all variables
    var tabName = targetElement.getAttribute('data-tab-link');
    var contentClassName = '_se_tab_content';
    var i, tabContent, tabLinks;

    // Get all elements with class="tabcontent" and hide them
    tabContent = modal.getElementsByClassName(contentClassName);
    for (i = 0; i < tabContent.length; i++) {
      tabContent[i].style.display = 'none';
    }

    // Get all elements with class="tablinks" and remove the class "active"
    tabLinks = modal.getElementsByClassName('_se_tab_link');
    for (i = 0; i < tabLinks.length; i++) {
      this.util.removeClass(tabLinks[i], 'active');
    }

    // Show the current tab, and add an "active" class to the button that opened the tab
    modal.querySelector('.' + contentClassName + '_' + tabName).style.display = 'block';
    this.util.addClass(targetElement, 'active');

    // focus
    if (tabName === 'image' && this.context.image.focusElement) {
      this.context.image.focusElement.focus();
    } else if (tabName === 'url') {
      this.context.anchor.caller.image.urlInput.focus();
    }
    return false;
  },
  submit: function submit(e) {
    var contextImage = this.context.image;
    var imagePlugin = this.plugins.image;
    e.preventDefault();
    e.stopPropagation();
    contextImage._altText = contextImage.altText.value;
    contextImage._align = contextImage.modal.querySelector('input[name="suneditor_image_radio"]:checked').value;
    contextImage._captionChecked = contextImage.captionCheckEl.checked;
    if (contextImage._resizing) contextImage._proportionChecked = contextImage.proportion.checked;
    try {
      if (this.context.dialog.updateModal) {
        imagePlugin.update_image.call(this, false, true, false);
      }
      if (contextImage.imgInputFile && contextImage.imgInputFile.files.length > 0) {
        this.showLoading();
        imagePlugin.submitAction.call(this, this.context.image.imgInputFile.files);
      } else if (contextImage.imgUrlFile && contextImage._v_src._linkValue.length > 0) {
        this.showLoading();
        imagePlugin.onRender_imgUrl.call(this, contextImage._v_src._linkValue);
      }
    } catch (error) {
      this.closeLoading();
      throw Error('[SUNEDITOR.image.submit.fail] cause : "' + error.message + '"');
    } finally {
      this.plugins.dialog.close.call(this);
    }
    return false;
  },
  submitAction: function submitAction(fileList) {
    if (fileList.length === 0) return;
    var fileSize = 0;
    var files = [];
    for (var i = 0, len = fileList.length; i < len; i++) {
      if (/image/i.test(fileList[i].type)) {
        files.push(fileList[i]);
        fileSize += fileList[i].size;
      }
    }
    var limitSize = this.options.imageUploadSizeLimit;
    if (limitSize > 0) {
      var infoSize = 0;
      var imagesInfo = this.context.image._infoList;
      for (var _i = 0, _len = imagesInfo.length; _i < _len; _i++) {
        infoSize += imagesInfo[_i].size * 1;
      }
      if (fileSize + infoSize > limitSize) {
        this.closeLoading();
        var err = '[SUNEDITOR.imageUpload.fail] Size of uploadable total images: ' + limitSize / 1000 + 'KB';
        if (typeof this.functions.onImageUploadError !== 'function' || this.functions.onImageUploadError(err, {
          'limitSize': limitSize,
          'currentSize': infoSize,
          'uploadSize': fileSize
        }, this)) {
          this.functions.noticeOpen(err);
        }
        return;
      }
    }
    var contextImage = this.context.image;
    contextImage._uploadFileLength = files.length;
    var anchor = this.plugins.anchor.createAnchor.call(this, contextImage.anchorCtx, true);
    var info = {
      anchor: anchor,
      inputWidth: contextImage.inputX.value,
      inputHeight: contextImage.inputY.value,
      align: contextImage._align,
      isUpdate: this.context.dialog.updateModal,
      alt: contextImage._altText,
      element: contextImage._element
    };
    if (typeof this.functions.onImageUploadBefore === 'function') {
      var result = this.functions.onImageUploadBefore(files, info, this, function (data) {
        if (data && this._w.Array.isArray(data.result)) {
          this.plugins.image.register.call(this, info, data);
        } else {
          this.plugins.image.upload.call(this, info, data);
        }
      }.bind(this));
      if (typeof result === 'undefined') return;
      if (!result) {
        this.closeLoading();
        return;
      }
      if (this._w.Array.isArray(result) && result.length > 0) files = result;
    }
    this.plugins.image.upload.call(this, info, files);
  },
  error: function error(message, response) {
    this.closeLoading();
    if (typeof this.functions.onImageUploadError !== 'function' || this.functions.onImageUploadError(message, response, this)) {
      this.functions.noticeOpen(message);
      throw Error('[SUNEDITOR.plugin.image.error] response: ' + message);
    }
  },
  upload: function upload(info, files) {
    if (!files) {
      this.closeLoading();
      return;
    }
    if (typeof files === 'string') {
      this.plugins.image.error.call(this, files, null);
      return;
    }
    var imageUploadUrl = this.options.imageUploadUrl;
    var filesLen = this.context.dialog.updateModal ? 1 : files.length;

    // server upload
    if (typeof imageUploadUrl === 'string' && imageUploadUrl.length > 0) {
      var formData = new FormData();
      for (var i = 0; i < filesLen; i++) {
        formData.append('file-' + i, files[i]);
      }
      this.plugins.fileManager.upload.call(this, imageUploadUrl, this.options.imageUploadHeader, formData, this.plugins.image.callBack_imgUpload.bind(this, info), this.functions.onImageUploadError);
    } else {
      // base64
      this.plugins.image.setup_reader.call(this, files, info.anchor, info.inputWidth, info.inputHeight, info.align, info.alt, filesLen, info.isUpdate);
    }
  },
  callBack_imgUpload: function callBack_imgUpload(info, xmlHttp) {
    if (typeof this.functions.imageUploadHandler === 'function') {
      this.functions.imageUploadHandler(xmlHttp, info, this);
    } else {
      var response = JSON.parse(xmlHttp.responseText);
      if (response.errorMessage) {
        this.plugins.image.error.call(this, response.errorMessage, response);
      } else {
        this.plugins.image.register.call(this, info, response);
      }
    }
  },
  register: function register(info, response) {
    var fileList = response.result;
    for (var i = 0, len = fileList.length, file; i < len; i++) {
      file = {
        name: fileList[i].name,
        size: fileList[i].size
      };
      if (info.isUpdate) {
        this.plugins.image.update_src.call(this, fileList[i].url, info.element, file);
        break;
      } else {
        this.plugins.image.create_image.call(this, fileList[i].url, info.anchor, info.inputWidth, info.inputHeight, info.align, file, info.alt);
      }
    }
    this.closeLoading();
  },
  setup_reader: function setup_reader(files, anchor, width, height, align, alt, filesLen, isUpdate) {
    try {
      this.context.image.base64RenderIndex = filesLen;
      var wFileReader = this._w.FileReader;
      var filesStack = [filesLen];
      this.context.image.inputX.value = width;
      this.context.image.inputY.value = height;
      for (var i = 0, reader, file; i < filesLen; i++) {
        reader = new wFileReader();
        file = files[i];
        reader.onload = function (reader, update, updateElement, file, index) {
          filesStack[index] = {
            result: reader.result,
            file: file
          };
          if (--this.context.image.base64RenderIndex === 0) {
            this.plugins.image.onRender_imgBase64.call(this, update, filesStack, updateElement, anchor, width, height, align, alt);
            this.closeLoading();
          }
        }.bind(this, reader, isUpdate, this.context.image._element, file, i);
        reader.readAsDataURL(file);
      }
    } catch (e) {
      this.closeLoading();
      throw Error('[SUNEDITOR.image.setup_reader.fail] cause : "' + e.message + '"');
    }
  },
  onRender_imgBase64: function onRender_imgBase64(update, filesStack, updateElement, anchor, width, height, align, alt) {
    var updateMethod = this.plugins.image.update_src;
    var createMethod = this.plugins.image.create_image;
    for (var i = 0, len = filesStack.length; i < len; i++) {
      if (update) {
        this.context.image._element.setAttribute('data-file-name', filesStack[i].file.name);
        this.context.image._element.setAttribute('data-file-size', filesStack[i].file.size);
        updateMethod.call(this, filesStack[i].result, updateElement, filesStack[i].file);
      } else {
        createMethod.call(this, filesStack[i].result, anchor, width, height, align, filesStack[i].file, alt);
      }
    }
  },
  onRender_imgUrl: function onRender_imgUrl(url) {
    if (!url) url = this.context.image._v_src._linkValue;
    if (!url) return false;
    var contextImage = this.context.image;
    try {
      var file = {
        name: url.split('/').pop(),
        size: 0
      };
      if (this.context.dialog.updateModal) this.plugins.image.update_src.call(this, url, contextImage._element, file);else this.plugins.image.create_image.call(this, url, this.plugins.anchor.createAnchor.call(this, contextImage.anchorCtx, true), contextImage.inputX.value, contextImage.inputY.value, contextImage._align, file, contextImage._altText);
    } catch (e) {
      throw Error('[SUNEDITOR.image.URLRendering.fail] cause : "' + e.message + '"');
    } finally {
      this.closeLoading();
    }
  },
  onRender_link: function onRender_link(imgTag, anchor) {
    if (anchor) {
      anchor.setAttribute('data-image-link', 'image');
      imgTag.setAttribute('data-image-link', anchor.href);
      anchor.appendChild(imgTag);
      return anchor;
    }
    return imgTag;
  },
  /**
   * @Override resizing
   * @param {String} xy 'x': width, 'y': height
   * @param {KeyboardEvent} e Event object
   */
  setInputSize: function setInputSize(xy, e) {
    if (e && e.keyCode === 32) {
      e.preventDefault();
      return;
    }
    this.plugins.resizing._module_setInputSize.call(this, this.context.image, xy);
  },
  /**
   * @Override resizing
   */
  setRatio: function setRatio() {
    this.plugins.resizing._module_setRatio.call(this, this.context.image);
  },
  /**
   * @Override fileManager
   */
  checkFileInfo: function checkFileInfo() {
    var imagePlugin = this.plugins.image;
    var contextImage = this.context.image;
    var modifyHandler = function (tag) {
      imagePlugin.onModifyMode.call(this, tag, null);
      imagePlugin.openModify.call(this, true);
      // get size
      contextImage.inputX.value = contextImage._origin_w;
      contextImage.inputY.value = contextImage._origin_h;
      // get align
      var format = this.util.getFormatElement(tag);
      if (format) contextImage._align = format.style.textAlign || format.style.float;
      // link
      var link = this.util.getParentElement(tag, this.util.isAnchor);
      if (link && !contextImage.anchorCtx.linkValue) contextImage.anchorCtx.linkValue = ' ';
      imagePlugin.update_image.call(this, true, false, true);
      imagePlugin.init.call(this);
    }.bind(this);
    this.plugins.fileManager.checkInfo.call(this, 'image', ['img'], this.functions.onImageUpload, modifyHandler, true);
  },
  /**
   * @Override fileManager
   */
  resetFileInfo: function resetFileInfo() {
    this.plugins.fileManager.resetInfo.call(this, 'image', this.functions.onImageUpload);
  },
  create_image: function create_image(src, anchor, width, height, align, file, alt) {
    var imagePlugin = this.plugins.image;
    var contextImage = this.context.image;
    this.context.resizing._resize_plugin = 'image';
    var oImg = this.util.createElement('IMG');
    oImg.src = src;
    oImg.alt = alt;
    oImg.setAttribute('data-rotate', '0');
    anchor = imagePlugin.onRender_link.call(this, oImg, anchor ? anchor.cloneNode(false) : null);
    if (contextImage._resizing) {
      oImg.setAttribute('data-proportion', contextImage._proportionChecked);
    }
    var cover = this.plugins.component.set_cover.call(this, anchor);
    var container = this.plugins.component.set_container.call(this, cover, 'se-image-container');

    // caption
    if (contextImage._captionChecked) {
      contextImage._caption = this.plugins.component.create_caption.call(this);
      contextImage._caption.setAttribute('contenteditable', false);
      cover.appendChild(contextImage._caption);
    }
    contextImage._element = oImg;
    contextImage._cover = cover;
    contextImage._container = container;

    // set size
    imagePlugin.applySize.call(this, width, height);

    // align
    imagePlugin.setAlign.call(this, align, oImg, cover, container);
    oImg.onload = imagePlugin._image_create_onload.bind(this, oImg, contextImage.svgDefaultSize, container);
    if (this.insertComponent(container, true, true, true)) this.plugins.fileManager.setInfo.call(this, 'image', oImg, this.functions.onImageUpload, file, true);
    this.context.resizing._resize_plugin = '';
  },
  _image_create_onload: function _image_create_onload(oImg, svgDefaultSize, container) {
    // svg exception handling
    if (oImg.offsetWidth === 0) this.plugins.image.applySize.call(this, svgDefaultSize, '');
    if (this.options.mediaAutoSelect) {
      this.selectComponent(oImg, 'image');
    } else {
      var line = this.appendFormatTag(container, null);
      if (line) this.setRange(line, 0, line, 0);
    }
  },
  update_image: function update_image(init, openController, notHistoryPush) {
    var contextImage = this.context.image;
    var imageEl = contextImage._element;
    var cover = contextImage._cover;
    var container = contextImage._container;
    var isNewContainer = false;
    if (cover === null) {
      isNewContainer = true;
      imageEl = contextImage._element.cloneNode(true);
      cover = this.plugins.component.set_cover.call(this, imageEl);
    }
    if (container === null) {
      cover = cover.cloneNode(true);
      imageEl = cover.querySelector('img');
      isNewContainer = true;
      container = this.plugins.component.set_container.call(this, cover, 'se-image-container');
    } else if (isNewContainer) {
      container.innerHTML = '';
      container.appendChild(cover);
      contextImage._cover = cover;
      contextImage._element = imageEl;
      isNewContainer = false;
    }

    // check size
    var changeSize;
    var x = this.util.isNumber(contextImage.inputX.value) ? contextImage.inputX.value + contextImage.sizeUnit : contextImage.inputX.value;
    var y = this.util.isNumber(contextImage.inputY.value) ? contextImage.inputY.value + contextImage.sizeUnit : contextImage.inputY.value;
    if (/%$/.test(imageEl.style.width)) {
      changeSize = x !== container.style.width || y !== container.style.height;
    } else {
      changeSize = x !== imageEl.style.width || y !== imageEl.style.height;
    }

    // alt
    imageEl.alt = contextImage._altText;

    // caption
    var modifiedCaption = false;
    if (contextImage._captionChecked) {
      if (!contextImage._caption) {
        contextImage._caption = this.plugins.component.create_caption.call(this);
        cover.appendChild(contextImage._caption);
        modifiedCaption = true;
      }
    } else {
      if (contextImage._caption) {
        this.util.removeItem(contextImage._caption);
        contextImage._caption = null;
        modifiedCaption = true;
      }
    }

    // link
    var anchor = this.plugins.anchor.createAnchor.call(this, contextImage.anchorCtx, true);
    if (anchor) {
      if (contextImage._linkElement !== anchor) {
        contextImage._linkElement = anchor.cloneNode(false);
        cover.insertBefore(this.plugins.image.onRender_link.call(this, imageEl, contextImage._linkElement), contextImage._caption);
        this.util.removeItem(anchor);
      } else {
        contextImage._linkElement.setAttribute('data-image-link', 'image');
      }
    } else if (contextImage._linkElement !== null) {
      var imageElement = imageEl;
      imageElement.setAttribute('data-image-link', '');
      if (cover.contains(contextImage._linkElement)) {
        var newEl = imageElement.cloneNode(true);
        cover.removeChild(contextImage._linkElement);
        cover.insertBefore(newEl, contextImage._caption);
        contextImage._element = imageEl = newEl;
      }
    }
    if (isNewContainer) {
      var existElement = this.util.isRangeFormatElement(contextImage._element.parentNode) || this.util.isWysiwygDiv(contextImage._element.parentNode) ? contextImage._element : /^A$/i.test(contextImage._element.parentNode.nodeName) ? contextImage._element.parentNode : this.util.getFormatElement(contextImage._element) || contextImage._element;
      if (this.util.isListCell(existElement)) {
        var refer = this.util.getParentElement(contextImage._element, function (current) {
          return current.parentNode === existElement;
        });
        existElement.insertBefore(container, refer);
        this.util.removeItem(contextImage._element);
        this.util.removeEmptyNode(refer, null);
      } else if (this.util.isFormatElement(existElement)) {
        var _refer = this.util.getParentElement(contextImage._element, function (current) {
          return current.parentNode === existElement;
        });
        existElement = this.util.splitElement(existElement, _refer);
        existElement.parentNode.insertBefore(container, existElement);
        this.util.removeItem(contextImage._element);
        this.util.removeEmptyNode(existElement, null);
        if (existElement.children.length === 0) existElement.innerHTML = this.util.htmlRemoveWhiteSpace(existElement.innerHTML);
      } else {
        if (this.util.isFormatElement(existElement.parentNode)) {
          var formats = existElement.parentNode;
          formats.parentNode.insertBefore(container, existElement.previousSibling ? formats.nextElementSibling : formats);
          this.util.removeItem(existElement);
        } else {
          existElement.parentNode.replaceChild(container, existElement);
        }
      }
      imageEl = container.querySelector('img');
      contextImage._element = imageEl;
      contextImage._cover = cover;
      contextImage._container = container;
    }

    // transform
    if (modifiedCaption || !contextImage._onlyPercentage && changeSize) {
      if (!init && (/\d+/.test(imageEl.style.height) || this.context.resizing._rotateVertical && contextImage._captionChecked)) {
        if (/%$/.test(contextImage.inputX.value) || /%$/.test(contextImage.inputY.value)) {
          this.plugins.resizing.resetTransform.call(this, imageEl);
        } else {
          this.plugins.resizing.setTransformSize.call(this, imageEl, this.util.getNumber(contextImage.inputX.value, 0), this.util.getNumber(contextImage.inputY.value, 0));
        }
      }
    }

    // size
    if (contextImage._resizing) {
      imageEl.setAttribute('data-proportion', contextImage._proportionChecked);
      if (changeSize) {
        this.plugins.image.applySize.call(this);
      }
    }

    // align
    this.plugins.image.setAlign.call(this, null, imageEl, null, null);

    // set imagesInfo
    if (init) {
      this.plugins.fileManager.setInfo.call(this, 'image', imageEl, this.functions.onImageUpload, null, true);
    }
    if (openController) {
      this.selectComponent(imageEl, 'image');
    }

    // history stack
    if (!notHistoryPush) this.history.push(false);
  },
  update_src: function update_src(src, element, file) {
    element.src = src;
    this._w.setTimeout(this.plugins.fileManager.setInfo.bind(this, 'image', element, this.functions.onImageUpload, file, true));
    this.selectComponent(element, 'image');
  },
  /**
   * @Required @Override fileManager, resizing
   */
  onModifyMode: function onModifyMode(element, size) {
    if (!element) return;
    var contextImage = this.context.image;
    contextImage._linkElement = contextImage.anchorCtx.linkAnchor = /^A$/i.test(element.parentNode.nodeName) ? element.parentNode : null;
    contextImage._element = element;
    contextImage._cover = this.util.getParentElement(element, 'FIGURE');
    contextImage._container = this.util.getParentElement(element, this.util.isMediaComponent);
    contextImage._caption = this.util.getChildElement(contextImage._cover, 'FIGCAPTION');
    contextImage._align = element.style.float || element.getAttribute('data-align') || 'none';
    element.style.float = '';
    this.plugins.anchor.setCtx(contextImage._linkElement, contextImage.anchorCtx);
    if (size) {
      contextImage._element_w = size.w;
      contextImage._element_h = size.h;
      contextImage._element_t = size.t;
      contextImage._element_l = size.l;
    }
    var userSize = contextImage._element.getAttribute('data-size') || contextImage._element.getAttribute('data-origin');
    var w, h;
    if (userSize) {
      userSize = userSize.split(',');
      w = userSize[0];
      h = userSize[1];
    } else if (size) {
      w = size.w;
      h = size.h;
    }
    contextImage._origin_w = w || element.style.width || element.width || '';
    contextImage._origin_h = h || element.style.height || element.height || '';
  },
  /**
   * @Required @Override fileManager, resizing
   */
  openModify: function openModify(notOpen) {
    var contextImage = this.context.image;
    if (contextImage.imgUrlFile) {
      contextImage._v_src._linkValue = contextImage.previewSrc.textContent = contextImage.imgUrlFile.value = contextImage._element.src;
    }
    contextImage._altText = contextImage.altText.value = contextImage._element.alt;
    (contextImage.modal.querySelector('input[name="suneditor_image_radio"][value="' + contextImage._align + '"]') || contextImage.modal.querySelector('input[name="suneditor_image_radio"][value="none"]')).checked = true;
    contextImage._align = contextImage.modal.querySelector('input[name="suneditor_image_radio"]:checked').value;
    contextImage._captionChecked = contextImage.captionCheckEl.checked = !!contextImage._caption;
    if (contextImage._resizing) {
      this.plugins.resizing._module_setModifyInputSize.call(this, contextImage, this.plugins.image);
    }
    if (!notOpen) this.plugins.dialog.open.call(this, 'image', true);
  },
  /**
   * @Override fileManager
   */
  applySize: function applySize(w, h) {
    var contextImage = this.context.image;
    if (!w) w = contextImage.inputX.value || this.options.imageWidth;
    if (!h) h = contextImage.inputY.value || this.options.imageHeight;
    if (contextImage._onlyPercentage && !!w || /%$/.test(w)) {
      this.plugins.image.setPercentSize.call(this, w, h);
      return true;
    } else if ((!w || w === 'auto') && (!h || h === 'auto')) {
      this.plugins.image.setAutoSize.call(this);
    } else {
      this.plugins.image.setSize.call(this, w, h, false);
    }
    return false;
  },
  /**
   * @Override resizing
   */
  sizeRevert: function sizeRevert() {
    this.plugins.resizing._module_sizeRevert.call(this, this.context.image);
  },
  /**
   * @Override resizing
   */
  setSize: function setSize(w, h, notResetPercentage, direction) {
    var contextImage = this.context.image;
    var onlyW = /^(rw|lw)$/.test(direction) && /\d+/.test(contextImage._element.style.height);
    var onlyH = /^(th|bh)$/.test(direction) && /\d+/.test(contextImage._element.style.width);
    if (!onlyH) {
      contextImage._element.style.width = this.util.isNumber(w) ? w + contextImage.sizeUnit : w;
      this.plugins.image.cancelPercentAttr.call(this);
    }
    if (!onlyW) {
      contextImage._element.style.height = this.util.isNumber(h) ? h + contextImage.sizeUnit : /%$/.test(h) ? '' : h;
    }
    if (contextImage._align === 'center') this.plugins.image.setAlign.call(this, null, null, null, null);
    if (!notResetPercentage) contextImage._element.removeAttribute('data-percentage');

    // save current size
    this.plugins.resizing._module_saveCurrentSize.call(this, contextImage);
  },
  /**
   * @Override resizing
   */
  setAutoSize: function setAutoSize() {
    var contextImage = this.context.image;
    if (contextImage._caption) contextImage._caption.style.marginTop = '';
    this.plugins.resizing.resetTransform.call(this, contextImage._element);
    this.plugins.image.cancelPercentAttr.call(this);
    contextImage._element.style.maxWidth = '';
    contextImage._element.style.width = '';
    contextImage._element.style.height = '';
    contextImage._cover.style.width = '';
    contextImage._cover.style.height = '';
    this.plugins.image.setAlign.call(this, null, null, null, null);
    contextImage._element.setAttribute('data-percentage', 'auto,auto');

    // save current size
    this.plugins.resizing._module_saveCurrentSize.call(this, contextImage);
  },
  /**
   * @Override resizing
   */
  setOriginSize: function setOriginSize() {
    var contextImage = this.context.image;
    contextImage._element.removeAttribute('data-percentage');
    this.plugins.resizing.resetTransform.call(this, contextImage._element);
    this.plugins.image.cancelPercentAttr.call(this);
    var originSize = (contextImage._element.getAttribute('data-origin') || '').split(',');
    var w = originSize[0];
    var h = originSize[1];
    if (originSize) {
      if (contextImage._onlyPercentage || /%$/.test(w) && (/%$/.test(h) || !/\d/.test(h))) {
        this.plugins.image.setPercentSize.call(this, w, h);
      } else {
        this.plugins.image.setSize.call(this, w, h);
      }

      // save current size
      this.plugins.resizing._module_saveCurrentSize.call(this, contextImage);
    }
  },
  /**
   * @Override resizing
   */
  setPercentSize: function setPercentSize(w, h) {
    var contextImage = this.context.image;
    h = !!h && !/%$/.test(h) && !this.util.getNumber(h, 0) ? this.util.isNumber(h) ? h + '%' : h : this.util.isNumber(h) ? h + contextImage.sizeUnit : h || '';
    var heightPercentage = /%$/.test(h);
    contextImage._container.style.width = this.util.isNumber(w) ? w + '%' : w;
    contextImage._container.style.height = '';
    contextImage._cover.style.width = '100%';
    contextImage._cover.style.height = !heightPercentage ? '' : h;
    contextImage._element.style.width = '100%';
    contextImage._element.style.height = heightPercentage ? '' : h;
    contextImage._element.style.maxWidth = '';
    if (contextImage._align === 'center') this.plugins.image.setAlign.call(this, null, null, null, null);
    contextImage._element.setAttribute('data-percentage', w + ',' + h);
    this.plugins.resizing.setCaptionPosition.call(this, contextImage._element);

    // save current size
    this.plugins.resizing._module_saveCurrentSize.call(this, contextImage);
  },
  /**
   * @Override resizing
   */
  cancelPercentAttr: function cancelPercentAttr() {
    var contextImage = this.context.image;
    contextImage._cover.style.width = '';
    contextImage._cover.style.height = '';
    contextImage._container.style.width = '';
    contextImage._container.style.height = '';
    this.util.removeClass(contextImage._container, this.context.image._floatClassRegExp);
    this.util.addClass(contextImage._container, '__se__float-' + contextImage._align);
    if (contextImage._align === 'center') this.plugins.image.setAlign.call(this, null, null, null, null);
  },
  /**
   * @Override resizing
   */
  setAlign: function setAlign(align, element, cover, container) {
    var contextImage = this.context.image;
    if (!align) align = contextImage._align;
    if (!element) element = contextImage._element;
    if (!cover) cover = contextImage._cover;
    if (!container) container = contextImage._container;
    if (align && align !== 'none') {
      cover.style.margin = 'auto';
    } else {
      cover.style.margin = '0';
    }
    if (/%$/.test(element.style.width) && align === 'center') {
      container.style.minWidth = '100%';
      cover.style.width = container.style.width;
    } else {
      container.style.minWidth = '';
      cover.style.width = this.context.resizing._rotateVertical ? element.style.height || element.offsetHeight : !element.style.width || element.style.width === 'auto' ? '' : element.style.width || '100%';
    }
    if (!this.util.hasClass(container, '__se__float-' + align)) {
      this.util.removeClass(container, contextImage._floatClassRegExp);
      this.util.addClass(container, '__se__float-' + align);
    }
    element.setAttribute('data-align', align);
  },
  /**
   * @Override dialog
   */
  init: function init() {
    var contextImage = this.context.image;
    if (contextImage.imgInputFile) contextImage.imgInputFile.value = '';
    if (contextImage.imgUrlFile) contextImage._v_src._linkValue = contextImage.previewSrc.textContent = contextImage.imgUrlFile.value = '';
    if (contextImage.imgInputFile && contextImage.imgUrlFile) {
      contextImage.imgUrlFile.removeAttribute('disabled');
      contextImage.previewSrc.style.textDecoration = '';
    }
    contextImage.altText.value = '';
    contextImage.modal.querySelector('input[name="suneditor_image_radio"][value="none"]').checked = true;
    contextImage.captionCheckEl.checked = false;
    contextImage._element = null;
    this.plugins.image.openTab.call(this, 'init');
    if (contextImage._resizing) {
      contextImage.inputX.value = this.options.imageWidth === contextImage._defaultSizeX ? '' : this.options.imageWidth;
      contextImage.inputY.value = this.options.imageHeight === contextImage._defaultSizeY ? '' : this.options.imageHeight;
      contextImage.proportion.checked = true;
      contextImage._ratio = false;
      contextImage._ratioX = 1;
      contextImage._ratioY = 1;
    }
    this.plugins.anchor.init.call(this, contextImage.anchorCtx);
  }
});
// CONCATENATED MODULE: ./node_modules/suneditor/src/plugins/dialog/video.js
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2017 JiHong Lee.
 * MIT license.
 */






/* harmony default export */ var video = ({
  name: 'video',
  display: 'dialog',
  add: function add(core) {
    core.addModule([dialog_default.a, component_default.a, resizing_default.a, fileManager_default.a]);
    var options = core.options;
    var context = core.context;
    var contextVideo = context.video = {
      _infoList: [],
      // @Override fileManager
      _infoIndex: 0,
      // @Override fileManager
      _uploadFileLength: 0,
      // @Override fileManager
      focusElement: null,
      // @Override dialog // This element has focus when the dialog is opened.
      sizeUnit: options._videoSizeUnit,
      _align: 'none',
      _floatClassRegExp: '__se__float\\-[a-z]+',
      _youtubeQuery: options.youtubeQuery,
      _videoRatio: options.videoRatio * 100 + '%',
      _defaultRatio: options.videoRatio * 100 + '%',
      _linkValue: '',
      // @require @Override component
      _element: null,
      _cover: null,
      _container: null,
      // @Override resizing properties
      inputX: null,
      inputY: null,
      _element_w: 1,
      _element_h: 1,
      _element_l: 0,
      _element_t: 0,
      _defaultSizeX: '100%',
      _defaultSizeY: options.videoRatio * 100 + '%',
      _origin_w: options.videoWidth === '100%' ? '' : options.videoWidth,
      _origin_h: options.videoHeight === '56.25%' ? '' : options.videoHeight,
      _proportionChecked: true,
      _resizing: options.videoResizing,
      _resizeDotHide: !options.videoHeightShow,
      _rotation: options.videoRotation,
      _alignHide: !options.videoAlignShow,
      _onlyPercentage: options.videoSizeOnlyPercentage,
      _ratio: false,
      _ratioX: 1,
      _ratioY: 1,
      _captionShow: false
    };

    /** video dialog */
    var video_dialog = this.setDialog(core);
    contextVideo.modal = video_dialog;
    contextVideo.videoInputFile = video_dialog.querySelector('._se_video_file');
    contextVideo.videoUrlFile = video_dialog.querySelector('.se-input-url');
    contextVideo.focusElement = contextVideo.videoUrlFile || contextVideo.videoInputFile;
    contextVideo.preview = video_dialog.querySelector('.se-link-preview');

    /** add event listeners */
    video_dialog.querySelector('form').addEventListener('submit', this.submit.bind(core));
    if (contextVideo.videoInputFile) video_dialog.querySelector('.se-dialog-files-edge-button').addEventListener('click', this._removeSelectedFiles.bind(contextVideo.videoInputFile, contextVideo.videoUrlFile, contextVideo.preview));
    if (contextVideo.videoInputFile && contextVideo.videoUrlFile) contextVideo.videoInputFile.addEventListener('change', this._fileInputChange.bind(contextVideo));
    if (contextVideo.videoUrlFile) contextVideo.videoUrlFile.addEventListener('input', this._onLinkPreview.bind(contextVideo.preview, contextVideo, options.linkProtocol));
    contextVideo.proportion = {};
    contextVideo.videoRatioOption = {};
    contextVideo.inputX = {};
    contextVideo.inputY = {};
    if (options.videoResizing) {
      contextVideo.proportion = video_dialog.querySelector('._se_video_check_proportion');
      contextVideo.videoRatioOption = video_dialog.querySelector('.se-video-ratio');
      contextVideo.inputX = video_dialog.querySelector('._se_video_size_x');
      contextVideo.inputY = video_dialog.querySelector('._se_video_size_y');
      contextVideo.inputX.value = options.videoWidth;
      contextVideo.inputY.value = options.videoHeight;
      contextVideo.inputX.addEventListener('keyup', this.setInputSize.bind(core, 'x'));
      contextVideo.inputY.addEventListener('keyup', this.setInputSize.bind(core, 'y'));
      contextVideo.inputX.addEventListener('change', this.setRatio.bind(core));
      contextVideo.inputY.addEventListener('change', this.setRatio.bind(core));
      contextVideo.proportion.addEventListener('change', this.setRatio.bind(core));
      contextVideo.videoRatioOption.addEventListener('change', this.setVideoRatio.bind(core));
      video_dialog.querySelector('.se-dialog-btn-revert').addEventListener('click', this.sizeRevert.bind(core));
    }

    /** append html */
    context.dialog.modal.appendChild(video_dialog);

    /** empty memory */
    video_dialog = null;
  },
  /** dialog */
  setDialog: function setDialog(core) {
    var option = core.options;
    var lang = core.lang;
    var dialog = core.util.createElement('DIV');
    dialog.className = 'se-dialog-content';
    dialog.style.display = 'none';
    var html = '' + '<form method="post" enctype="multipart/form-data">' + '<div class="se-dialog-header">' + '<button type="button" data-command="close" class="se-btn se-dialog-close" title="' + lang.dialogBox.close + '" aria-label="' + lang.dialogBox.close + '">' + core.icons.cancel + '</button>' + '<span class="se-modal-title">' + lang.dialogBox.videoBox.title + '</span>' + '</div>' + '<div class="se-dialog-body">';
    if (option.videoFileInput) {
      html += '' + '<div class="se-dialog-form">' + '<label>' + lang.dialogBox.videoBox.file + '</label>' + '<div class="se-dialog-form-files">' + '<input class="se-input-form _se_video_file" type="file" accept="' + option.videoAccept + '"' + (option.videoMultipleFile ? ' multiple="multiple"' : '') + '/>' + '<button type="button" data-command="filesRemove" class="se-btn se-dialog-files-edge-button se-file-remove" title="' + lang.controller.remove + '" aria-label="' + lang.controller.remove + '">' + core.icons.cancel + '</button>' + '</div>' + '</div>';
    }
    if (option.videoUrlInput) {
      html += '' + '<div class="se-dialog-form">' + '<label>' + lang.dialogBox.videoBox.url + '</label>' + '<input class="se-input-form se-input-url" type="text" />' + '<pre class="se-link-preview"></pre>' + '</div>';
    }
    if (option.videoResizing) {
      var ratioList = option.videoRatioList || [{
        name: '16:9',
        value: 0.5625
      }, {
        name: '4:3',
        value: 0.75
      }, {
        name: '21:9',
        value: 0.4285
      }];
      var ratio = option.videoRatio;
      var onlyPercentage = option.videoSizeOnlyPercentage;
      var onlyPercentDisplay = onlyPercentage ? ' style="display: none !important;"' : '';
      var heightDisplay = !option.videoHeightShow ? ' style="display: none !important;"' : '';
      var ratioDisplay = !option.videoRatioShow ? ' style="display: none !important;"' : '';
      var onlyWidthDisplay = !onlyPercentage && !option.videoHeightShow && !option.videoRatioShow ? ' style="display: none !important;"' : '';
      html += '' + '<div class="se-dialog-form">' + '<div class="se-dialog-size-text">' + '<label class="size-w">' + lang.dialogBox.width + '</label>' + '<label class="se-dialog-size-x">&nbsp;</label>' + '<label class="size-h"' + heightDisplay + '>' + lang.dialogBox.height + '</label>' + '<label class="size-h"' + ratioDisplay + '>(' + lang.dialogBox.ratio + ')</label>' + '</div>' + '<input class="se-input-control _se_video_size_x" placeholder="100%"' + (onlyPercentage ? ' type="number" min="1"' : 'type="text"') + (onlyPercentage ? ' max="100"' : '') + '/>' + '<label class="se-dialog-size-x"' + onlyWidthDisplay + '>' + (onlyPercentage ? '%' : 'x') + '</label>' + '<input class="se-input-control _se_video_size_y" placeholder="' + option.videoRatio * 100 + '%"' + (onlyPercentage ? ' type="number" min="1"' : 'type="text"') + (onlyPercentage ? ' max="100"' : '') + heightDisplay + '/>' + '<select class="se-input-select se-video-ratio" title="' + lang.dialogBox.ratio + '" aria-label="' + lang.dialogBox.ratio + '"' + ratioDisplay + '>';
      if (!heightDisplay) html += '<option value=""> - </option>';
      for (var i = 0, len = ratioList.length; i < len; i++) {
        html += '<option value="' + ratioList[i].value + '"' + (ratio.toString() === ratioList[i].value.toString() ? ' selected' : '') + '>' + ratioList[i].name + '</option>';
      }
      html += '</select>' + '<button type="button" title="' + lang.dialogBox.revertButton + '" aria-label="' + lang.dialogBox.revertButton + '" class="se-btn se-dialog-btn-revert" style="float: right;">' + core.icons.revert + '</button>' + '</div>' + '<div class="se-dialog-form se-dialog-form-footer"' + onlyPercentDisplay + onlyWidthDisplay + '>' + '<label><input type="checkbox" class="se-dialog-btn-check _se_video_check_proportion" checked/>&nbsp;' + lang.dialogBox.proportion + '</label>' + '</div>';
    }
    html += '' + '</div>' + '<div class="se-dialog-footer">' + '<div' + (option.videoAlignShow ? '' : ' style="display: none"') + '>' + '<label><input type="radio" name="suneditor_video_radio" class="se-dialog-btn-radio" value="none" checked>' + lang.dialogBox.basic + '</label>' + '<label><input type="radio" name="suneditor_video_radio" class="se-dialog-btn-radio" value="left">' + lang.dialogBox.left + '</label>' + '<label><input type="radio" name="suneditor_video_radio" class="se-dialog-btn-radio" value="center">' + lang.dialogBox.center + '</label>' + '<label><input type="radio" name="suneditor_video_radio" class="se-dialog-btn-radio" value="right">' + lang.dialogBox.right + '</label>' + '</div>' + '<button type="submit" class="se-btn-primary" title="' + lang.dialogBox.submitButton + '" aria-label="' + lang.dialogBox.submitButton + '"><span>' + lang.dialogBox.submitButton + '</span></button>' + '</div>' + '</form>';
    dialog.innerHTML = html;
    return dialog;
  },
  _fileInputChange: function _fileInputChange() {
    if (!this.videoInputFile.value) {
      this.videoUrlFile.removeAttribute('disabled');
      this.preview.style.textDecoration = '';
    } else {
      this.videoUrlFile.setAttribute('disabled', true);
      this.preview.style.textDecoration = 'line-through';
    }
  },
  _removeSelectedFiles: function _removeSelectedFiles(urlInput, preview) {
    this.value = '';
    if (urlInput) {
      urlInput.removeAttribute('disabled');
      preview.style.textDecoration = '';
    }
  },
  _onLinkPreview: function _onLinkPreview(context, protocol, e) {
    var value = e.target.value.trim();
    if (/^<iframe.*\/iframe>$/.test(value)) {
      context._linkValue = value;
      this.textContent = '<IFrame :src=".."></IFrame>';
    } else {
      context._linkValue = this.textContent = !value ? '' : protocol && value.indexOf('://') === -1 && value.indexOf('#') !== 0 ? protocol + value : value.indexOf('://') === -1 ? '/' + value : value;
    }
  },
  _setTagAttrs: function _setTagAttrs(element) {
    element.setAttribute('controls', true);
    var attrs = this.options.videoTagAttrs;
    if (!attrs) return;
    for (var key in attrs) {
      if (!this.util.hasOwn(attrs, key)) continue;
      element.setAttribute(key, attrs[key]);
    }
  },
  createVideoTag: function createVideoTag() {
    var videoTag = this.util.createElement('VIDEO');
    this.plugins.video._setTagAttrs.call(this, videoTag);
    return videoTag;
  },
  _setIframeAttrs: function _setIframeAttrs(element) {
    element.frameBorder = '0';
    element.allowFullscreen = true;
    var attrs = this.options.videoIframeAttrs;
    if (!attrs) return;
    for (var key in attrs) {
      if (!this.util.hasOwn(attrs, key)) continue;
      element.setAttribute(key, attrs[key]);
    }
  },
  createIframeTag: function createIframeTag() {
    var iframeTag = this.util.createElement('IFRAME');
    this.plugins.video._setIframeAttrs.call(this, iframeTag);
    return iframeTag;
  },
  /**
   * @Override @Required fileManager
   */
  fileTags: ['iframe', 'video'],
  /**
   * @Override core, resizing, fileManager
   * @description It is called from core.selectComponent.
   * @param {Element} element Target element
   */
  select: function select(element) {
    this.plugins.video.onModifyMode.call(this, element, this.plugins.resizing.call_controller_resize.call(this, element, 'video'));
  },
  /**
   * @Override fileManager, resizing
   */
  destroy: function destroy(element) {
    var frame = element || this.context.video._element;
    var container = this.context.video._container;
    var dataIndex = frame.getAttribute('data-index') * 1;
    var focusEl = container.previousElementSibling || container.nextElementSibling;
    var emptyDiv = container.parentNode;
    this.util.removeItem(container);
    this.plugins.video.init.call(this);
    this.controllersOff();
    if (emptyDiv !== this.context.element.wysiwyg) this.util.removeItemAllParents(emptyDiv, function (current) {
      return current.childNodes.length === 0;
    }, null);

    // focus
    this.focusEdge(focusEl);

    // event
    this.plugins.fileManager.deleteInfo.call(this, 'video', dataIndex, this.functions.onVideoUpload);

    // history stack
    this.history.push(false);
  },
  /**
   * @Required @Override dialog
   */
  on: function on(update) {
    var contextVideo = this.context.video;
    if (!update) {
      contextVideo.inputX.value = contextVideo._origin_w = this.options.videoWidth === contextVideo._defaultSizeX ? '' : this.options.videoWidth;
      contextVideo.inputY.value = contextVideo._origin_h = this.options.videoHeight === contextVideo._defaultSizeY ? '' : this.options.videoHeight;
      contextVideo.proportion.disabled = true;
      if (contextVideo.videoInputFile && this.options.videoMultipleFile) contextVideo.videoInputFile.setAttribute('multiple', 'multiple');
    } else {
      if (contextVideo.videoInputFile && this.options.videoMultipleFile) contextVideo.videoInputFile.removeAttribute('multiple');
    }
    if (contextVideo._resizing) {
      this.plugins.video.setVideoRatioSelect.call(this, contextVideo._origin_h || contextVideo._defaultRatio);
    }
  },
  /**
   * @Required @Override dialog
   */
  open: function open() {
    this.plugins.dialog.open.call(this, 'video', 'video' === this.currentControllerName);
  },
  setVideoRatio: function setVideoRatio(e) {
    var contextVideo = this.context.video;
    var value = e.target.options[e.target.selectedIndex].value;
    contextVideo._defaultSizeY = contextVideo._videoRatio = !value ? contextVideo._defaultSizeY : value * 100 + '%';
    contextVideo.inputY.placeholder = !value ? '' : value * 100 + '%';
    contextVideo.inputY.value = '';
  },
  /**
   * @Override resizing
   * @param {String} xy 'x': width, 'y': height
   * @param {KeyboardEvent} e Event object
   */
  setInputSize: function setInputSize(xy, e) {
    if (e && e.keyCode === 32) {
      e.preventDefault();
      return;
    }
    var contextVideo = this.context.video;
    this.plugins.resizing._module_setInputSize.call(this, contextVideo, xy);
    if (xy === 'y') {
      this.plugins.video.setVideoRatioSelect.call(this, e.target.value || contextVideo._defaultRatio);
    }
  },
  /**
   * @Override resizing
   */
  setRatio: function setRatio() {
    this.plugins.resizing._module_setRatio.call(this, this.context.video);
  },
  submit: function submit(e) {
    var contextVideo = this.context.video;
    var videoPlugin = this.plugins.video;
    e.preventDefault();
    e.stopPropagation();
    contextVideo._align = contextVideo.modal.querySelector('input[name="suneditor_video_radio"]:checked').value;
    try {
      if (contextVideo.videoInputFile && contextVideo.videoInputFile.files.length > 0) {
        this.showLoading();
        videoPlugin.submitAction.call(this, this.context.video.videoInputFile.files);
      } else if (contextVideo.videoUrlFile && contextVideo._linkValue.length > 0) {
        this.showLoading();
        videoPlugin.setup_url.call(this, contextVideo._linkValue);
      }
    } catch (error) {
      this.closeLoading();
      throw Error('[SUNEDITOR.video.submit.fail] cause : "' + error.message + '"');
    } finally {
      this.plugins.dialog.close.call(this);
    }
    return false;
  },
  submitAction: function submitAction(fileList) {
    if (fileList.length === 0) return;
    var fileSize = 0;
    var files = [];
    for (var i = 0, len = fileList.length; i < len; i++) {
      if (/video/i.test(fileList[i].type)) {
        files.push(fileList[i]);
        fileSize += fileList[i].size;
      }
    }
    var limitSize = this.options.videoUploadSizeLimit;
    if (limitSize > 0) {
      var infoSize = 0;
      var videosInfo = this.context.video._infoList;
      for (var _i = 0, _len = videosInfo.length; _i < _len; _i++) {
        infoSize += videosInfo[_i].size * 1;
      }
      if (fileSize + infoSize > limitSize) {
        this.closeLoading();
        var err = '[SUNEDITOR.videoUpload.fail] Size of uploadable total videos: ' + limitSize / 1000 + 'KB';
        if (typeof this.functions.onVideoUploadError !== 'function' || this.functions.onVideoUploadError(err, {
          'limitSize': limitSize,
          'currentSize': infoSize,
          'uploadSize': fileSize
        }, this)) {
          this.functions.noticeOpen(err);
        }
        return;
      }
    }
    var contextVideo = this.context.video;
    contextVideo._uploadFileLength = files.length;
    var info = {
      inputWidth: contextVideo.inputX.value,
      inputHeight: contextVideo.inputY.value,
      align: contextVideo._align,
      isUpdate: this.context.dialog.updateModal,
      element: contextVideo._element
    };
    if (typeof this.functions.onVideoUploadBefore === 'function') {
      var result = this.functions.onVideoUploadBefore(files, info, this, function (data) {
        if (data && this._w.Array.isArray(data.result)) {
          this.plugins.video.register.call(this, info, data);
        } else {
          this.plugins.video.upload.call(this, info, data);
        }
      }.bind(this));
      if (typeof result === 'undefined') return;
      if (!result) {
        this.closeLoading();
        return;
      }
      if (typeof result === 'object' && result.length > 0) files = result;
    }
    this.plugins.video.upload.call(this, info, files);
  },
  error: function error(message, response) {
    this.closeLoading();
    if (typeof this.functions.onVideoUploadError !== 'function' || this.functions.onVideoUploadError(message, response, this)) {
      this.functions.noticeOpen(message);
      throw Error('[SUNEDITOR.plugin.video.error] response: ' + message);
    }
  },
  upload: function upload(info, files) {
    if (!files) {
      this.closeLoading();
      return;
    }
    if (typeof files === 'string') {
      this.plugins.video.error.call(this, files, null);
      return;
    }
    var videoUploadUrl = this.options.videoUploadUrl;
    var filesLen = this.context.dialog.updateModal ? 1 : files.length;

    // server upload
    if (typeof videoUploadUrl === 'string' && videoUploadUrl.length > 0) {
      var formData = new FormData();
      for (var i = 0; i < filesLen; i++) {
        formData.append('file-' + i, files[i]);
      }
      this.plugins.fileManager.upload.call(this, videoUploadUrl, this.options.videoUploadHeader, formData, this.plugins.video.callBack_videoUpload.bind(this, info), this.functions.onVideoUploadError);
    } else {
      throw Error('[SUNEDITOR.videoUpload.fail] cause : There is no "videoUploadUrl" option.');
    }
  },
  callBack_videoUpload: function callBack_videoUpload(info, xmlHttp) {
    if (typeof this.functions.videoUploadHandler === 'function') {
      this.functions.videoUploadHandler(xmlHttp, info, this);
    } else {
      var response = JSON.parse(xmlHttp.responseText);
      if (response.errorMessage) {
        this.plugins.video.error.call(this, response.errorMessage, response);
      } else {
        this.plugins.video.register.call(this, info, response);
      }
    }
  },
  register: function register(info, response) {
    var fileList = response.result;
    var videoTag = this.plugins.video.createVideoTag.call(this);
    for (var i = 0, len = fileList.length, file; i < len; i++) {
      file = {
        name: fileList[i].name,
        size: fileList[i].size
      };
      this.plugins.video.create_video.call(this, info.isUpdate ? info.element : videoTag.cloneNode(false), fileList[i].url, info.inputWidth, info.inputHeight, info.align, file, info.isUpdate);
    }
    this.closeLoading();
  },
  setup_url: function setup_url(url) {
    try {
      var contextVideo = this.context.video;
      if (!url) url = contextVideo._linkValue;
      if (!url) return false;

      /** iframe source */
      if (/^<iframe.*\/iframe>$/.test(url)) {
        var oIframe = new this._w.DOMParser().parseFromString(url, 'text/html').querySelector('iframe');
        url = oIframe.src;
        if (url.length === 0) return false;
      }

      /** youtube */
      if (/youtu\.?be/.test(url)) {
        if (!/^http/.test(url)) url = 'https://' + url;
        url = url.replace('watch?v=', '');
        if (!/^\/\/.+\/embed\//.test(url)) {
          url = url.replace(url.match(/\/\/.+\//)[0], '//www.youtube.com/embed/').replace('&', '?&');
        }
        if (contextVideo._youtubeQuery.length > 0) {
          if (/\?/.test(url)) {
            var splitUrl = url.split('?');
            url = splitUrl[0] + '?' + contextVideo._youtubeQuery + '&' + splitUrl[1];
          } else {
            url += '?' + contextVideo._youtubeQuery;
          }
        }
      } else if (/vimeo\.com/.test(url)) {
        if (url.endsWith('/')) {
          url = url.slice(0, -1);
        }
        url = 'https://player.vimeo.com/video/' + url.slice(url.lastIndexOf('/') + 1);
      }
      this.plugins.video.create_video.call(this, this.plugins.video[!/embed|iframe|player|\/e\/|\.php|\.html?/.test(url) && !/vimeo\.com/.test(url) ? "createVideoTag" : "createIframeTag"].call(this), url, contextVideo.inputX.value, contextVideo.inputY.value, contextVideo._align, null, this.context.dialog.updateModal);
    } catch (error) {
      throw Error('[SUNEDITOR.video.upload.fail] cause : "' + error.message + '"');
    } finally {
      this.closeLoading();
    }
  },
  create_video: function create_video(oFrame, src, width, height, align, file, isUpdate) {
    this.context.resizing._resize_plugin = 'video';
    var contextVideo = this.context.video;
    var cover = null;
    var container = null;
    var init = false;

    /** update */
    if (isUpdate) {
      oFrame = contextVideo._element;
      if (oFrame.src !== src) {
        init = true;
        var isYoutube = /youtu\.?be/.test(src);
        var isVimeo = /vimeo\.com/.test(src);
        if ((isYoutube || isVimeo) && !/^iframe$/i.test(oFrame.nodeName)) {
          var newTag = this.plugins.video.createIframeTag.call(this);
          newTag.src = src;
          oFrame.parentNode.replaceChild(newTag, oFrame);
          contextVideo._element = oFrame = newTag;
        } else if (!isYoutube && !isVimeo && !/^videoo$/i.test(oFrame.nodeName)) {
          var _newTag = this.plugins.video.createVideoTag.call(this);
          _newTag.src = src;
          oFrame.parentNode.replaceChild(_newTag, oFrame);
          contextVideo._element = oFrame = _newTag;
        } else {
          oFrame.src = src;
        }
      }
      container = contextVideo._container;
      cover = this.util.getParentElement(oFrame, 'FIGURE');
    }
    /** create */else {
      init = true;
      oFrame.src = src;
      contextVideo._element = oFrame;
      cover = this.plugins.component.set_cover.call(this, oFrame);
      container = this.plugins.component.set_container.call(this, cover, 'se-video-container');
    }

    /** rendering */
    contextVideo._cover = cover;
    contextVideo._container = container;
    var inputUpdate = this.plugins.resizing._module_getSizeX.call(this, contextVideo) !== (width || contextVideo._defaultSizeX) || this.plugins.resizing._module_getSizeY.call(this, contextVideo) !== (height || contextVideo._videoRatio);
    var changeSize = !isUpdate || inputUpdate;
    if (contextVideo._resizing) {
      this.context.video._proportionChecked = contextVideo.proportion.checked;
      oFrame.setAttribute('data-proportion', contextVideo._proportionChecked);
    }

    // size
    var isPercent = false;
    if (changeSize) {
      isPercent = this.plugins.video.applySize.call(this);
    }

    // align
    if (!(isPercent && align === 'center')) {
      this.plugins.video.setAlign.call(this, null, oFrame, cover, container);
    }
    var changed = true;
    if (!isUpdate) {
      changed = this.insertComponent(container, false, true, !this.options.mediaAutoSelect);
      if (!this.options.mediaAutoSelect) {
        var line = this.appendFormatTag(container, null);
        if (line) this.setRange(line, 0, line, 0);
      }
    } else if (contextVideo._resizing && this.context.resizing._rotateVertical && changeSize) {
      this.plugins.resizing.setTransformSize.call(this, oFrame, null, null);
    }
    if (changed) {
      if (init) {
        this.plugins.fileManager.setInfo.call(this, 'video', oFrame, this.functions.onVideoUpload, file, true);
      }
      if (isUpdate) {
        this.selectComponent(oFrame, 'video');
        // history stack
        this.history.push(false);
      }
    }
    this.context.resizing._resize_plugin = '';
  },
  _update_videoCover: function _update_videoCover(oFrame) {
    if (!oFrame) return;
    var contextVideo = this.context.video;
    if (/^video$/i.test(oFrame.nodeName)) this.plugins.video._setTagAttrs.call(this, oFrame);else this.plugins.video._setIframeAttrs.call(this, oFrame);
    var existElement = this.util.isRangeFormatElement(oFrame.parentNode) || this.util.isWysiwygDiv(oFrame.parentNode) ? oFrame : this.util.getFormatElement(oFrame) || oFrame;
    var prevFrame = oFrame;
    contextVideo._element = oFrame = oFrame.cloneNode(true);
    var cover = contextVideo._cover = this.plugins.component.set_cover.call(this, oFrame);
    var container = contextVideo._container = this.plugins.component.set_container.call(this, cover, 'se-video-container');
    try {
      var figcaption = existElement.querySelector('figcaption');
      var caption = null;
      if (!!figcaption) {
        caption = this.util.createElement('DIV');
        caption.innerHTML = figcaption.innerHTML;
        this.util.removeItem(figcaption);
      }

      // size
      var size = (oFrame.getAttribute('data-size') || oFrame.getAttribute('data-origin') || '').split(',');
      this.plugins.video.applySize.call(this, size[0] || prevFrame.style.width || prevFrame.width || '', size[1] || prevFrame.style.height || prevFrame.height || '');

      // align
      var format = this.util.getFormatElement(prevFrame);
      if (format) contextVideo._align = format.style.textAlign || format.style.float;
      this.plugins.video.setAlign.call(this, null, oFrame, cover, container);
      if (this.util.isListCell(existElement)) {
        var refer = this.util.getParentElement(prevFrame, function (current) {
          return current.parentNode === existElement;
        });
        existElement.insertBefore(container, refer);
        this.util.removeItem(prevFrame);
        this.util.removeEmptyNode(refer, null);
      } else if (this.util.isFormatElement(existElement)) {
        var _refer = this.util.getParentElement(prevFrame, function (current) {
          return current.parentNode === existElement;
        });
        existElement = this.util.splitElement(existElement, _refer);
        existElement.parentNode.insertBefore(container, existElement);
        this.util.removeItem(prevFrame);
        this.util.removeEmptyNode(existElement, null);
        if (existElement.children.length === 0) existElement.innerHTML = this.util.htmlRemoveWhiteSpace(existElement.innerHTML);
      } else {
        existElement.parentNode.replaceChild(container, existElement);
      }
      if (!!caption) existElement.parentNode.insertBefore(caption, container.nextElementSibling);
    } catch (error) {
      console.warn('[SUNEDITOR.video.error] Maybe the video tag is nested.', error);
    }
    this.plugins.fileManager.setInfo.call(this, 'video', oFrame, this.functions.onVideoUpload, null, true);
    this.plugins.video.init.call(this);
  },
  /**
   * @Required @Override fileManager, resizing
   */
  onModifyMode: function onModifyMode(element, size) {
    var contextVideo = this.context.video;
    contextVideo._element = element;
    contextVideo._cover = this.util.getParentElement(element, 'FIGURE');
    contextVideo._container = this.util.getParentElement(element, this.util.isMediaComponent);
    contextVideo._align = element.style.float || element.getAttribute('data-align') || 'none';
    element.style.float = '';
    if (size) {
      contextVideo._element_w = size.w;
      contextVideo._element_h = size.h;
      contextVideo._element_t = size.t;
      contextVideo._element_l = size.l;
    }
    var origin = contextVideo._element.getAttribute('data-size') || contextVideo._element.getAttribute('data-origin');
    var w, h;
    if (origin) {
      origin = origin.split(',');
      w = origin[0];
      h = origin[1];
    } else if (size) {
      w = size.w;
      h = size.h;
    }
    contextVideo._origin_w = w || element.style.width || element.width || '';
    contextVideo._origin_h = h || element.style.height || element.height || '';
  },
  /**
   * @Required @Override fileManager, resizing
   */
  openModify: function openModify(notOpen) {
    var contextVideo = this.context.video;
    if (contextVideo.videoUrlFile) contextVideo._linkValue = contextVideo.preview.textContent = contextVideo.videoUrlFile.value = contextVideo._element.src || (contextVideo._element.querySelector('source') || '').src || '';
    (contextVideo.modal.querySelector('input[name="suneditor_video_radio"][value="' + contextVideo._align + '"]') || contextVideo.modal.querySelector('input[name="suneditor_video_radio"][value="none"]')).checked = true;
    if (contextVideo._resizing) {
      this.plugins.resizing._module_setModifyInputSize.call(this, contextVideo, this.plugins.video);
      var y = contextVideo._videoRatio = this.plugins.resizing._module_getSizeY.call(this, contextVideo);
      var ratioSelected = this.plugins.video.setVideoRatioSelect.call(this, y);
      if (!ratioSelected) contextVideo.inputY.value = contextVideo._onlyPercentage ? this.util.getNumber(y, 2) : y;
    }
    if (!notOpen) this.plugins.dialog.open.call(this, 'video', true);
  },
  setVideoRatioSelect: function setVideoRatioSelect(value) {
    var ratioSelected = false;
    var contextVideo = this.context.video;
    var ratioOptions = contextVideo.videoRatioOption.options;
    if (/%$/.test(value) || contextVideo._onlyPercentage) value = this.util.getNumber(value, 2) / 100 + '';else if (!this.util.isNumber(value) || value * 1 >= 1) value = '';
    contextVideo.inputY.placeholder = '';
    for (var i = 0, len = ratioOptions.length; i < len; i++) {
      if (ratioOptions[i].value === value) {
        ratioSelected = ratioOptions[i].selected = true;
        contextVideo.inputY.placeholder = !value ? '' : value * 100 + '%';
      } else ratioOptions[i].selected = false;
    }
    return ratioSelected;
  },
  /**
   * @Override fileManager
   */
  checkFileInfo: function checkFileInfo() {
    this.plugins.fileManager.checkInfo.call(this, 'video', ['iframe', 'video'], this.functions.onVideoUpload, this.plugins.video._update_videoCover.bind(this), true);
  },
  /**
   * @Override fileManager
   */
  resetFileInfo: function resetFileInfo() {
    this.plugins.fileManager.resetInfo.call(this, 'video', this.functions.onVideoUpload);
  },
  /**
   * @Override fileManager
   */
  applySize: function applySize(w, h) {
    var contextVideo = this.context.video;
    if (!w) w = contextVideo.inputX.value || this.options.videoWidth;
    if (!h) h = contextVideo.inputY.value || this.options.videoHeight;
    if (contextVideo._onlyPercentage || /%$/.test(w) || !w) {
      this.plugins.video.setPercentSize.call(this, w || '100%', h || (/%$/.test(contextVideo._videoRatio) ? contextVideo._videoRatio : contextVideo._defaultRatio));
      return true;
    } else if ((!w || w === 'auto') && (!h || h === 'auto')) {
      this.plugins.video.setAutoSize.call(this);
    } else {
      this.plugins.video.setSize.call(this, w, h || contextVideo._videoRatio || contextVideo._defaultRatio, false);
    }
    return false;
  },
  /**
   * @Override resizing
   */
  sizeRevert: function sizeRevert() {
    this.plugins.resizing._module_sizeRevert.call(this, this.context.video);
  },
  /**
   * @Override resizing
   */
  setSize: function setSize(w, h, notResetPercentage, direction) {
    var contextVideo = this.context.video;
    var onlyW = /^(rw|lw)$/.test(direction);
    var onlyH = /^(th|bh)$/.test(direction);
    if (!onlyH) w = this.util.getNumber(w, 0);
    if (!onlyW) h = this.util.isNumber(h) ? h + contextVideo.sizeUnit : !h ? '' : h;
    w = w ? w + contextVideo.sizeUnit : '';
    if (!onlyH) contextVideo._element.style.width = w;
    if (!onlyW) contextVideo._cover.style.paddingBottom = contextVideo._cover.style.height = h;
    if (!onlyH && !/%$/.test(w)) {
      contextVideo._cover.style.width = w;
      contextVideo._container.style.width = '';
    }
    if (!onlyW && !/%$/.test(h)) {
      contextVideo._element.style.height = h;
    } else {
      contextVideo._element.style.height = '';
    }
    if (!notResetPercentage) contextVideo._element.removeAttribute('data-percentage');

    // save current size
    this.plugins.resizing._module_saveCurrentSize.call(this, contextVideo);
  },
  /**
   * @Override resizing
   */
  setAutoSize: function setAutoSize() {
    this.plugins.video.setPercentSize.call(this, 100, this.context.video._defaultRatio);
  },
  /**
   * @Override resizing
   */
  setOriginSize: function setOriginSize(dataSize) {
    var contextVideo = this.context.video;
    contextVideo._element.removeAttribute('data-percentage');
    this.plugins.resizing.resetTransform.call(this, contextVideo._element);
    this.plugins.video.cancelPercentAttr.call(this);
    var originSize = ((dataSize ? contextVideo._element.getAttribute('data-size') : '') || contextVideo._element.getAttribute('data-origin') || '').split(',');
    if (originSize) {
      var w = originSize[0];
      var h = originSize[1];
      if (contextVideo._onlyPercentage || /%$/.test(w) && (/%$/.test(h) || !/\d/.test(h))) {
        this.plugins.video.setPercentSize.call(this, w, h);
      } else {
        this.plugins.video.setSize.call(this, w, h);
      }

      // save current size
      this.plugins.resizing._module_saveCurrentSize.call(this, contextVideo);
    }
  },
  /**
   * @Override resizing
   */
  setPercentSize: function setPercentSize(w, h) {
    var contextVideo = this.context.video;
    h = !!h && !/%$/.test(h) && !this.util.getNumber(h, 0) ? this.util.isNumber(h) ? h + '%' : h : this.util.isNumber(h) ? h + contextVideo.sizeUnit : h || contextVideo._defaultRatio;
    contextVideo._container.style.width = this.util.isNumber(w) ? w + '%' : w;
    contextVideo._container.style.height = '';
    contextVideo._cover.style.width = '100%';
    contextVideo._cover.style.height = h;
    contextVideo._cover.style.paddingBottom = h;
    contextVideo._element.style.width = '100%';
    contextVideo._element.style.height = '100%';
    contextVideo._element.style.maxWidth = '';
    if (contextVideo._align === 'center') this.plugins.video.setAlign.call(this, null, null, null, null);
    contextVideo._element.setAttribute('data-percentage', w + ',' + h);

    // save current size
    this.plugins.resizing._module_saveCurrentSize.call(this, contextVideo);
  },
  /**
   * @Override resizing
   */
  cancelPercentAttr: function cancelPercentAttr() {
    var contextVideo = this.context.video;
    contextVideo._cover.style.width = '';
    contextVideo._cover.style.height = '';
    contextVideo._cover.style.paddingBottom = '';
    contextVideo._container.style.width = '';
    contextVideo._container.style.height = '';
    this.util.removeClass(contextVideo._container, this.context.video._floatClassRegExp);
    this.util.addClass(contextVideo._container, '__se__float-' + contextVideo._align);
    if (contextVideo._align === 'center') this.plugins.video.setAlign.call(this, null, null, null, null);
  },
  /**
   * @Override resizing
   */
  setAlign: function setAlign(align, element, cover, container) {
    var contextVideo = this.context.video;
    if (!align) align = contextVideo._align;
    if (!element) element = contextVideo._element;
    if (!cover) cover = contextVideo._cover;
    if (!container) container = contextVideo._container;
    if (align && align !== 'none') {
      cover.style.margin = 'auto';
    } else {
      cover.style.margin = '0';
    }
    if (/%$/.test(element.style.width) && align === 'center') {
      container.style.minWidth = '100%';
      cover.style.width = container.style.width;
      cover.style.height = cover.style.height;
      cover.style.paddingBottom = !/%$/.test(cover.style.height) ? cover.style.height : this.util.getNumber(this.util.getNumber(cover.style.height, 2) / 100 * this.util.getNumber(cover.style.width, 2), 2) + '%';
    } else {
      container.style.minWidth = '';
      cover.style.width = this.context.resizing._rotateVertical ? element.style.height || element.offsetHeight : element.style.width || '100%';
      cover.style.paddingBottom = cover.style.height;
    }
    if (!this.util.hasClass(container, '__se__float-' + align)) {
      this.util.removeClass(container, contextVideo._floatClassRegExp);
      this.util.addClass(container, '__se__float-' + align);
    }
    element.setAttribute('data-align', align);
  },
  /**
   * @Override dialog
   */
  init: function init() {
    var contextVideo = this.context.video;
    if (contextVideo.videoInputFile) contextVideo.videoInputFile.value = '';
    if (contextVideo.videoUrlFile) contextVideo._linkValue = contextVideo.preview.textContent = contextVideo.videoUrlFile.value = '';
    if (contextVideo.videoInputFile && contextVideo.videoUrlFile) {
      contextVideo.videoUrlFile.removeAttribute('disabled');
      contextVideo.preview.style.textDecoration = '';
    }
    contextVideo._origin_w = this.options.videoWidth;
    contextVideo._origin_h = this.options.videoHeight;
    contextVideo.modal.querySelector('input[name="suneditor_video_radio"][value="none"]').checked = true;
    if (contextVideo._resizing) {
      contextVideo.inputX.value = this.options.videoWidth === contextVideo._defaultSizeX ? '' : this.options.videoWidth;
      contextVideo.inputY.value = this.options.videoHeight === contextVideo._defaultSizeY ? '' : this.options.videoHeight;
      contextVideo.proportion.checked = true;
      contextVideo.proportion.disabled = true;
      this.plugins.video.setVideoRatioSelect.call(this, contextVideo._defaultRatio);
    }
  }
});
// CONCATENATED MODULE: ./node_modules/suneditor/src/plugins/dialog/audio.js
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2017 JiHong Lee.
 * MIT license.
 */





/* harmony default export */ var audio = ({
  name: 'audio',
  display: 'dialog',
  add: function add(core) {
    core.addModule([dialog_default.a, component_default.a, fileManager_default.a]);
    var context = core.context;
    var contextAudio = context.audio = {
      _infoList: [],
      // @Override fileManager
      _infoIndex: 0,
      // @Override fileManager
      _uploadFileLength: 0,
      // @Override fileManager
      focusElement: null,
      // @Override dialog // This element has focus when the dialog is opened.
      targetSelect: null,
      _origin_w: core.options.audioWidth,
      _origin_h: core.options.audioHeight,
      _linkValue: '',
      // @require @Override component
      _element: null,
      _cover: null,
      _container: null
    };

    /** dialog */
    var audio_dialog = this.setDialog(core);
    contextAudio.modal = audio_dialog;
    contextAudio.audioInputFile = audio_dialog.querySelector('._se_audio_files');
    contextAudio.audioUrlFile = audio_dialog.querySelector('.se-input-url');
    contextAudio.focusElement = contextAudio.audioInputFile || contextAudio.audioUrlFile;
    contextAudio.preview = audio_dialog.querySelector('.se-link-preview');

    /** controller */
    var audio_controller = this.setController(core);
    contextAudio.controller = audio_controller;

    /** add event listeners */
    audio_dialog.querySelector('form').addEventListener('submit', this.submit.bind(core));
    if (contextAudio.audioInputFile) audio_dialog.querySelector('.se-dialog-files-edge-button').addEventListener('click', this._removeSelectedFiles.bind(contextAudio.audioInputFile, contextAudio.audioUrlFile, contextAudio.preview));
    if (contextAudio.audioInputFile && contextAudio.audioUrlFile) contextAudio.audioInputFile.addEventListener('change', this._fileInputChange.bind(contextAudio));
    audio_controller.addEventListener('click', this.onClick_controller.bind(core));
    if (contextAudio.audioUrlFile) contextAudio.audioUrlFile.addEventListener('input', this._onLinkPreview.bind(contextAudio.preview, contextAudio, core.options.linkProtocol));

    /** append html */
    context.dialog.modal.appendChild(audio_dialog);

    /** append controller */
    context.element.relative.appendChild(audio_controller);

    /** empty memory */
    audio_dialog = null, audio_controller = null;
  },
  /** HTML - dialog */
  setDialog: function setDialog(core) {
    var option = core.options;
    var lang = core.lang;
    var dialog = core.util.createElement('DIV');
    dialog.className = 'se-dialog-content';
    dialog.style.display = 'none';
    var html = '' + '<form method="post" enctype="multipart/form-data">' + '<div class="se-dialog-header">' + '<button type="button" data-command="close" class="se-btn se-dialog-close" title="' + lang.dialogBox.close + '" aria-label="' + lang.dialogBox.close + '">' + core.icons.cancel + '</button>' + '<span class="se-modal-title">' + lang.dialogBox.audioBox.title + '</span>' + '</div>' + '<div class="se-dialog-body">';
    if (option.audioFileInput) {
      html += '' + '<div class="se-dialog-form">' + '<label>' + lang.dialogBox.audioBox.file + '</label>' + '<div class="se-dialog-form-files">' + '<input class="se-input-form _se_audio_files" type="file" accept="' + option.audioAccept + '"' + (option.audioMultipleFile ? ' multiple="multiple"' : '') + '/>' + '<button type="button" data-command="filesRemove" class="se-btn se-dialog-files-edge-button se-file-remove" title="' + lang.controller.remove + '" aria-label="' + lang.controller.remove + '">' + core.icons.cancel + '</button>' + '</div>' + '</div>';
    }
    if (option.audioUrlInput) {
      html += '' + '<div class="se-dialog-form">' + '<label>' + lang.dialogBox.audioBox.url + '</label>' + '<input class="se-input-form se-input-url" type="text" />' + '<pre class="se-link-preview"></pre>' + '</div>';
    }
    html += '' + '</div>' + '<div class="se-dialog-footer">' + '<button type="submit" class="se-btn-primary" title="' + lang.dialogBox.submitButton + '" aria-label="' + lang.dialogBox.submitButton + '"><span>' + lang.dialogBox.submitButton + '</span></button>' + '</div>' + '</form>';
    dialog.innerHTML = html;
    return dialog;
  },
  /** HTML - controller */
  setController: function setController(core) {
    var lang = core.lang;
    var icons = core.icons;
    var link_btn = core.util.createElement('DIV');
    link_btn.className = 'se-controller se-controller-link';
    link_btn.innerHTML = '' + '<div class="se-arrow se-arrow-up"></div>' + '<div class="link-content">' + '<div class="se-btn-group">' + '<button type="button" data-command="update" tabindex="-1" class="se-tooltip">' + icons.edit + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.edit + '</span></span>' + '</button>' + '<button type="button" data-command="delete" tabindex="-1" class="se-tooltip">' + icons.delete + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.remove + '</span></span>' + '</button>' + '</div>' + '</div>';
    return link_btn;
  },
  // Disable url input when uploading files
  _fileInputChange: function _fileInputChange() {
    if (!this.audioInputFile.value) {
      this.audioUrlFile.removeAttribute('disabled');
      this.preview.style.textDecoration = '';
    } else {
      this.audioUrlFile.setAttribute('disabled', true);
      this.preview.style.textDecoration = 'line-through';
    }
  },
  // Disable url input when uploading files
  _removeSelectedFiles: function _removeSelectedFiles(urlInput, preview) {
    this.value = '';
    if (urlInput) {
      urlInput.removeAttribute('disabled');
      preview.style.textDecoration = '';
    }
  },
  // create new audio tag
  _createAudioTag: function _createAudioTag() {
    var oAudio = this.util.createElement('AUDIO');
    this.plugins.audio._setTagAttrs.call(this, oAudio);
    var w = this.context.audio._origin_w;
    var h = this.context.audio._origin_h;
    oAudio.setAttribute('origin-size', w + ',' + h);
    oAudio.style.cssText = (w ? 'width:' + w + '; ' : '') + (h ? 'height:' + h + ';' : '');
    return oAudio;
  },
  _setTagAttrs: function _setTagAttrs(element) {
    element.setAttribute('controls', true);
    var attrs = this.options.audioTagAttrs;
    if (!attrs) return;
    for (var key in attrs) {
      if (!this.util.hasOwn(attrs, key)) continue;
      element.setAttribute(key, attrs[key]);
    }
  },
  _onLinkPreview: function _onLinkPreview(context, protocol, e) {
    var value = e.target.value.trim();
    context._linkValue = this.textContent = !value ? '' : protocol && value.indexOf('://') === -1 && value.indexOf('#') !== 0 ? protocol + value : value.indexOf('://') === -1 ? '/' + value : value;
  },
  /**
   * @Required @Override fileManager
   */
  fileTags: ['audio'],
  /**
   * @Override core, fileManager, resizing
   * @description It is called from core.selectComponent.
   * @param {Element} element Target element
   */
  select: function select(element) {
    this.plugins.audio.onModifyMode.call(this, element);
  },
  /**
   * @Override fileManager, resizing 
   */
  destroy: function destroy(element) {
    element = element || this.context.audio._element;
    var container = this.util.getParentElement(element, this.util.isComponent) || element;
    var dataIndex = element.getAttribute('data-index') * 1;
    var focusEl = container.previousElementSibling || container.nextElementSibling;
    var emptyDiv = container.parentNode;
    this.util.removeItem(container);
    this.plugins.audio.init.call(this);
    this.controllersOff();
    if (emptyDiv !== this.context.element.wysiwyg) this.util.removeItemAllParents(emptyDiv, function (current) {
      return current.childNodes.length === 0;
    }, null);

    // focus
    this.focusEdge(focusEl);

    // fileManager event
    this.plugins.fileManager.deleteInfo.call(this, 'audio', dataIndex, this.functions.onAudioUpload);

    // history stack
    this.history.push(false);
  },
  /**
   * @Override fileManager
   */
  checkFileInfo: function checkFileInfo() {
    this.plugins.fileManager.checkInfo.call(this, 'audio', ['audio'], this.functions.onAudioUpload, this.plugins.audio.updateCover.bind(this), false);
  },
  /**
   * @Override fileManager
   */
  resetFileInfo: function resetFileInfo() {
    this.plugins.fileManager.resetInfo.call(this, 'audio', this.functions.onAudioUpload);
  },
  /**
   * @Required @Override dialog
   */
  on: function on(update) {
    var contextAudio = this.context.audio;
    if (!update) {
      this.plugins.audio.init.call(this);
      if (contextAudio.audioInputFile && this.options.audioMultipleFile) contextAudio.audioInputFile.setAttribute('multiple', 'multiple');
    } else if (contextAudio._element) {
      this.context.dialog.updateModal = true;
      contextAudio._linkValue = contextAudio.preview.textContent = contextAudio.audioUrlFile.value = contextAudio._element.src;
      if (contextAudio.audioInputFile && this.options.audioMultipleFile) contextAudio.audioInputFile.removeAttribute('multiple');
    } else {
      if (contextAudio.audioInputFile && this.options.audioMultipleFile) contextAudio.audioInputFile.removeAttribute('multiple');
    }
  },
  /**
   * @Required @Override dialog
   */
  open: function open() {
    this.plugins.dialog.open.call(this, 'audio', 'audio' === this.currentControllerName);
  },
  submit: function submit(e) {
    var contextAudio = this.context.audio;
    e.preventDefault();
    e.stopPropagation();
    try {
      if (contextAudio.audioInputFile && contextAudio.audioInputFile.files.length > 0) {
        this.showLoading();
        this.plugins.audio.submitAction.call(this, contextAudio.audioInputFile.files);
      } else if (contextAudio.audioUrlFile && contextAudio._linkValue.length > 0) {
        this.showLoading();
        this.plugins.audio.setupUrl.call(this, contextAudio._linkValue);
      }
    } catch (error) {
      this.closeLoading();
      throw Error('[SUNEDITOR.audio.submit.fail] cause : "' + error.message + '"');
    } finally {
      this.plugins.dialog.close.call(this);
    }
    return false;
  },
  submitAction: function submitAction(fileList) {
    if (fileList.length === 0) return;
    var fileSize = 0;
    var files = [];
    for (var i = 0, len = fileList.length; i < len; i++) {
      if (/audio/i.test(fileList[i].type)) {
        files.push(fileList[i]);
        fileSize += fileList[i].size;
      }
    }
    var limitSize = this.options.audioUploadSizeLimit;
    if (limitSize > 0) {
      var infoSize = 0;
      var audiosInfo = this.context.audio._infoList;
      for (var _i = 0, _len = audiosInfo.length; _i < _len; _i++) {
        infoSize += audiosInfo[_i].size * 1;
      }
      if (fileSize + infoSize > limitSize) {
        this.closeLoading();
        var err = '[SUNEDITOR.audioUpload.fail] Size of uploadable total audios: ' + limitSize / 1000 + 'KB';
        if (typeof this.functions.onAudioUploadError !== 'function' || this.functions.onAudioUploadError(err, {
          'limitSize': limitSize,
          'currentSize': infoSize,
          'uploadSize': fileSize
        }, this)) {
          this.functions.noticeOpen(err);
        }
        return;
      }
    }
    var contextAudio = this.context.audio;
    contextAudio._uploadFileLength = files.length;
    var info = {
      isUpdate: this.context.dialog.updateModal,
      element: contextAudio._element
    };
    if (typeof this.functions.onAudioUploadBefore === 'function') {
      var result = this.functions.onAudioUploadBefore(files, info, this, function (data) {
        if (data && this._w.Array.isArray(data.result)) {
          this.plugins.audio.register.call(this, info, data);
        } else {
          this.plugins.audio.upload.call(this, info, data);
        }
      }.bind(this));
      if (typeof result === 'undefined') return;
      if (!result) {
        this.closeLoading();
        return;
      }
      if (typeof result === 'object' && result.length > 0) files = result;
    }
    this.plugins.audio.upload.call(this, info, files);
  },
  error: function error(message, response) {
    this.closeLoading();
    if (typeof this.functions.onAudioUploadError !== 'function' || this.functions.onAudioUploadError(message, response, this)) {
      this.functions.noticeOpen(message);
      throw Error('[SUNEDITOR.plugin.audio.exception] response: ' + message);
    }
  },
  upload: function upload(info, files) {
    if (!files) {
      this.closeLoading();
      return;
    }
    if (typeof files === 'string') {
      this.plugins.audio.error.call(this, files, null);
      return;
    }
    var audioUploadUrl = this.options.audioUploadUrl;
    var filesLen = this.context.dialog.updateModal ? 1 : files.length;

    // create formData
    var formData = new FormData();
    for (var i = 0; i < filesLen; i++) {
      formData.append('file-' + i, files[i]);
    }

    // server upload
    this.plugins.fileManager.upload.call(this, audioUploadUrl, this.options.audioUploadHeader, formData, this.plugins.audio.callBack_upload.bind(this, info), this.functions.onAudioUploadError);
  },
  callBack_upload: function callBack_upload(info, xmlHttp) {
    if (typeof this.functions.audioUploadHandler === 'function') {
      this.functions.audioUploadHandler(xmlHttp, info, this);
    } else {
      var response = JSON.parse(xmlHttp.responseText);
      if (response.errorMessage) {
        this.plugins.audio.error.call(this, response.errorMessage, response);
      } else {
        this.plugins.audio.register.call(this, info, response);
      }
    }
  },
  register: function register(info, response) {
    var fileList = response.result;
    for (var i = 0, len = fileList.length, file, oAudio; i < len; i++) {
      if (info.isUpdate) oAudio = info.element;else oAudio = this.plugins.audio._createAudioTag.call(this);
      file = {
        name: fileList[i].name,
        size: fileList[i].size
      };
      this.plugins.audio.create_audio.call(this, oAudio, fileList[i].url, file, info.isUpdate);
    }
    this.closeLoading();
  },
  setupUrl: function setupUrl(src) {
    try {
      if (src.length === 0) return false;
      this.plugins.audio.create_audio.call(this, this.plugins.audio._createAudioTag.call(this), src, null, this.context.dialog.updateModal);
    } catch (error) {
      throw Error('[SUNEDITOR.audio.audio.fail] cause : "' + error.message + '"');
    } finally {
      this.closeLoading();
    }
  },
  create_audio: function create_audio(element, src, file, isUpdate) {
    var contextAudio = this.context.audio;

    // create new tag
    if (!isUpdate) {
      element.src = src;
      var cover = this.plugins.component.set_cover.call(this, element);
      var container = this.plugins.component.set_container.call(this, cover, '');
      if (!this.insertComponent(container, false, true, !this.options.mediaAutoSelect)) {
        this.focus();
        return;
      }
      if (!this.options.mediaAutoSelect) {
        var line = this.appendFormatTag(container, null);
        if (line) this.setRange(line, 0, line, 0);
      }
    } // update
    else {
      if (contextAudio._element) element = contextAudio._element;
      if (element && element.src !== src) {
        element.src = src;
        this.selectComponent(element, 'audio');
      } else {
        this.selectComponent(element, 'audio');
        return;
      }
    }
    this.plugins.fileManager.setInfo.call(this, 'audio', element, this.functions.onAudioUpload, file, false);
    if (isUpdate) this.history.push(false);
  },
  updateCover: function updateCover(element) {
    var contextAudio = this.context.audio;
    this.plugins.audio._setTagAttrs.call(this, element);

    // find component element
    var existElement = this.util.isRangeFormatElement(element.parentNode) || this.util.isWysiwygDiv(element.parentNode) ? element : this.util.getFormatElement(element) || element;

    // clone element
    var prevElement = element;
    contextAudio._element = element = element.cloneNode(false);
    var cover = this.plugins.component.set_cover.call(this, element);
    var container = this.plugins.component.set_container.call(this, cover, 'se-audio-container');
    try {
      if (this.util.isListCell(existElement)) {
        var refer = this.util.getParentElement(prevElement, function (current) {
          return current.parentNode === existElement;
        });
        existElement.insertBefore(container, refer);
        this.util.removeItem(prevElement);
        this.util.removeEmptyNode(refer, null);
      } else if (this.util.isFormatElement(existElement)) {
        var _refer = this.util.getParentElement(prevElement, function (current) {
          return current.parentNode === existElement;
        });
        existElement = this.util.splitElement(existElement, _refer);
        existElement.parentNode.insertBefore(container, existElement);
        this.util.removeItem(prevElement);
        this.util.removeEmptyNode(existElement, null);
        if (existElement.children.length === 0) existElement.innerHTML = this.util.htmlRemoveWhiteSpace(existElement.innerHTML);
      } else {
        existElement.parentNode.replaceChild(container, existElement);
      }
    } catch (error) {
      console.warn('[SUNEDITOR.audio.error] Maybe the audio tag is nested.', error);
    }
    this.plugins.fileManager.setInfo.call(this, 'audio', element, this.functions.onAudioUpload, null, false);
    this.plugins.audio.init.call(this);
  },
  /**
   * @Required @Override fileManager, resizing
   */
  onModifyMode: function onModifyMode(selectionTag) {
    var contextAudio = this.context.audio;
    this.setControllerPosition(contextAudio.controller, selectionTag, 'bottom', {
      left: 0,
      top: 0
    });
    this.controllersOn(contextAudio.controller, selectionTag, this.plugins.audio.onControllerOff.bind(this, selectionTag), 'audio');
    this.util.addClass(selectionTag, 'active');
    contextAudio._element = selectionTag;
    contextAudio._cover = this.util.getParentElement(selectionTag, 'FIGURE');
    contextAudio._container = this.util.getParentElement(selectionTag, this.util.isComponent);
  },
  /**
   * @Required @Override fileManager, resizing
   */
  openModify: function openModify(notOpen) {
    if (this.context.audio.audioUrlFile) {
      var contextAudio = this.context.audio;
      contextAudio._linkValue = contextAudio.preview.textContent = contextAudio.audioUrlFile.value = contextAudio._element.src;
    }
    if (!notOpen) this.plugins.dialog.open.call(this, 'audio', true);
  },
  onClick_controller: function onClick_controller(e) {
    e.stopPropagation();
    var command = e.target.getAttribute('data-command');
    if (!command) return;
    e.preventDefault();
    if (/update/.test(command)) {
      this.plugins.audio.openModify.call(this, false);
    } else {
      /** delete */
      this.plugins.audio.destroy.call(this, this.context.audio._element);
    }
    this.controllersOff();
  },
  onControllerOff: function onControllerOff(selectionTag) {
    this.util.removeClass(selectionTag, 'active');
    this.context.audio.controller.style.display = 'none';
  },
  /**
   * @Required @Override dialog
   */
  init: function init() {
    if (this.context.dialog.updateModal) return;
    var contextAudio = this.context.audio;
    if (contextAudio.audioInputFile) contextAudio.audioInputFile.value = '';
    if (contextAudio.audioUrlFile) contextAudio._linkValue = contextAudio.preview.textContent = contextAudio.audioUrlFile.value = '';
    if (contextAudio.audioInputFile && contextAudio.audioUrlFile) {
      contextAudio.audioUrlFile.removeAttribute('disabled');
      contextAudio.preview.style.textDecoration = '';
    }
    contextAudio._element = null;
  }
});
// CONCATENATED MODULE: ./node_modules/suneditor/src/plugins/dialog/math.js



var KATEX_WEBSITE = "https://katex.org/docs/supported.html";
/* harmony default export */ var math = ({
  name: 'math',
  display: 'dialog',
  add: function add(core) {
    core.addModule([dialog_default.a]);
    var context = core.context;
    context.math = {
      focusElement: null,
      // @Override dialog // This element has focus when the dialog is opened.
      previewElement: null,
      fontSizeElement: null,
      defaultFontSize: '',
      _mathExp: null
    };

    /** math dialog */
    var math_dialog = this.setDialog(core);
    context.math.modal = math_dialog;
    context.math.focusElement = math_dialog.querySelector('.se-math-exp');
    context.math.previewElement = math_dialog.querySelector('.se-math-preview');
    context.math.fontSizeElement = math_dialog.querySelector('.se-math-size');
    context.math.focusElement.addEventListener(core.util.isIE ? 'textinput' : 'input', this._renderMathExp.bind(core, context.math), false);
    context.math.fontSizeElement.addEventListener('change', function (e) {
      this.fontSize = e.target.value;
    }.bind(context.math.previewElement.style), false);

    /** math controller */
    var math_controller = this.setController_MathButton(core);
    context.math.mathController = math_controller;
    context.math._mathExp = null;

    /** add event listeners */
    math_dialog.querySelector('form').addEventListener('submit', this.submit.bind(core), false);
    math_controller.addEventListener('click', this.onClick_mathController.bind(core));
    context.math.previewElement.style.fontSize = context.math.defaultFontSize;

    /** append html */
    context.dialog.modal.appendChild(math_dialog);
    context.element.relative.appendChild(math_controller);

    /** empty memory */
    math_dialog = null, math_controller = null;
  },
  /** dialog */
  setDialog: function setDialog(core) {
    var lang = core.lang;
    var dialog = core.util.createElement('DIV');
    var fontSize = core.options.mathFontSize;
    var defaultFontSize = fontSize[0].value;
    dialog.className = 'se-dialog-content';
    dialog.style.display = 'none';
    var html = '' + '<form>' + '<div class="se-dialog-header">' + '<button type="button" data-command="close" class="se-btn se-dialog-close" title="' + lang.dialogBox.close + '" aria-label="' + lang.dialogBox.close + '">' + core.icons.cancel + '</button>' + '<span class="se-modal-title">' + lang.dialogBox.mathBox.title + '</span>' + '</div>' + '<div class="se-dialog-body">' + '<div class="se-dialog-form">' + '<label>' + lang.dialogBox.mathBox.inputLabel + ' (<a href="' + KATEX_WEBSITE + '" target="_blank">KaTeX</a>)</label>' + '<textarea class="se-input-form se-math-exp" type="text"></textarea>' + '</div>' + '<div class="se-dialog-form">' + '<label>' + lang.dialogBox.mathBox.fontSizeLabel + '</label>' + '<select class="se-input-select se-math-size">';
    for (var i = 0, len = fontSize.length, f; i < len; i++) {
      f = fontSize[i];
      if (f.default) defaultFontSize = f.value;
      html += '<option value="' + f.value + '"' + (f.default ? ' selected' : '') + '>' + f.text + '</option>';
    }
    html += '</select>' + '</div>' + '<div class="se-dialog-form">' + '<label>' + lang.dialogBox.mathBox.previewLabel + '</label>' + '<p class="se-math-preview"></p>' + '</div>' + '</div>' + '<div class="se-dialog-footer">' + '<button type="submit" class="se-btn-primary" title="' + lang.dialogBox.submitButton + '" aria-label="' + lang.dialogBox.submitButton + '"><span>' + lang.dialogBox.submitButton + '</span></button>' + '</div>' + '</form>';
    core.context.math.defaultFontSize = defaultFontSize;
    dialog.innerHTML = html;
    return dialog;
  },
  /** modify controller button */
  setController_MathButton: function setController_MathButton(core) {
    var lang = core.lang;
    var math_btn = core.util.createElement('DIV');
    math_btn.className = 'se-controller se-controller-link';
    math_btn.innerHTML = '' + '<div class="se-arrow se-arrow-up"></div>' + '<div class="link-content">' + '<div class="se-btn-group">' + '<button type="button" data-command="update" tabindex="-1" class="se-btn se-tooltip">' + core.icons.edit + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.edit + '</span></span>' + '</button>' + '<button type="button" data-command="delete" tabindex="-1" class="se-btn se-tooltip">' + core.icons.delete + '<span class="se-tooltip-inner"><span class="se-tooltip-text">' + lang.controller.remove + '</span></span>' + '</button>' + '</div>' + '</div>' + '';
    return math_btn;
  },
  /**
   * @Required @Override dialog
   */
  open: function open() {
    this.plugins.dialog.open.call(this, 'math', 'math' === this.currentControllerName);
  },
  /**
   * @Override core - managedTagsInfo
   */
  managedTags: function managedTags() {
    return {
      className: 'katex',
      method: function method(element) {
        if (!element.getAttribute('data-exp') || !this.options.katex) return;
        var dom = this._d.createRange().createContextualFragment(this.plugins.math._renderer.call(this, this.util.HTMLDecoder(element.getAttribute('data-exp'))));
        element.innerHTML = dom.querySelector('.katex').innerHTML;
      }
    };
  },
  _renderer: function _renderer(exp) {
    var result = '';
    try {
      this.util.removeClass(this.context.math.focusElement, 'se-error');
      result = this.options.katex.src.renderToString(exp, {
        throwOnError: true,
        displayMode: true
      });
    } catch (error) {
      this.util.addClass(this.context.math.focusElement, 'se-error');
      result = '<span class="se-math-katex-error">Katex syntax error. (Refer <a href="' + KATEX_WEBSITE + '" target="_blank">KaTeX</a>)</span>';
      console.warn('[SUNEDITOR.math.Katex.error] ', error);
    }
    return result;
  },
  _renderMathExp: function _renderMathExp(contextMath, e) {
    contextMath.previewElement.innerHTML = this.plugins.math._renderer.call(this, e.target.value);
  },
  submit: function submit(e) {
    this.showLoading();
    e.preventDefault();
    e.stopPropagation();
    var submitAction = function () {
      if (this.context.math.focusElement.value.trim().length === 0) return false;
      var contextMath = this.context.math;
      var mathExp = contextMath.focusElement.value;
      var katexEl = contextMath.previewElement.querySelector('.katex');
      if (!katexEl) return false;
      katexEl.className = '__se__katex ' + katexEl.className;
      katexEl.setAttribute('contenteditable', false);
      katexEl.setAttribute('data-exp', this.util.HTMLEncoder(mathExp));
      katexEl.setAttribute('data-font-size', contextMath.fontSizeElement.value);
      katexEl.style.fontSize = contextMath.fontSizeElement.value;
      if (!this.context.dialog.updateModal) {
        var selectedFormats = this.getSelectedElements();
        if (selectedFormats.length > 1) {
          var oFormat = this.util.createElement(selectedFormats[0].nodeName);
          oFormat.appendChild(katexEl);
          if (!this.insertNode(oFormat, null, true)) return false;
        } else {
          if (!this.insertNode(katexEl, null, true)) return false;
        }
        var empty = this.util.createTextNode(this.util.zeroWidthSpace);
        katexEl.parentNode.insertBefore(empty, katexEl.nextSibling);
        this.setRange(katexEl, 0, katexEl, 1);
      } else {
        var containerEl = this.util.getParentElement(contextMath._mathExp, '.katex');
        containerEl.parentNode.replaceChild(katexEl, containerEl);
        this.setRange(katexEl, 0, katexEl, 1);
      }
      contextMath.focusElement.value = '';
      contextMath.fontSizeElement.value = '1em';
      contextMath.previewElement.style.fontSize = '1em';
      contextMath.previewElement.innerHTML = '';
      return true;
    }.bind(this);
    try {
      if (submitAction()) {
        this.plugins.dialog.close.call(this);
        // history stack
        this.history.push(false);
      }
    } catch (e) {
      this.plugins.dialog.close.call(this);
    } finally {
      this.closeLoading();
    }
    return false;
  },
  active: function active(element) {
    if (!element) {
      if (this.controllerArray.indexOf(this.context.math.mathController) > -1) {
        this.controllersOff();
      }
    } else if (element.getAttribute('data-exp')) {
      if (this.controllerArray.indexOf(this.context.math.mathController) < 0) {
        this.setRange(element, 0, element, 1);
        this.plugins.math.call_controller.call(this, element);
      }
      return true;
    }
    return false;
  },
  on: function on(update) {
    if (!update) {
      this.plugins.math.init.call(this);
    } else {
      var contextMath = this.context.math;
      if (contextMath._mathExp) {
        var exp = this.util.HTMLDecoder(contextMath._mathExp.getAttribute('data-exp'));
        var fontSize = contextMath._mathExp.getAttribute('data-font-size') || '1em';
        this.context.dialog.updateModal = true;
        contextMath.focusElement.value = exp;
        contextMath.fontSizeElement.value = fontSize;
        contextMath.previewElement.innerHTML = this.plugins.math._renderer.call(this, exp);
        contextMath.previewElement.style.fontSize = fontSize;
      }
    }
  },
  call_controller: function call_controller(mathTag) {
    this.context.math._mathExp = mathTag;
    var mathBtn = this.context.math.mathController;
    this.setControllerPosition(mathBtn, mathTag, 'bottom', {
      left: 0,
      top: 0
    });
    this.controllersOn(mathBtn, mathTag, 'math');
  },
  onClick_mathController: function onClick_mathController(e) {
    e.stopPropagation();
    var command = e.target.getAttribute('data-command') || e.target.parentNode.getAttribute('data-command');
    if (!command) return;
    e.preventDefault();
    if (/update/.test(command)) {
      this.context.math.focusElement.value = this.util.HTMLDecoder(this.context.math._mathExp.getAttribute('data-exp'));
      this.plugins.dialog.open.call(this, 'math', true);
    } else {
      /** delete */
      this.util.removeItem(this.context.math._mathExp);
      this.context.math._mathExp = null;
      this.focus();

      // history stack
      this.history.push(false);
    }
    this.controllersOff();
  },
  init: function init() {
    var contextMath = this.context.math;
    contextMath.mathController.style.display = 'none';
    contextMath._mathExp = null;
    contextMath.focusElement.value = '';
    contextMath.previewElement.innerHTML = '';
  }
});
// EXTERNAL MODULE: ./node_modules/suneditor/src/plugins/modules/fileBrowser.js
var fileBrowser = __webpack_require__(2071);
var fileBrowser_default = /*#__PURE__*/__webpack_require__.n(fileBrowser);

// CONCATENATED MODULE: ./node_modules/suneditor/src/plugins/fileBrowser/imageGallery.js
/*
 * wysiwyg web editor
 *
 * suneditor.js
 * Copyright 2017 JiHong Lee.
 * MIT license.
 */



/* harmony default export */ var imageGallery = ({
  name: 'imageGallery',
  /**
   * @description Constructor
   * @param {Object} core Core object 
   */
  add: function add(core) {
    core.addModule([fileBrowser_default.a]);
    var context = core.context;
    context.imageGallery = {
      title: core.lang.toolbar.imageGallery,
      // @Required @Override fileBrowser - File browser window title.
      url: core.options.imageGalleryUrl,
      // @Required @Override fileBrowser - File server url.
      header: core.options.imageGalleryHeader,
      // @Required @Override fileBrowser - File server http header.
      listClass: 'se-image-list',
      // @Required @Override fileBrowser - Class name of list div.
      itemTemplateHandler: this.drawItems,
      // @Required @Override fileBrowser - Function that defines the HTML of an file item.
      selectorHandler: this.setImage.bind(core),
      // @Required @Override fileBrowser - Function that action when item click.
      columnSize: 4 // @Option @Override fileBrowser - Number of "div.se-file-item-column" to be created (default: 4)
    };
  },

  /**
   * @Required @Override fileBrowser
   * @description Open a file browser.
   * @param {Function|null} selectorHandler When the function comes as an argument value, it substitutes "context.selectorHandler".
   */
  open: function open(selectorHandler) {
    this.plugins.fileBrowser.open.call(this, 'imageGallery', selectorHandler);
  },
  /**
   * @Required @Override fileBrowser
   * @description Define the HTML of the item to be put in "div.se-file-item-column".
   * Format: [
   *      { src: "image src", name: "name(@option)", alt: "image alt(@option)", tag: "tag name(@option)" }
   * ]
   * @param {Object} item Item of the response data's array
   */
  drawItems: function drawItems(item) {
    var srcName = item.src.split('/').pop();
    return '<div class="se-file-item-img"><img src="' + (item.thumbnail || item.src) + '" alt="' + (item.alt || srcName) + '" data-command="pick" data-value="' + (item.src || item.thumbnail) + '">' + '<div class="se-file-img-name se-file-name-back"></div>' + '<div class="se-file-img-name __se__img_name">' + (item.name || srcName) + '</div>' + '</div>';
  },
  setImage: function setImage(target) {
    this.callPlugin('image', function () {
      var file = {
        name: target.parentNode.querySelector('.__se__img_name').textContent,
        size: 0
      };
      this.plugins.image.create_image.call(this, target.getAttribute('data-value'), null, this.context.image._origin_w, this.context.image._origin_h, 'none', file, target.alt);
    }.bind(this), null);
  }
});
// CONCATENATED MODULE: ./node_modules/suneditor/src/plugins/index.js


// command


// submenu














// dialog






// file browser


/* harmony default export */ var plugins = __webpack_exports__["default"] = ({
  blockquote: blockquote,
  align: align,
  font: font,
  fontSize: fontSize,
  fontColor: fontColor,
  hiliteColor: hiliteColor,
  horizontalRule: horizontalRule,
  list: list,
  table: table,
  formatBlock: formatBlock,
  lineHeight: lineHeight,
  template: template,
  paragraphStyle: paragraphStyle,
  textStyle: textStyle,
  link: dialog_link,
  image: dialog_image,
  video: video,
  audio: audio,
  math: math,
  imageGallery: imageGallery
});

/***/ })

}]);
//# sourceMappingURL=vendors~PARAGRAPH.70436a1c6344ae75c10a.js.map